--[[

--TODO: document, credits, etc.
--board art: Francesco Neri https://boardgamegeek.com/image/540942/el-grande

  -MVP TODO items remaining:

  -TODO: maybe implement "missing" cards from player's edition.   Some anyway.
          Cool:  13, 43, 53 (cool but very hard), 73, 113(maybe, kinda hard), 153
          Not gonna do: 23, 83,

  -Ongoing stuff
  -TODO: base game: disable Done/Undo buttons during action (when Finished/Reset are showing).  Only show during action:stage == 'main'
  -BUG: base game: king card didn't flip face up at start of bidding phase (king card was held by last player before bid phase)
        WORKAROUND: just unlock and flip it manually.
  -BUG: not locking power card when moved to held_cards area, see code that places the card
        Maybe fixed with wait 1 frame then wait.condition?  test this.
  -BUG: I&K card 15: moved cube court to board.  Then moved that cube to Castillo.  Undo fails, cannot locate object.  Undo not being updated for Castillo.
  -TODO: retest Veto now that wait.condition over use is better
  -TODO: Mostly done.  Make scoring state/data persist. Make coro rewind/reload safe.
          Works for saved game reload. May work for rewind but multiple rewinds can get it confused.
          If very careful about the rewind then it's ok.
  -TODO: retest the entire base game.  Much shared code changed in implementing I&K expansion

  -Really hard stuff
  -TODO: how to undo last action step when vetoed.  Would need sequential undo and don't have that.  Also some action steps might create more than
         one undo entry.  Might be able to modify actions to always set a last action step (similer to an undo entry) but that is a lot of code
         paths that would need updating.  For now, players need to announce what they're doing and veto player must trigger veto BEFORE they drop
         the cube or mobile scoreboard etc.  Handling the undo would be MUCH cooler.

  --Probably highly desired by players
  -TODO: remove cube from pending move when placed back in origin region, reset things back to original state wrt that cube and origin region.

  --Relatively minor finishing things / nice to haves
  -TODO: create an undo entry that clears scoring history when action that generated it get's undone (special scoring only)
  -TODO: waitLock(obj) utility function with timeout that logs debug info.  Maybe put in utils.ttslua?
]]
env = {}
env.version = "0.1 Alpha"
env.debug = false
env.trace = true
env.trace2 = false
-- env.test_players = {"Blue","Red","Green","Purple","Yellow"}
env.test_players = {"Green","Purple",}
env.in_dev = false --leave some objects interactable for dev purposes.
env.use_saved_data = true
env.ui_dedupe = false --NOTE: EXPERIMENTAL: trying to ignore dupes in UI setAttribute calls.
env.save_stats = false --log save data size every onSave() call.  Noisy.
env.lock_player_cubes = true --false for testing
env.ignore_drop = false --true for testing
env.hide_start_panel = false --for workng on UIs, don't show start panel.
--[[  defaults for game environment settings ]]
env.game_verbose = true
env.short_game = false
env.intrigue_king_exp = false --I&K Expansion
env.grandissimo_exp = false --TODO: future option, maybe
env.inquisitor_colonies_exp = false --TODO: future expansion, probably not
--[[ EXPERIMENTAL cube flasher settings]]
env.flasher_rate = 30 --frames between cube color changes when pending
env.flasher_debug = false -- periodically log flasher state
env.flasher_debug_cycles = 60 --log every flasher_debug_cycles * flasher_rate frames

G = {} --persistent game data
U = {} --persistent UI state

--[[ TTS Load function
]]
function onLoad(saved_data)
  if not(env.in_dev) then getObjectFromGUID(C.board).interactable = false end
  log("*************************************")
  log("Disigner:       TBD")
  log("Artist:         TBD")
  log("Year Released:  1995")
  log("Publisher:      ")
  log("TTS Scripting:  David Veach; 2024")
  log("Version: "..env.version)
  log("*************************************")
  UI.setAttribute("game_version","text","Version "..env.version)

  if env.test_players then
    UI.setAttribute("start_title","text","After all players seated:\n*** Test Players Enabled ***")
    log("WARN: Test players enabled")
  end
  if not(env.in_dev) then
    local o = getObjectFromGUID(C.trash)
    o.interactable = false
    o.setInvisibleTo(Player.getAvailableColors())
    o=getObjectFromGUID(C.table_extension); if o then o.interactable=false end
  end
  if not(env.use_saved_data) then saved_data = "" end
  if saved_data ~= "" then
    if env.trace then log("Global:onLoad(): loading from saved data") end
    local restored = JSON.decode(saved_data)
    U = restored.U
    G = restored.G
    setRegionXml() --restore region object UIs before replaying UI state
    Wait.frames(function() restoreGame() end, 5)
  else
    if env.trace then log("Global:onload(): initializing a fresh load") end
    --persistent UI state tables
    U.attributes = {}
    U.class = {}
    U.object_attributes = {}
    U.object_class = {}
    --persistent environment vars
    G.env = {}
    G.env.verbose = env.game_verbose
    G.env.short_game = env.short_game
    G.env.intrigue_king_exp = env.intrigue_king_exp
    G.env.grandissimo_exp = env.grandissimo_exp
    G.env.inquisitor_colonies_exp = env.inquisitor_colonies_exp
    --object tables
    G.obj = {}
    G.obj.snaps = {}
    G.obj.snaps[C.king] = getObjectFromGUID(C.king).getPosition()
    G.obj.snaps[C.bridge] = getObjectFromGUID(C.bridge).getPosition()
    for g,_ in pairs(C.mobile_score_boards) do G.obj.snaps[g] = getObjectFromGUID(g).getPosition() end
    G.obj.bid_buttons = simpleDeepCopy(C.order_buttons)
    for _,e in pairs(G.obj.bid_buttons) do --TODO template like I did with regions
      e.selected = false
      e.button_on = false
      e.players = {}
      e.visibility = {}
      e.used = {}
    end
    G.obj.regions = simpleDeepCopy(C.regions_template)
    G.obj.castillo = simpleDeepCopy(C.castillo_template)
    --Game data
    G.d = {}
    G.d.round = 0
    G.d.started = false
    G.d.phase = ""
    G.d.players = {}
    G.d.player_order = {}
    G.d.active_player = ""
    G.d.action_cards = {}
    G.d.action = {}
    resetAction()
    G.d.waitlist = {}
    G.d.status = {}
    G.d.status.waitlist = {}
    G.d.scoring = {}
    --setup start dialog
    UI_setAttribute("verbose","isOn",G.env.verbose)
    UI_setAttribute("short","isOn",G.env.short_game)
    UI_setAttribute("intrigue_king","isOn",G.env.intrigue_king_exp)
    UI_setAttribute("grandissimo","isOn",G.env.grandissimo_exp)
    UI_setAttribute("inquisitor_colonies","isOn",G.env.inquisitor_colonies_exp)
    UI_setAttribute("start_pnl","active",true)
    UI_setAttribute("confirm_pnl","visibility","Pink")
    UI_setAttribute("confirm_pnl","active",true)
    --setup region UIs
    setRegionXml()
  end
  updateCastilloUI()
  math.randomseed(os.time())
  --set up a hotkey to trigger UI reload.
  clearHotkeys()
  addHotkey("Reload all UI", function(player_color) reloadUI(player_color) end)
  --start the cube flasher coro
  startLuaCoroutine(Global, "flashCubes")
  if env.hide_start_panel then UI.setAttribute("start_pnl","active",false) end --DEVELOPMENT
end
--[[ Save game state
]]
function onSave()
  local data = {U=U,G=G}
  local save_data = JSON.encode(data)
  if env.save_stats then
    log("Saved data length: "..tostring(#save_data))
    if env.debug then log(save_data) end
  end
  return save_data
end
--[[ Replapy saved game state. (Mostly UI)]]
function restoreGame()
  if env.trace then log("restoreGame()") end
  --restore Global UI setAttribute()
  for key,value in pairs(U.attributes) do
    local id = Split(key, ':')[1]
    local field = Split(key, ':')[2]
    if not(UI.setAttribute(id, field, value)) then
      log("WARN: restoreGame() unable to setAttribute() "..tostring(id)..", "..tostring(field)..", "..tostring(value))
    end
  end
  --restore object UI setAttribute()
  for key,value in pairs(U.object_attributes) do
    local params = Split(key,":")
    local guid = params[1]
    local id = params[2]
    local field = params[3]
    local obj = getObjectFromGUID(guid)
    assert(obj, "restoreGame() restore object attributes, unable to locate object for guid "..tostring(guid))
    if not(obj.UI.setAttribute(id, field, value)) then
      log("WARN: restoreGame() unable to setAttribute() "..tostring(guid)..":"..tostring(id)..", "..tostring(field)..", "..tostring(value))
    end
  end
  --restore Global UI setClass()
  for id,value in pairs(U.class) do
    if not(UI.setClass(id,value)) then
      log("WARN: restoreGame() unable to setClass() "..tostring(id)..", "..tostring(value))
    end
  end
  --restore object UI setClass()
  for key,value in pairs(U.object_class) do
    local params = Split(key,":")
    local guid = params[1]
    local id = params[2]
    local obj = getObjectFromGUID(guid)
    assert(obj, "restoreGame() restore object classes, unable to locate object for guid "..tostring(guid))
    if not(obj.UI.setClass(id,value)) then
      log("WARN: restoreGame() unable to setClass() "..tostring(guid)..":"..tostring(id)..", "..tostring(value))
    end
  end
  --card buttons do not survive reload.  Need to recreate them.
  if G.d.phase == "actions" then
    for _,g in ipairs(G.d.action_cards) do
      local o = getObjectFromGUID(g)
      if o then
        o.clearButtons()
        local selected = false
        for _,pdata in pairs(G.d.players) do
          if pdata.action_card == g then selected = true; break end
        end
        if not(selected) then o.createButton(C.card_button) end
      end
    end
  end
  --special cases
  if G.env.intrigue_king_exp then
    for _,c in ipairs(G.d.player_order) do --restore card modifications not retained in save
      local opp = simpleDeepCopy(G.d.player_order)
      table.remove(opp,indexOf(opp,c))
      for _,o in ipairs(Player[c].getHandObjects()) do
        o.setHiddenFrom(opp)
        o.addContextMenuItem("Sort Hand", sortHand)
      end
    end
    if G.d.IK_bridge then
      local o = getObjectFromGUID(C.bridge)
      if o then
        o.call("setActive",G.d.IK_bridge.active)
      else
        log("WARN: restoreGame() unable to locate I&K bridge object")
        G.d.IK_bridge = nil
      end
    end
  end
  if G.d.scoring.running then
    Wait.time(function()
      log("restoreGame() INFO: restarting scoring coro, should pick up where it left off")
      G.d.scoring.restarting = true
      -- log("****************************************")
      -- log(G.d.scoring)
      -- log("****************************************")
      startScoring()
    end,1)
  end
  if env.hide_start_panel then UI.setAttribute("start_pnl","active",false) end --DEVELOPMENT
end
--[[ Set xml on all the regions and apply attribute data from Constants
    UIs are initialized inactive.
    See Constants.ttslua: C.region_ui
--]]
function setRegionXml()
  if env.trace then log("setRegionXml()") end
  -- if true then log("*** SKIP setRegionXml() ***"); return end
  for g,d in pairs(C.region_ui) do
    local r = getObjectFromGUID(g)
    local xml = r.UI.getXmlTable()
    local e = getXmlElement("scoreboard",xml)
    for id,val in pairs(d.msb) do e.attributes[id]=val end
    e = getXmlElement("quarantined",xml)
    for id,val in pairs(d.quarantined) do e.attributes[id]=val end
    e = getXmlElement("protected",xml)
    for id,val in pairs(d.protected) do e.attributes[id]=val end
    e = getXmlElement("limit",xml)
    for id,val in pairs(d.limit) do e.attributes[id]=val end
    e = getXmlElement("label",xml)
    for id,val in pairs(d.label) do e.attributes[id]=val end
    r.UI.setXmlTable(xml)
  end
end
--[[ TODO: TESTING ignoring dupes in UI wrapper calls. Cut down UI overhead.
  Need to do some stats testing to see if it is dropping any updates needed.
  NOTE: for setAttribute only, not for setClass. ]]
--[[  Wrapper function for saving Global UI attributes for game restore. ]]
function UI_setAttribute(id, field, value)
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  if env.ui_dedupe and U.attributes[id..":"..field] == value then return end
  if env.trace2 then log("UI_setAttribute(): "..tostring(id)..", "..tostring(field)..", "..tostring(value)) end
  UI.setAttribute(id, field, value)
  U.attributes[id..":"..field] = value
end
--[[  Wrapper function for saving Global UI setClass for game restore.
]]
function UI_setClass(id, value)
  assert(type(id) == "string", "UI_setClass(): id must be a string")
  assert(type(value) == "string", "UI_setClass(): value must be a string")
  -- if U.class[id] == value then log("skip class "..id) return end
  if env.trace2 then log("UI_setClass() "..tostring(id)..", "..tostring(value)) end
  UI.setClass(id, value)
  U.class[id] = value
end
--[[  Wrapper function for saving Global UI setClass for game restore.
]]
function object_UI_setClass(guid, id, value)
  assert(guid, "object_UI_setClass(): missing guid")
  assert(type(id) == "string", "object_UI_setClass(): id must be a string")
  assert(type(value) == "string", "object_UI_setClass(): value must be a string")
  local obj = getObjectFromGUID(guid)
  assert(obj, "object_UI_setAttribute() unable to locate object for guid "..tostring(guid))
  -- if U.object_class[guid..":"..id] == value then log("skip class "..guid..":"..id) return end
  if env.trace2 then log("UI_setClass() "..tostring(id)..", "..tostring(value)) end
  obj.UI.setClass(id, value)
  U.object_class[guid..":"..id] = value
end
--[[  Wrapper function for saving object UI attributes for game restore.
]]
function object_UI_setAttribute(guid, id, field, value)
  assert(guid, "object_UI_setAttribute(): missing guid")
  assert(type(id) == "string", "object_UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "object_UI_setAttribute(): field must be a string")
  assert(value ~= nil, "object_UI_setAttribute(): missing value for id "..tostring(id)..", field "..tostring(field))
  local obj = getObjectFromGUID(guid)
  assert(obj, "object_UI_setAttribute() unable to locate object for guid "..tostring(guid))
  if env.ui_dedupe and U.object_attributes[guid..":"..id..":"..field] == value then return end
  if env.trace2 then log("object_UI_setAttribute() "..tostring(guid)..", "..tostring(id)..", "..tostring(field)..", "..tostring(value)) end
  obj.UI.setAttribute(id, field, value)
  U.object_attributes[guid..":"..id..":"..field] = value
end

-- ////////////// Game logic ////////////////////////

--[[ Set up the game environment.
]]
function setupGame(player, button, id)
  if env.trace then log("setupGame() "..player.color..", "..tostring(id)) end
  -- setup players
  local seated = getSeatedPlayers()
  if env.test_players then seated = env.test_players
  elseif #seated < 2 then broadcastToAll("At least 2 players required to play this game"); return end
  UI_setAttribute("start_pnl","active",false)
  for i=1,4 do
    local g = C.stacks[i]
    local stack = getObjectFromGUID(g)
    assert(stack, "setupGame() missing card stack for guid "..tostring(g))
    stack.shuffle()
  end
  local plist="Pink"
  local n = math.random(#C.table_order)
  for i=1,#C.table_order do
    local pcol = C.table_order[n]
    if contains(seated,pcol) then
      plist=plist.."|"..pcol
      table.insert(G.d.player_order,pcol)
      G.d.players[pcol] = {
        score = 0,  --TODO more detailed stats for a cool end game report?
        grande = "",
        start_caballeros = {},
        caballeros = {},
        provinces = {},
        court = {},
        active = false,
        undo_button = false,
        allow_undo = true,
        done_button = false,
        show_disk = true,
        allowed_regions = {},
        disk_button = true,
        selected_region = math.random(1,9),
        court_locked = true,
        provinces_locked = true,
        action_card = "",
        held_cards = {},
      }
    else
      --delete all unused items for non-seated colors
      getObjectFromGUID(C.IK.decks[pcol]).destruct()
      getObjectFromGUID(C.player_boards[pcol]).destruct()
    end
    if n == #C.table_order then n=1 else n=n+1 end
  end
  G.d.visibility_all = plist
  -- Handle I&K expansion if selected
  if G.env.intrigue_king_exp then
    for _,g in ipairs(C.stacks) do getObjectFromGUID(g).destruct() end
    local d = getObjectFromGUID(C.IK.setup_deck)
    assert(d,"setupGame() cannot locate setup deck for Intrigue and the King expansion")
    local cleanup = true
    d.takeObject({guid=C.IK.king,position=C.IK.king_home_pos,
      callback_function=function(card)
        Wait.condition(function() card.setLock(true) end,function() return card.resting end, 5)
      end,
    })
    d.takeObject({guid=C.IK.intrigue,position=C.IK.intrigue_home_pos,
      callback_function=function(card)
        Wait.condition(function() card.setLock(true) end,function() return card.resting end, 5)
      end,
    })
    G.d.IK_caballero_cards = {}
    for _,i in ipairs(C.IK.setup_caballero_cards[#G.d.player_order]) do
      local p = C.IK.caballero_home_pos[i]
      local g = C.IK.caballero_cards[i]
      if d.tag == "Deck" then
        local o = d.takeObject({
          guid=g, position=p,
          callback_function=function(card)
            card.value = i
            Wait.condition(function() card.setLock(true) end,function() return card.resting end, 5)
          end,
        })
        if d.remainder then d = d.remainder end
      elseif d.tag == "Card" then --last card, no more deck (shouldn't happen but cover the case)
        d.setPositionSmooth(p,false,false)
        Wait.condition(function() d.setLock(true); d.value = i end,function() return d.resting end, 5)
        cleanup = false --nothing to destroy
      else
        log("ERROR: setupGame(): unhandled tag "..tostring(d.tag)) --DEBUG
      end
      table.insert(G.d.IK_caballero_cards,g)
    end
    if d and cleanup then d.destruct() end --destroy remaining deck
    for _,pdata in pairs(G.d.players) do pdata.power_cards = {} end
    for _,g in ipairs(C.button_guids) do getObjectFromGUID(g).destruct() end --get rid of bid tiles from base game
    G.obj.bid_buttons = nil
    -- Table for "Face Up Cards" that may be played.  Save information needed to "remove" them later if #125 is played.
    G.d.IK_face_up_cards = {}
  else
    getObjectFromGUID(C.bridge).destruct()
    getObjectFromGUID(C.IK.setup_deck).destruct()
    getObjectFromGUID(C.IK.setup_card).destruct()
    getObjectFromGUID(C.table_extension).destruct()
    for _,c in ipairs(G.d.player_order) do
      getObjectFromGUID(C.IK.decks[c]).destruct()
      local t = Player[c].getHandTransform()
      t.position.z = C.hand_base_game_z
      Player[c].setHandTransform(t)
    end
  end
  if G.env.grandissimo_exp then
    log("setupGame() TODO: handle Grandissimo expansion")
  end
  if G.env.inquisitor_colonies_exp then
    log("setupGame() TODO: handle Inquisitor and Colonies expansion")
  end
  G.d.MSB = {}
  local n = #G.d.player_order
  G.d.scoring_mask = nil
  for g,d in pairs(C.mobile_score_boards) do
    G.d.MSB[g] = {scoring=d.scoring, home_pos=d.home_pos, image=d.image, placed=false, quarantine=false}
    if n == 2 then
      G.d.MSB[g].image = d.image_2p
      local o = getObjectFromGUID(g)
      o.setCustomObject({image=d.url_2p})
      o.reload()
      if not(G.d.scoring_mask) then G.d.scoring_mask = "MSB_2p_mask" end
    elseif n == 3 then
      G.d.MSB[g].image = d.image_3p
      local o = getObjectFromGUID(g)
      o.setCustomObject({image=d.url_3p})
      o.reload()
      if not(G.d.scoring_mask) then G.d.scoring_mask = "MSB_3p_mask" end
    end
  end
  --set scoring masks for 2 or 3 players
  if G.d.scoring_mask then
    for g,_ in pairs(G.obj.regions) do
      object_UI_setAttribute(g,"scoreboard_image","image",G.d.scoring_mask)
      object_UI_setAttribute(g,"scoreboard","active",true)
    end
    object_UI_setAttribute(C.board,"scoreboard_image","image",G.d.scoring_mask)
    object_UI_setAttribute(C.board,"scoreboard","active",true)
  end
  --setup bid buttons
  if G.obj.bid_buttons then
    for g,e in pairs(G.obj.bid_buttons) do
      e.players = simpleDeepCopy(G.d.player_order)
      e.visibility = simpleDeepCopy(G.d.player_order)
    end
  end
  --get rid of extra scoring markers
  for p,g in pairs(C.score_markers) do
    if not(contains(G.d.player_order,p)) then
      getObjectFromGUID(g).destruct()
    end
  end
  object_UI_setAttribute(C.board, "regions","active",true)
  object_UI_setAttribute(C.castillo,"info","active",true)
  UI_setAttribute("scoring_pnl","active",true)
  UI_setAttribute("scoring_pnl","visibility","Pink")
  UI_setAttribute("confirm_pnl","visibility","Pink")
  UI_setAttribute("confirm_pnl","active",true)
  startLuaCoroutine(Global, "createPlayerCubes")
  G.d.started = true
end
--[[ Create player cubes and place them.
  Runs in a coro to yield between spawn calls.  Not entirely necessary
  but I like the visual effect it creates. :)
]]
function createPlayerCubes()
  if env.trace then log("createPlayerCubes()") end
  for _,pcol in ipairs(G.d.player_order) do
    local pdata = G.d.players[pcol]
    local board = getObjectFromGUID(C.player_boards[pcol])
    --Grande
    local sd = {
      position = board.positionToWorld(Vector(C.start_pos_l[1])),
      rotation = Vector(0,0,0),
    }
    sd.data = JSON.decode(C.grande_json)
    sd.callback_function = function(o)
      o.setName(pcol.." Grande")
      o.setColorTint(Color[pcol])
      o.memo = pcol
      o.setLock(env.lock_player_cubes)
      pdata.grande = o.getGUID()
      G.obj.snaps[o.getGUID()] = o.getPosition()
    end
    spawnObjectData(sd)
    coroutine.yield(0)
    --Province Caballeros
    sd.data = JSON.decode(C.caballero_json)
    sd.callback_function = function(o)
      o.setName(pcol.." Caballero")
      o.setColorTint(Color[pcol])
      o.memo = pcol
      o.setLock(env.lock_player_cubes)
      table.insert(pdata.caballeros, o.getGUID())
      table.insert(pdata.provinces, o.getGUID())
      G.obj.snaps[o.getGUID()] = o.getPosition()
    end
    -- Province Caballeros
    for i=1,21 do
      sd.position = board.positionToWorld(Vector(C.prov_pos_l[i]))
      spawnObjectData(sd)
      coroutine.yield(0)
    end
    --Court Caballeros
    sd.callback_function = function(o)
      o.setName(pcol.." Caballero")
      o.setColorTint(Color[pcol])
      o.memo = pcol
      o.setLock(env.lock_player_cubes)
      table.insert(pdata.caballeros, o.getGUID())
      table.insert(pdata.court, o.getGUID())
      G.obj.snaps[o.getGUID()] = o.getPosition()
    end
    for i=1,7 do
      sd.position = board.positionToWorld(Vector(C.court_pos_l[i]))
      spawnObjectData(sd)
      coroutine.yield(0)
    end
    --Starting Caballeros
    sd.callback_function = function(o)
      o.setName(pcol.." Caballero")
      o.setColorTint(Color[pcol])
      o.memo = pcol
      o.setLock(env.lock_player_cubes)
      table.insert(pdata.caballeros, o.getGUID())
      table.insert(pdata.start_caballeros, o.getGUID())
      G.obj.snaps[o.getGUID()] = o.getPosition()
    end
    sd.position = board.positionToWorld(Vector(C.start_pos_l[2]))
    spawnObjectData(sd)
    coroutine.yield(0)
    sd.position = board.positionToWorld(Vector(C.start_pos_l[3]))
    spawnObjectData(sd)
    coroutine.yield(0)
  end
  local c = 0
  while c < 30 do c=c+1; coroutine.yield(0) end
  if G.env.intrigue_king_exp then
    startIKCardSelection()
  else
    startPlacementPhase()
  end
  return 1
end
--[[ Setup for player hands, Intrigue and the King card drafting ]]
function startIKCardSelection()
  if env.trace then log("startIKCardSelection()") end
  G.d.phase = "IK_card_selection"
  G.d.waitlist = simpleDeepCopy(G.d.player_order)
  G.d.status = {}
  G.d.status.info = "Intrigue and the King"
  G.d.status.info = G.d.status.info.."\nSelect 13 cards from search"
  G.d.status.info = G.d.status.info.."\nDrop cards anywhere"
  G.d.status.waitlist = {}
  for _,c in ipairs(G.d.player_order) do
    object_UI_setAttribute(C.player_boards[c],"button_pnl","active",true)
    table.insert(G.d.status.waitlist,{player_color=c,player_status="Deciding"})
    G.d.players[c].active = true
    G.d.players[c].waiting = true
    G.d.players[c].undo_button = false
    G.d.players[c].done_button = false
    G.d.players[c].show_disk = false
    updatePlayerBoardUI(c)
    local d = getObjectFromGUID(C.IK.decks[c])
    local opp = simpleDeepCopy(G.d.player_order)
    table.remove(opp,indexOf(opp,c))
    d.setInvisibleTo(opp)
    d.setLock(false)
    d.memo = JSON.encode(opp)
    d.Container.search(c)
    object_UI_setAttribute(C.player_boards[c],"undo_row","active",false)
    object_UI_setAttribute(C.player_boards[c],"card_select_txt","text","Cards: 0")
    object_UI_setAttribute(C.player_boards[c],"card_select_row","active",true)
  end
  G.d.status.show = true
  updateStatusUI(G.d.status)
end
--[[ Setup for bidding on initial placement.
]]
function startPlacementPhase()
  if env.trace then log("startPlacementPhase()") end
  G.d.phase = "placement"
  --randomly place the king
  local kings_region = math.random(1,9)
  local g = C.region_guids[kings_region]
  local king = getObjectFromGUID(C.king)
  king.setPosition(C.region_start_info[g].king)
  king.setLock(false)
  if setKing(g) then G.obj.snaps[king.getGUID()]=king.getPosition()
  else log("WARN: startPlacementPhase() king region not set") end --DEBUG
  --set up each player's allowed disk selections
  local allowed = {}
  for i,g in ipairs(C.region_guids) do
    local r = G.obj.regions[g]
    if not(r.king) then table.insert(allowed,r.scoring_order) end
  end
  --set up the selection dialog
  G.d.waitlist = simpleDeepCopy(G.d.player_order)
  G.d.status = {}
  G.d.status.info = "Initial Placement Selection"
  G.d.status.info = G.d.status.info.."\nSecretly select starting region for"
  G.d.status.info = G.d.status.info.."\nGrande and 2 starting Caballeros"
  G.d.status.waitlist = {}
  for i=1,5 do
    if i <= #G.d.player_order then
      local pcol = G.d.player_order[i]
      object_UI_setAttribute(C.player_boards[pcol],"button_pnl","active",true)
      table.insert(G.d.status.waitlist,{player_color=pcol,player_status="Deciding"})
      G.d.players[pcol].active = true
      G.d.players[pcol].waiting = true
      G.d.players[pcol].done_button = true
      G.d.players[pcol].show_disk = true
      G.d.players[pcol].allowed_regions = simpleDeepCopy(allowed)
      G.d.players[pcol].selected_region = allowed[math.random(#allowed)]
      updatePlayerBoardUI(pcol)
    end
  end
  G.d.status.show = true
  updateStatusUI(G.d.status)
end
--[[ Place Grande and 2 starting Caballeros in the Regions
    selected for each player.
]]
function placeStartingCubes()
  if env.trace then log("placeStartingCubes()") end
  for _,pcol in ipairs(G.d.player_order) do
    local pdata = G.d.players[pcol]
    local region_guid = C.region_guids[pdata.selected_region]
    local grande = getObjectFromGUID(pdata.grande)
    grande.setLock(false)
    local pos = C.region_start_info[region_guid].grande[pcol]
    grande.setPosition(pos)
    G.obj.snaps[pdata.grande] = pos
    setGrande(region_guid, pcol)
    --place starting caballeros
    local delta_x = {0.28, -0.32}
    local delta_z = 1.15
    for i,g in ipairs(pdata.start_caballeros) do
      local o = getObjectFromGUID(g)
      o.setLock(false)
      local pos = grande.getPosition()
      pos.x = pos.x - delta_x[i]
      pos.z = pos.z - delta_z
      o.setPosition(pos)
      G.obj.snaps[g] = pos
      addCaballero(pcol, region_guid, pcol, g)
    end
    pdata.start_caballeros = nil
  end
end
--[[ Set up the region selection for I&K extra Caballero placement]]
function startIKExtraPlacement()
  if env.trace then log("startIKExtraPlacement()") end
  G.d.phase = "IK_extra_placement"
  G.d.waitlist = simpleDeepCopy(G.d.player_order)
  G.d.status = {}
  G.d.status.info = "Initial Placement Selection"
  G.d.status.info = G.d.status.info.."\nSecretly select region for"
  G.d.status.info = G.d.status.info.."\none additional Caballero"
  G.d.status.waitlist = {}
  local allowed = {1,2,3,4,5,6,7,8,9}
  for i=1,5 do
    if i <= #G.d.player_order then
      local pcol = G.d.player_order[i]
      object_UI_setAttribute(C.player_boards[pcol],"button_pnl","active",true)
      table.insert(G.d.status.waitlist,{player_color=pcol,player_status="Deciding"})
      G.d.players[pcol].active = true
      G.d.players[pcol].waiting = true
      G.d.players[pcol].undo_button = false
      G.d.players[pcol].done_button = true
      G.d.players[pcol].disk_button = true
      G.d.players[pcol].show_disk = true
      G.d.players[pcol].allowed_regions = allowed
      G.d.players[pcol].selected_region = allowed[math.random(#allowed)]
      updatePlayerBoardUI(pcol)
    end
  end
  G.d.status.show = true
  updateStatusUI(G.d.status)
end
--[[ Setup and begin the order bidding phase
]]
function startBidPhase()
  if env.trace then log("startBidPhase()") end
  G.d.phase = "bidding"
  if G.env.intrigue_king_exp then
    if G.env.verbose then broadcastToAll("In current turn order players play power cards") end
    G.d.players_to_bid = simpleDeepCopy(G.d.player_order)
    G.d.status = {}
    G.d.status.waitlist = {}
    G.d.status.info = "Power card phase:\nIn the following player order\nplay a power card"
    G.d.active_player = G.d.player_order[1]
    for i,pcol in ipairs(G.d.player_order) do
      local pdata = G.d.players[pcol]
      local s = ""
      if pcol == G.d.active_player then s = "Active" end
      table.insert(G.d.status.waitlist,{player_color=pcol,player_status=s})
      pdata.active = pcol == G.d.active_player
      pdata.done = false
      pdata.waiting = false
      pdata.undo_button = false
      pdata.done_button = false
      pdata.show_disk = false
      updatePlayerBoardUI(pcol)
      pdata.power_card = nil
      pdata.power_bid = nil
    end
    G.d.status.show = true
    updateStatusUI(G.d.status)
  else
    if G.env.verbose then broadcastToAll("In current turn order players select action order bids") end
    G.d.players_to_bid = simpleDeepCopy(G.d.player_order)
    G.d.status = {}
    G.d.status.waitlist = {}
    G.d.status.info = "Turn order bidding phase:\nIn the following player order\nchoose an available bid number"
    G.d.active_player = G.d.player_order[1]
    for i,pcol in ipairs(G.d.player_order) do
      local pdata = G.d.players[pcol]
      local s = ""
      if pcol == G.d.active_player then s = "Active" end
      table.insert(G.d.status.waitlist,{player_color=pcol,player_status=s})
      pdata.active = pcol == G.d.active_player
      pdata.done = false
      pdata.waiting = false
      pdata.undo_button = false
      pdata.done_button = false
      pdata.show_disk = false
      pdata.bid_button = nil
      updatePlayerBoardUI(pcol)
    end
    G.d.status.show = true
    updateStatusUI(G.d.status)
    -- Check to see if veto card has expired
    if G.env.intrigue_king_exp then
      log("--- startBidPhase(): Remove I&K Veto cards at start of next round")
      if G.d.veto_player then G.d.veto_player = nil end
    else
      if G.d.veto_round and G.d.round - G.d.veto_round >= 2 then
        local card = getObjectFromGUID(G.d.players[G.d.veto_player].veto_card)
        assert(card, "startBidPhase(): unable to locate veto card object")
        getObjectFromGUID(C.trash).putObject(card)
        G.d.players[G.d.veto_player].veto_card = nil
        G.d.veto_player = nil
        G.d.veto_round = nil
      end
    end
    -- Reveal Action Cards
    if #G.d.action_cards > 0 then
      -- trash all remaining cards except the King card
      local trash = getObjectFromGUID(C.trash)
      for _,g in ipairs(G.d.action_cards) do
        local o = getObjectFromGUID(g)
        o.setLock(false)
        if g ~= C.stacks[5] then trash.putObject(o) end
      end
    end
    G.d.action_cards = {}
    for i=1,4 do
      local stack = getObjectFromGUID(C.stacks[i])
      local pos = stack.getPosition()
      pos.y = pos.y + 3
      local card = stack.takeObject({
        position=pos,
        flip=true,
        callback_function = function(o)
          Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
        end
      })
      table.insert(G.d.action_cards, card.getGUID())
    end
    local king_card = getObjectFromGUID(C.stacks[5])
    if king_card.resting and king_card.is_face_down then
      king_card.setLock(false)
      king_card.flip()
      Wait.condition(function() king_card.setLock(true) end, function() return king_card.resting end, 5)
    end
    table.insert(G.d.action_cards, king_card.getGUID())
    -- Activate bid buttons
    for g,d in pairs(G.obj.bid_buttons) do
      d.button_on = true
      d.selected = false
      if indexOf(d.players,G.d.active_player) > 0 then d.visibility = {G.d.active_player}
      else d.visibility = {} end
      updateOrderButtonUI(g,d)
    end
  end
  -- Move round marker
  G.d.round = G.d.round + 1
  if G.env.short_game then
    if G.d.round == 1 then G.d.round = 2
    elseif G.d.round == 4 then G.d.round = 5
    elseif G.d.round == 7 then G.d.round = 8
    end
  end
  local marker = getObjectFromGUID(C.round_marker)
  marker.setPosition(C.round_marker_positions[G.d.round])
  if G.env.intrigue_king_exp and G.d.round > 1 then
    --return King, Intrigue, and Caballero cards to home positions
    local o = getObjectFromGUID(C.IK.king)
    o.setPosition(C.IK.king_home_pos)
    o.setScale({1.87,1,1.87})
    o = getObjectFromGUID(C.IK.intrigue)
    o.setPosition(C.IK.intrigue_home_pos)
    o.setScale({1.87,1,1.87})
    for _,g in ipairs(G.d.IK_caballero_cards) do
      local o = getObjectFromGUID(g)
      o.setPosition(C.IK.caballero_home_pos[o.value])
      o.setScale({1.87,1,1.87})
    end
  end
  --remove any "this round only" effects
  for r,rd in pairs(G.obj.regions) do
    if rd.protected then
      rd.protected = false
      object_UI_setAttribute(r,"protected","active",false)
    end
  end
end
--[[ Return action data to initial state
--]]
function resetAction()
  if env.trace then log("resetAction()") end
  G.d.action = {
    stage= "main",              --"main" | "court" | "special", keys to undo tables, UI updates, etc.
    guid = "",              --card guid
    player = "",            --active player
    opponents = {},         --active player's opponents
    court = 0,              --number of Court Caballeros that can move to Regions
    special = {},           --table of allowed actions ("move_king", "move_grande", etc.)
    description = "",       --description of the action
    pending_cubes = {},     --cubes that have been moved in this action stage (see flasher)
    caballeros = 0;         --caballeros to move
    caballeros_moved = 0;   --caballeros moved so far
    undo = {main={},court={},special={},reset=true},
    stage_status = "",      --status of the current action stage when not "main"
    status = {      --TODO: clean up the naming.  waitlist -> players  status->hud or something like that.
      waitlist={},
      show=true,
    },
    sequence = {},          --LIFO, Order of actions taken, used by reset/undo to unwind: "court", "special", "IK_king", "IK_intrigue"
  }
  if G.env.intrigue_king_exp then
    G.d.action.IK = {}
    G.d.action.undo.IK_king = {}
    G.d.action.undo.IK_intrigue = {}
  end
end
--[[ Setup and begin the action phase
]]
function startActionPhase()
  if env.trace then log("startActionPhase()") end
  G.d.phase = "actions"
  resetAction()
  G.d.status = {}
  G.d.status.waitlist = {}
  G.d.players_to_play = simpleDeepCopy(G.d.player_order)
  if G.env.intrigue_king_exp then
    log("start action phase for I&K expansion") --DEBUG
    -- Set up player order based on power cards played
    local temp = nil
    for c,pd in pairs(G.d.players) do
      if not(temp) then temp = {c}
      else
        for i,e in ipairs(temp) do
          local add = true
          if pd.power_bid > G.d.players[e].power_bid then table.insert(temp,i,c); add=false; break end
          if add then table.insert(temp, c); break end
        end
      end
      --Check for any player played the veto card
      if power_cards[pd.power_bid].special.id == "veto" then
        G.d.veto_player = c
        pd.IK_special_action = false
        --enable veto button on the card
        local card = getObjectFromGUID(pd.power_card)
        card.createButton(C.veto_card_button)          --TODO: move this to processAction():special with check for veto allowed
      end
    end
    G.d.player_order = temp
    -- Update status dialog
    G.d.active_player = G.d.player_order[1]
    G.d.status.info = "Actions Phase:\nIn the following turn order\nperform selected actions"
    G.d.active_player = G.d.player_order[1]
    for i,c in ipairs(G.d.player_order) do
      local pdata = G.d.players[c]
      local s = ""
      if c == G.d.active_player then s = "Active" end
      table.insert(G.d.status.waitlist,{player_color=c,player_status=s})
      pdata.active = c == G.d.active_player
      pdata.done = false
      pdata.waiting = c ~= G.d.active_player
      pdata.undo_button = false
      pdata.allow_undo = true
      pdata.done_button = false
      pdata.show_disk = false
      updatePlayerBoardUI(c)
      local board = getObjectFromGUID(C.player_boards[c])
      local cinfo = power_cards[pdata.power_bid]
      for i=1,cinfo.prov do
        if #pdata.provinces > 0 then
          local o = getObjectFromGUID(pdata.provinces[#pdata.provinces])
          table.insert(pdata.court, o.getGUID())
          o.setPosition(board.positionToWorld(C.court_pos_l[#pdata.court]))
          G.obj.snaps[o.getGUID()] = o.getPosition()
          table.remove(pdata.provinces, #pdata.provinces)
        end
      end
      --give caballero card
      local o=getObjectFromGUID(G.d.IK_caballero_cards[i])
      o.setLock(false)
      o.setPosition(board.positionToWorld(C.IK.caballero_pos_l[1]))
      o.setScale({1.6,1,1.6})
      Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
      pdata.court_limit = indexOf(C.IK.caballero_cards,o.getGUID())
      local cards = 1
      if i == 1 then
        --give king card
        local o=getObjectFromGUID(C.IK.king)
        o.setLock(false)
        o.setPosition(board.positionToWorld(C.IK.caballero_pos_l[2]))
        o.setScale({1.6,1,1.6})
        Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
        pdata.IK_king_card = o.getGUID()
        pdata.IK_intrigue_card = nil
        cards = 2
      elseif i == #G.d.player_order then
        --give intrigue card
        local o=getObjectFromGUID(C.IK.intrigue)
        o.setLock(false)
        o.setPosition(board.positionToWorld(C.IK.caballero_pos_l[2]))
        o.setScale({1.6,1,1.6})
        Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
        pdata.IK_king_card = nil
        pdata.IK_intrigue_card = o.getGUID()
        cards = 2
      else
        pdata.IK_king_card = nil
        pdata.IK_intrigue_card = nil
      end
    end
    startPlayerActions(G.d.active_player)
  else
    -- set player order from highest to lowest bid
    local temp = {}
    for i=13,1,-1 do
      local d = G.obj.bid_buttons[C.button_guids[i]]
      if d.selected then
        table.insert(temp,d.selected)
        G.d.players[d.selected].p2c = d.court
      end
      d.button_on = false
    end
    assert(#temp == #G.d.player_order, "FATAL: startActionPhase() uable to build new player order from selected bids") --DEBUG
    G.d.player_order = temp
    G.d.active_player = G.d.player_order[1]
    G.d.status.info = "Actions Phase:\nIn the following turn order\nchoose an action card to play"
    -- G.d.status.info = G.d.status.info.."\nCaballeros move Court -> Region"
    G.d.active_player = G.d.player_order[1]
    for i,pcol in ipairs(G.d.player_order) do
      local pdata = G.d.players[pcol]
      local s = ""
      if pcol == G.d.active_player then s = "Active" end
      table.insert(G.d.status.waitlist,{player_color=pcol,player_status=s})
      pdata.active = pcol == G.d.active_player
      pdata.done = false
      pdata.waiting = pcol ~= G.d.active_player
      pdata.undo_button = false
      pdata.allow_undo = true
      pdata.done_button = false
      pdata.show_disk = false
      updatePlayerBoardUI(pcol)
      -- Move Caballeros from Province to Court based on player's order button selection.
      local board = getObjectFromGUID(C.player_boards[pcol])
      for i=1,pdata.p2c do
        if #pdata.provinces > 0 then
          local o = getObjectFromGUID(pdata.provinces[#pdata.provinces])
          table.insert(pdata.court, o.getGUID())
          o.setPosition(board.positionToWorld(C.court_pos_l[#pdata.court]))
          G.obj.snaps[o.getGUID()] = o.getPosition()
          table.remove(pdata.provinces, #pdata.provinces)
        end
      end
    end
    -- Activate buttons on action cards
    for i,g in ipairs(G.d.action_cards) do getObjectFromGUID(g).createButton(C.card_button) end
  end
  G.d.status.show = true
  updateStatusUI(G.d.status)
end
--[[ Set up for a player actions turn ]]
function startPlayerActions(pcol)
  if env.trace then log("startPlayerActions() "..tostring(pcol)) end
  local pdata = G.d.players[pcol]
  resetAction()
  local a = G.d.action
  a.player = pcol
  a.description = "Choose an action:"
  a.status.info = "Active Player\nChoose actions for\n"
  for _,c in ipairs(G.d.player_order) do if c~=pcol then table.insert(a.opponents,c) end end
  local cinfo = nil
  if G.env.intrigue_king_exp then
    cinfo = power_cards[pdata.power_bid]
    a.name = cinfo.name
    a.court = pdata.court_limit --HACK: why is this set in player data?  Should get from cinfo?
    if cinfo.special.id == "veto" then
      log("TODO: startPlayerActions(), player holds I&K Veto power card")
      pdata.IK_special_action = false
      a.status.info = "Veto Player has\nno special action\nduring turn"
      a.IK.special = simpleDeepCopy(cinfo.special)
      a.IK.special.completed = true --don't trigger unused action warn on Done
      if (pdata.IK_king_card or pdata.IK_intrigue_card) and #G.d.player_order > 3 then
        if pdata.IK_king_card then
          a.IK.king = simpleDeepCopy(IK_king)
          pdata.IK_king_action = true
          pdata.IK_intrigue_action = false
        elseif pdata.IK_intrigue_card then
          a.IK.intrigue = simpleDeepCopy(IK_intrigue)
          pdata.IK_king_action = false
          pdata.IK_intrigue_action = true
        end
      elseif (pdata.IK_king_card or pdata.IK_intrigue_card) and #G.d.player_order <= 3 then
        if G.d.veto_player then --hasn't used it yet, allow king or intrigue as appropriate
          if pdata.IK_king_card then
            a.IK.king = simpleDeepCopy(IK_king)
            pdata.IK_king_action = true
            pdata.IK_intrigue_action = false
          elseif pdata.IK_intrigue_card then
            a.IK.intrigue = simpleDeepCopy(IK_intrigue)
            pdata.IK_king_action = false
            pdata.IK_intrigue_action = true
          end
        else --veto has been used, only allow caballero action
          pdata.IK_king_action = false
          pdata.IK_intrigue_action = false
        end
      end
    else
      a.status.info = a.status.info..a.name
      a.IK.special = simpleDeepCopy(cinfo.special)
      --set up I&K king/intrigue action if owned
      if (pdata.IK_king_card or pdata.IK_intrigue_card) and #G.d.player_order > 3 then
        pdata.IK_special_action = false
        a.special = {}
        a.IK.special.completed = true --don't trigger unused action warn on Done
      else
        pdata.IK_special_action = true
      end
      if pdata.IK_king_card then
        a.IK.king = simpleDeepCopy(IK_king)
        pdata.IK_king_action = true
        pdata.IK_intrigue_action = false
      elseif pdata.IK_intrigue_card then
        a.IK.intrigue = simpleDeepCopy(IK_intrigue)
        pdata.IK_king_action = false
        pdata.IK_intrigue_action = true
      else
        -- pdata.IK_special_action = true
        pdata.IK_king_action = false
        pdata.IK_intrigue_action = false
      end
    end
    pdata.undo_button = false
  else --Base Game
    local cinfo = cards[pdata.action_card]
    assert(cinfo, "startPlayerActions() could not locate card info") --DEBUG
    local card = getObjectFromGUID(pdata.action_card)
    assert(card, "startPlayerActions() could not locate card object") --DEBUG
    a.guid = card.getGUID()
    a.name = cinfo.name
    a.court = cinfo.court
    a.undo.main[card.getGUID()] = {id="select_card",g=card.getGUID(),pcol=pcol,snap=card.getPosition()} --TODO: move to cardClick()?
    card.clearButtons() --TODO: move to cardClick()?
    if cinfo.special.id == "veto" then
      log("handle base game Veto card")
      UI_setAttribute("veto_player_pnl","color",pcol)
      UI_setAttribute("veto_player_txt","text",pcol)
      a.description = "Veto card\nCourt is only action"
      a.status.info = "Active Player\nHold Veto card in hand\nCourt is only action"
      a.special_completed = true
      card.addTag("Veto")
      card.deal(1,pcol)
      pdata.veto_card = card.getGUID()
      table.remove(G.d.action_cards,indexOf(G.d.action_cards,card.getGUID()))
      G.d.veto_player = pcol
      G.d.veto_round = G.d.round
    else
      a.status.info = a.status.info..cinfo.name
      a.special = simpleDeepCopy(cinfo.special)
      local board = getObjectFromGUID(C.player_boards[pcol])
      card.setPosition(board.positionToWorld(C.card_pos_l))
      Wait.condition(function() card.setLock(true) end, function() return card.resting end, 5)
    end
    pdata.undo_button = true
  end
  updateStatusUI(a.status)
  pdata.active = true
  pdata.waiting = false
  pdata.allow_undo = true
  pdata.done_button = false
  pdata.action_ui = true
  updatePlayerBoardUI(pcol)
end
--[[ Process an option selected by the player during actions.
]]
function processAction(pcol, opt)
  if env.trace then log("processAction() "..tostring(pcol)..", "..tostring(opt)) end
  local pdata = G.d.players[pcol]
  local a = G.d.action
  if opt == "court" then
    if a.stage == "main" or a.stage == "IK_main" then
      setLockCourt(pcol, false)
      a.stage="court"
      if a.vetoed then a.vetoed = false end --may have been set so clear it
      a.description = "Move from Court"
      pdata.disable_reset = false
      updatePlayerBoardUI(pcol)
      table.insert(a.sequence,1,"court")
    else
      log("ERROR: incorrect stage for special: "..tostring(a.stage)); return   --DEBUG
    end
  elseif opt == "king" then -- I&K King card action
    if a.stage == "main" then
      pdata.IK_special_action = false
      a.IK.special.completed = true --don't trigger unused action warn on Done
      a.special = simpleDeepCopy(a.IK.king.special)
      a.name = "The King"
      a.undo.IK_king = {}
      a.undo.IK_king["IK_special_action"] = {id="IK_special_action", pcol=pcol, state=true}
      table.insert(a.sequence,1,"IK_king")
      doSpecial(pcol)
    else log("ERROR: incorrect stage for I&K King: "..tostring(a.stage)); return end   --DEBUG
  elseif opt == "intrigue" then --I&K Intrigue card action
    if a.stage == "main" then
      pdata.IK_special_action = false
      a.IK.special.completed = true --don't trigger unused action warn on Done
      a.special = simpleDeepCopy(a.IK.intrigue.special)
      a.name = "Intrigue"
      a.undo.IK_intrigue = {}
      a.undo.IK_intrigue["IK_special_action"] = {id="IK_special_action", pcol=pcol, state=true}
      table.insert(a.sequence,1,"IK_intrigue")
      doSpecial(pcol)
    else log("ERROR: incorrect stage for I&K Intrigue: "..tostring(a.stage)); return end   --DEBUG
  elseif opt == "special" then
    if a.stage == "main" then
      if a.IK then
        if a.IK.special.hold_card then
          log("---place power card in holding area")
          local board = getObjectFromGUID(C.player_boards[pcol])
          if sizeOf(pdata.held_cards) <= #C.IK.card_pos_l then
            local pos = board.positionToWorld(C.IK.card_pos_l[sizeOf(pdata.held_cards)+1])
            local o = getObjectFromGUID(pdata.power_card)
            o.memo = pcol
            pdata.held_cards[pdata.power_card] = {id=a.IK.special.id,g=o.getGUID(),power=o.value,}
            o.setPosition(pos)
            Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
            table.remove(pdata.power_cards,indexOf(pdata.power_cards,o.getGUID()))
          else
            --TODO: more than 4 cards held, if this can happen, figure out how to handle it
            assert(false,"startActionPhase(): unable to place held card, too many for number of locations!") --TODO: handle this
          end
        end
        a.description = power_cards[pdata.power_bid].description
        if pdata.IK_king_action then
          pdata.IK_king_action = false
          a.undo.special["IK_king_action"] = {id="IK_king_action", pcol=pcol, state=true}
        elseif pdata.IK_intrigue_action then
          pdata.IK_intrigue_action = false
          a.undo.special["IK_intrigue_action"] = {id="IK_intrigue_action", pcol=pcol, state=true}
        end
        if a.IK.king then a.IK.king.completed = true end --don't trigger unused action warn on Done
        if a.IK.intrigue then a.IK.intrigue.completed = true end --don't trigger unused action warn on Done
      else a.description = cards[a.guid].description end
      if not(a.description) then a.description = "Special Action" end
      table.insert(a.sequence,1,"special")
      if a.IK then --bit of a HACK: override a.special for IK_king or IK_intrique specials
        if a.IK.special.id == "IK_king" then
          a.special = simpleDeepCopy(IK_king.special)
          a.name = "The King"
          a.special.IK = "special" --this the special, not the King card action
          doSpecial(pcol)
        elseif a.IK.special.id == "IK_intrigue" then
          a.special = simpleDeepCopy(IK_intrigue.special)
          a.name = "Intrigue"
          a.special.IK = "special" --this the special, not the Intrigue card action
          doSpecial(pcol)
        else
          a.special = simpleDeepCopy(a.IK.special)
          doSpecial(pcol)
        end
      else doSpecial(pcol) end
    else
      log("ERROR: incorrect stage for special: "..tostring(a.stage)); return   --DEBUG
    end
  elseif opt == "finished" then
    log("--- Finish action: stage is '"..a.stage.."'")
    if a.stage == "court" then
      for _,g in ipairs(a.pending_cubes) do
        local i = indexOf(pdata.court, g); if i > 0 then table.remove(pdata.court, i) end
      end
      a.court_completed = true
      a.undo.main["court"]={id="court_completed"}
    elseif a.stage == "special" or a.stage == "waiting" then
      if a.IK then
        -- special cases for I&K expansion
        if a.special.id == "bridge" then
          getObjectFromGUID(C.bridge).call("setActive",false)
          G.d.bridge.active = false
        end
        -- handle player count for King and Intrigue vs. Special action completion"
        if #G.d.player_order < 4 then
          if a.special.IK == "IK_king" then
            pdata.IK_king_action = false
            a.IK.king.completed = true
            if pdata.allow_undo then a.undo.main["IK_king"]={id="IK_king_completed"}
            else a.undo.special = {} end
            a.special = simpleDeepCopy(power_cards[pdata.power_bid].special)
          elseif a.special.IK == "IK_intrigue" then
            pdata.IK_intrigue_action = false
            a.IK.intrigue.completed = true
            if pdata.allow_undo then a.undo.main["IK_intrigue"]={id="IK_intrigue_completed"}
            else a.undo.special = {} end
            a.special = simpleDeepCopy(power_cards[pdata.power_bid].special)
          else
            a.IK.special.completed = true
            pdata.IK_special_action = false
          end
        else
          pdata.IK_special_action = false
          if a.special.IK == "IK_king" then
            pdata.IK_king_action = false
            a.IK.king.completed = true
            a.special = simpleDeepCopy(power_cards[pdata.power_bid].special)
            if pdata.allow_undo then a.undo.main["IK_king"]={id="IK_king_completed"}
            else a.undo.special = {} end
          elseif a.special.IK == "IK_intrigue" then
            pdata.IK_intrigue_action = false
            a.IK.intrigue.completed = true
            a.special = simpleDeepCopy(power_cards[pdata.power_bid].special)
            if pdata.allow_undo then a.undo.main["IK_intrigue"]={id="IK_intrigue_completed"}
            else a.undo.special = {} end
          else
            if pdata.allow_undo then
              a.undo.main["IK_special"]={id="IK_special_completed"}
              a.IK.special.completed = true
            else a.undo.special = {} end
          end
        end
      else
        -- Normal base game special
        a.special_completed = true
        if pdata.allow_undo then a.undo.main["special"]={id="special_completed"}
        else a.undo.special = {} end
      end
      --dlear any opponents state
      for p,pd in pairs(G.d.players) do
        if p ~= a.player then
          pd.undo_button = false
          pd.done_button = false
          pd.disk_button = false
          pd.show_disk = false
          pd.show_stage = false
          pd.action_ui = false
          pd.active = false
          pd.done = false
          updatePlayerBoardUI(p)
        end
      end
    else
      log("ERROR: incorrect stage for finished: "..tostring(a.stage)); return   --DEBUG
    end
    if #a.pending_cubes > 0 then
      cleanupCourt(pcol)
      pendingCubes("clear")
    end
    a.caballeros_moved = 0
    a.stage = "main"
    if a.court_completed and a.special_completed then
      a.description = "All actions completed"
      a.status.info = "Active Player\nActions completed for\n"..a.name
    else
      a.status.info = "Active Player\nChoose actions for\n"..a.name
      a.description = "Choose an action"
    end
    if a.vetoed then
      --Do some forced things as result of a veto, clear lots of stuff that might have been set
      pdata.allow_undo = false
      pdata.show_disk = false
      pdata.show_stage = false
      pendingCubes("clear")
      for g,_ in pairs(G.obj.regions) do
        local o = getObjectFromGUID(g); o.highlightOff(); o.clearButtons()
      end
      for p,pd in pairs(G.d.players) do
        local o = getObjectFromGUID(C.player_boards[p]); o.clearButtons(); o.highlightOff()
      end
      log("--- TODO: processAction():finished: anything else for forced action finish on a Veto?")
    end
    if pdata.allow_undo then pdata.undo_button = true else pdata.undo_button = false end
    pdata.done_button = true
    setLockCourt(pcol, true)
    setLockProvinces(pcol, true)
    updatePlayerBoardUI(pcol)
    updateBoardUI()
    updateCastilloUI()
    a.waiting = 0
    a.status.waitlist = {}
    -- updateStatusUI(a.status)
    updateStatusUI(G.d.status) --TODO: TESTING: return status back to G.d.status (beginning of turn?)  See also reset.
  elseif opt == "reset" then
    if a.stage == "waiting" then --TODO: clean up this mess! move stuff to an undo.special entries TODO: conflict with undo I&K sequencing?
      log("processAction(): reset special while waiting")
      if a.waitlist and #a.waitlist == 1 and a.waitlist[1] == pcol then --TODO: HACK: used when active is doing something (disk?), move to an undo.special entry
        if a.undo.special ~= {} then
          log("WARN: undoing specials while active player is in waiting state") --DEBUG
          for g,u in pairs(a.undo.special) do undo(u) end
        end
        local pdata = G.d.players[pcol]
        pdata.waiting = false
        pdata.show_disk = false
        pdata.disk_button = false
        pdata.undo_button = false
        pdata.done_button = true
        pdata.action_ui = true
      else
        if a.undo.special ~= {} then
          for g,u in pairs(a.undo.special) do undo(u) end
        else
          log("WARN: processAction() reset while waiting but no undo.special to do") --DEBUG
        end
        pdata.disable_reset = false
        pdata.allow_undo = true
        pdata.undo_button = true
        pdata.done_button = true
        pdata.action_ui = true
        updatePlayerBoardUI(pcol)
        for p,pd in pairs(G.d.players) do --TODO: make this an undo entry? id=reset_opponents ???
          if p ~= pcol then
            pd.undo_button = false
            pd.done_button = false
            pd.disk_button = false
            pd.show_disk = false
            pd.show_stage = false
            pd.action_ui = false
            pd.active = false
            pd.done = false
            updatePlayerBoardUI(p)
          end
        end
      end
      a.undo.special = {}
      a.special_completed = false
    else
      local stage = a.sequence[1]
      table.remove(a.sequence,1)
      if stage == "court" then
        log("processAction(): reset court stage")
        for _,u in pairs(a.undo.court) do undo(u) end
        a.undo.court = {}
        a.court_completed = false
      elseif stage == "special" then
        log("processAction(): reset special stage")
        for g,u in pairs(a.undo.special) do undo(u) end
        a.undo.special = {}
        a.special_completed = false
        a.special.origin = nil --HACK: should this be an undo?  not sure why I'm doing this
      elseif stage == "IK_king" then
        log("processAction(): reset I&K King action")
        for g,u in pairs(a.undo.IK_king) do undo(u) end
        a.undo.IK_king = {}
        a.IK.king.completed = false
      elseif stage == "IK_intrigue" then
        log("processAction(): reset I&K Intrigue action")
        for g,u in pairs(a.undo.IK_intrigue) do undo(u) end
        a.undo.IK_intrigue = {}
        a.IK.intrigue.completed = false
      else
        log("ERROR: processAction() incorrect stage for reset: "..tostring(a.stage)); return   --DEBUG
      end
    end
    a.stage = "main"
    a.description = "Choose an action"
    a.status.info = "Active Player\nChoose actions for\n"..a.name
    a.waitlist = {}
    a.status.waitlist = {}
    a.waiting = 0
    a.status.waitlist={}
    -- updateStatusUI(a.status)
    --TODO: always return status back to G.d.status (beginning of turn?)  Also needed in finished if so.
    updateStatusUI(G.d.status)
    --reset stuff in the action, TODO: more undo.special entries?
    a.caballeros_moved = 0
    if #a.pending_cubes > 0 then
      cleanupCourt(pcol)
      pendingCubes("clear")
    end
    setLockCourt(pcol, true)
    setLockProvinces(pcol, true)
    updatePlayerBoardUI(pcol)
    updateBoardUI()
    updateCastilloUI()
  else
    log("ERROR: processAction() unknown action opt: "..tostring(opt))   --DEBUG
  end
end
--[[ run a special action  MONSTER conditional function!
--]]
function doSpecial(pcol)
  if env.trace then log("doSpecial() "..pcol) end
  local pdata = G.d.players[pcol]
  local a = G.d.action
  local special = a.special
  if special.immediate and special.id ~= "special_scoring" then
    if G.d.veto_player and G.d.veto_player ~= pcol then
      if not(G.d.veto_declined) then
        log("---TESTING: activate veto check for an immediate special action")
        G.d.confirm_lock = true
        UI_setAttribute("veto_player_pnl","color",G.d.veto_player)
        UI_setAttribute("veto_player_txt","text",G.d.veto_player)
        UI_setAttribute("veto_msg_txt","text","Veto _"..a.name.."_?")
        if G.env.intrigue_king_exp then
          UI_setAttribute("veto_pnl","hidden","")
          getObjectFromGUID(G.d.players[G.d.veto_player].power_card).clearButtons()
        else UI_setAttribute("veto_pnl","hidden","re_deal") end
        UI_setAttribute("veto_pnl","active",true)
        return
      else
        log("---TESTING: continue with immediate special action after veto declined")
        G.d.veto_declined = nil
      end
    end
  end

  a.stage = "special"
  local desc = special.desc
  if not(desc) then desc = "Special Action" end
  a.stage_status = desc
  if special.id == "ret2provinces" then
    if special.disk then
      a.stage = "waiting"
      a.waitlist = simpleDeepCopy(a.opponents)
      a.status = {waitlist={},}
      local remove = {}
      for _,c in ipairs(a.waitlist) do
        local p = G.d.players[c]
        p.allowed_regions = {}
        if special.count then --allow regions with count or more caballeros
          for i,g in ipairs(C.region_guids) do
            local r = G.obj.regions[g]
            if not(r.king) and sizeOf(r.caballeros[c]) >= special.count then table.insert(p.allowed_regions,r.scoring_order) end
          end
        end
        if #p.allowed_regions == 0 then --allow any region with 1 or more caballeros
          for i,g in ipairs(C.region_guids) do
            local r = G.obj.regions[g]
            if not(r.king) and sizeOf(r.caballeros[c]) >= 1 then table.insert(p.allowed_regions,r.scoring_order) end
          end
        end
        if #p.allowed_regions == 0 then
          table.insert(remove,c) --player meets no criteria for selection
        else
          p.selected_region = p.allowed_regions[math.random(1,#p.allowed_regions)]
          table.insert(a.status.waitlist,{player_color=c,player_status="Deciding"})
          p.active = true
          p.waiting = true
          p.show_disk = true
          p.disk_button = true
          p.undo_button = false
          p.done_button = true
          p.action_ui = false
          updatePlayerBoardUI(c)
        end
      end
      for _,c in ipairs(remove) do table.remove(a.waitlist,indexOf(a.waitlist,c)) end
      if #a.waitlist > 0 then
        a.undo.special[special.id]={id=special.id, opp=simpleDeepCopy(a.waitlist),}
        a.status.info = "Provinces:\nOpponents select secretly\nReturn -> Provinces"
        a.status.show = true
        updateStatusUI(a.status)
        a.stage = "waiting"
        a.stage_status = "Waiting on opp"
        a.allow_veto = true
        a.waiting = #a.waitlist
      else
        log("WARN: ret2provinces: no opponents have Caballeros elegible to return")
        a.status.info = "Provinces:\nActive Player\nSelect an action"
        a.status.waitlist = {}
        a.status.show = true
        updateStatusUI(a.status)
        a.special_completed = true
        a.stage_status = "No opp met req"
        a.stage = "special"
      end
      pdata.disable_reset = false
      pdata.allow_undo = false
      pdata.undo_button = false
      pdata.done_button = false
      pdata.action_ui = true
      updatePlayerBoardUI(pcol)
    else
      if special.each then
        a.caballeros_moved = {}
        if special.all then for _,c in ipairs(G.d.player_order) do a.caballeros_moved[c]=0 end
        else for _,c in ipairs(a.opponents) do a.caballeros_moved[c]=0 end end
        local remove = {}
        for c,_ in pairs(a.caballeros_moved) do
          local valid = false
          for _,rd in pairs(G.obj.regions) do if sizeOf(rd.caballeros[c]) > 1 then valid = true; break end end
          if not(valid) then table.insert(remove, c) end
        end
        for _,c in ipairs(remove) do a.caballeros_moved[c] = nil end
        a.total_max = sizeOf(a.caballeros_moved) * special.count
        a.total_moved = 0
        a.stage_status = "Moved 0 / "..tostring(a.total_max)
      else
        log("ERROR: processAction(): ret2provinces, single caballeros_moved counter not yet supported")
        return
      end
      pdata.disable_reset = false
      pdata.allow_undo = true
      pdata.undo_button = false
      pdata.done_button = false
      pdata.action_ui = true
      updatePlayerBoardUI(pcol)
    end
  elseif special.id == "prov2court" then
    log("executing immediate special "..special.id)
    local board = getObjectFromGUID(C.player_boards[pcol])
    a.caballeros_moved = 0
    for i=1,special.count do
      if #pdata.provinces > 1 then
        local o = getObjectFromGUID(pdata.provinces[#pdata.provinces])
        o.setLock(false)
        local pos = C.court_pos_l[#pdata.court+1]
        o.setPosition(board.positionToWorld(pos))
        o.setRotation({0,0,0})
        table.insert(pdata.court,o.getGUID())
        table.remove(pdata.provinces,indexOf(pdata.provinces,o.getGUID()))
        Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
        G.obj.snaps[o.getGUID()] = pos
        a.undo.special[o.getGUID()] = {id="prov2court", pcol=pcol, g=o.getGUID()}
        a.caballeros_moved = a.caballeros_moved + 1
      end
    end
    a.allow_veto = false
    a.stage_status = "Moved "..tostring(a.caballeros_moved).." to Court"
    a.special_completed = true
    pdata.undo_button = true
    pdata.allow_undo = true
    pdata.done_button = true
    pdata.action_ui = true
    updatePlayerBoardUI(pcol)
  elseif special.id == "grande" then
    log("move Grande")
    a.stage_status = "Move your Grande"
    a.allow_veto = true
    a.status.waitlist = {}
    a.status.info = a.name..":\n"..a.description
    updateStatusUI(a.status)
    updatePlayerBoardUI(pcol)
  elseif special.id == "special_scoring" then
    log("executing special scoring "..special.id)
    if special.castillo then
      a.allow_veto = false
      pdata.undo_button = false
      pdata.done_button = false
      pdata.action_ui = false
      updatePlayerBoardUI(pcol)
      startScoring({"castillo"},true,"[Castillo,]")
    elseif special.region_score then
      local regions = {}
      local s = "Regions: ["
      if type(special.region_score) == "number" then
        if G.obj.castillo.scoring[1] == special.region_score then
          table.insert(regions,"castillo")
          s = s.."Castillo,"
        end
        for _,r in pairs(G.obj.regions) do
          if r.scoring[1] == special.region_score then
            table.insert(regions,r.scoring_order)
            s = s..tostring(r.scoring_order)..","
          end
        end
      elseif type(special.region_score) == "table" then
        if contains(special.region_score, G.obj.castillo.scoring[1]) then
          table.insert(regions,"castillo")
          s = s.."Castillo,"
        end
        for _,r in pairs(G.obj.regions) do
          if contains(special.region_score, r.scoring[1]) then
            table.insert(regions,r.scoring_order)
            s = s..tostring(r.scoring_order)..","
          end
        end
      end
      s = s .. "]"
      if #regions > 0 then
        a.allow_veto = false
        pdata.undo_button = false
        pdata.done_button = false
        pdata.action_ui = false
        updatePlayerBoardUI(pcol)
        startScoring(regions,true,s)
      end
    elseif special.secret then
      a.stage = "waiting"
      a.status = {waitlist={},}
      a.status.info = a.name.."\n"..special.desc
      a.allow_veto = true
      local undo_ok = false
      if special.players == "all" then a.waitlist = simpleDeepCopy(G.d.player_order)
      elseif special.players == "active" then a.waitlist={G.d.active_player}; undo_ok = true end
      --Show players disk
      for _,p in ipairs(a.waitlist) do
        local pd = G.d.players[p]
        pd.allowed_regions = {1,2,3,4,5,6,7,8,9,}
        table.insert(a.status.waitlist,{player_color=p,player_status="Deciding"})
        pd.active = true
        pd.waiting = true
        pd.show_disk = true
        pd.disk_button = true
        pd.undo_button = false
        pd.done_button = true
        pd.action_ui = undo_ok
        updatePlayerBoardUI(p)
      end
      a.status.show = true
      updateStatusUI(a.status)
      a.waiting = #a.waitlist
    elseif special.most_caballeros or special.least_caballeros then
      --NOTE: castillo is not considered
      local temp = nil
      for _,r in pairs(G.obj.regions) do
        local n = 0
        for _,p in ipairs(G.d.player_order) do n = n + sizeOf(r.caballeros[p]) end
        if n > 0 then
          local new = {r=r.scoring_order,n=n}
          if not(temp) then
            temp = {new}
          else
            if special.most_caballeros and new.n > temp[1].n then temp = {new}
            elseif special.least_caballeros and new.n < temp[1].n then temp = {new}
            elseif new.n == temp[1].n then table.insert(temp,new) end
          end
        end
      end
      if #temp > 0 then
        local regions = {}
        local s = "Regions: ["
        for _,e in ipairs(temp) do table.insert(regions,e.r); s = s .. tostring(e.r).."," end
        s = s .. "]"
        a.allow_veto = false
        pdata.undo_button = false
        pdata.done_button = false
        pdata.action_ui = false
        updatePlayerBoardUI(pcol)
        startScoring(regions,true,s)
      else
        a.stage_status = "No regions to score"
        a.special_completed = true
        a.stage = "special"
        pdata.disable_reset = false
        pdata.allow_undo = true
        pdata.undo_button = true
        pdata.done_button = true
        pdata.action_ui = true
        updatePlayerBoardUI(pcol)
      end
    elseif special.first_only then
      log("special scoring: first_only")
      a.allow_veto = false
      pdata.undo_button = false
      pdata.done_button = false
      pdata.action_ui = false
      updatePlayerBoardUI(pcol)
      startScoring({"first_only"}, true, "1st level of all Regions")
    elseif special.selected then
      a.stage = "waiting"
      a.status = {waitlist={},}
      a.status.info = a.name.."\nSelect 3 possible regions\nOpp chooses 1 to score"
      a.stage_status = "Click on a region"
      a.special.selecting_regions = true
      a.allow_veto = true
      --enable buttons on regions
      for g,_ in pairs(G.obj.regions) do
        getObjectFromGUID(g).createButton(C.region_button)
      end
      a.special.region_candidates = {}
      pdata.waiting = true
      pdata.show_disk = false
      pdata.disk_button = false
      pdata.undo_button = true
      pdata.allow_undo = true
      pdata.disable_reset = false
      pdata.done_button = false
      pdata.action_ui = true
      updatePlayerBoardUI(pcol)
      a.status.show = true
      a.waitlist={pcol}
      table.insert(a.status.waitlist,{player_color=pcol,player_status="Deciding"})
      a.waiting = 1
      updateStatusUI(a.status)
      a.undo.special[tostring(Time.time).."special_scoring_selected"] = {id="special_scoring_selected"}
    elseif special.no_maj then
      pdata.allowed_regions = {}
      for i,g in ipairs(C.region_guids) do
        local rd = G.obj.regions[g]
        if sizeOf(rd.caballeros[pcol]) == 2 then
          for p,d in pairs(rd.caballeros) do
            if p ~= pcol and sizeOf(d) > 2 then
              table.insert(pdata.allowed_regions,i)
              break
            end
          end
        end
      end
      if #pdata.allowed_regions == 0 then
        log("special_scoring:no_maj: handle case no regions allowed")
        a.stage = "special"
        a.stage_status = "No Regions to select!"
        a.disallow_finished = false
        pdata.action_ui = true
        pdata.undo_button = false
        pdata.done_button = false
        updatePlayerBoardUI(pcol)
        return
      end
      a.stage = "waiting"
      a.status.info = a.name.."\n"..special.desc
      a.status.waitlist = {}
      table.insert(a.status.waitlist,{player_color=pcol,player_status="Deciding"})
      a.waitlist = {pcol}
      a.waiting = 1
      a.allow_veto = true
      pdata.active = true
      pdata.waiting = true
      pdata.show_disk = true
      pdata.disk_button = true
      pdata.undo_button = false
      pdata.done_button = true
      pdata.action_ui = false
      pdata.selected_region = pdata.allowed_regions[math.random(1,#pdata.allowed_regions)]
      updatePlayerBoardUI(pcol)
      updateStatusUI(a.status)
    else
      log("WARN: processAction() unknown special_scoring action")
    end
    a.undo.special["special_scoring_"..tostring(Time.time)] = {id="scoring_window",hide=true}
  elseif Split(special.id,"_")[1] == "move" then
    log("move special action")
    a.allow_veto = true
    if special.each then a.caballeros_moved = {Blue=0,Red=0,Green=0,Purple=0,Yellow=0} end
    if special.total then a.total_moved = 0; a.stage_status = "Moved 0 / "..tostring(special.total)
    elseif special.max then a.stage_status = "Moved 0 / "..tostring(special.max)
    else a.stage_status = "Moved 0" end
    if special.max_opp then a.opp_moved = 0 end
    if special.max_own then a.own_moved = 0 end
    if special.court_ok then setLockCourt(pcol, false) end
    a.status.waitlist = {}
    a.status.info = a.name..":\n"..a.description
    updateStatusUI(a.status)
    updatePlayerBoardUI(pcol)
  elseif special.id == "court_2_prov" then
    log("executing immediate special "..special.id)
    for _,p in ipairs(a.opponents) do
      local pdata = G.d.players[p]
      local n = 0
      local remove = {}
      for _,g in ipairs(pdata.court) do
        if special.count and n >= special.count then break end
        table.insert(remove,g)
        returnToProvinces(p, g, true)
        a.undo.special[g] = {id="court2prov", pcol=p, g=g}
        n=n+1
      end
      for _,g in ipairs(remove) do table.remove(pdata.court,indexOf(pdata.court,g)) end
      cleanupCourt(p)
    end
    a.special_completed = true
    a.stage_status = "Special completed"
    a.stage = "special"
    pdata.disable_reset = false
    pdata.allow_undo = true
    pdata.undo_button = true
    pdata.done_button = true
    pdata.action_ui = true
    updatePlayerBoardUI(pcol)
  elseif special.id == "restore_bid" then
    log("special action: restore_bid")
    a.stage = "waiting"
    a.status.info = "Power Cards:\nActive player select a used\nused power bid to restore"
    a.status.waitlist = {}
    updateStatusUI(a.status)
    a.stage_status = "Pick a used bid"
    pdata.disable_reset = false
    pdata.allow_undo = true
    pdata.undo_button = false
    pdata.done_button = true
    pdata.action_ui = true
    updatePlayerBoardUI(pcol)
    --enable buttons on used bid tokens
    for g,button_data in pairs(G.obj.bid_buttons) do
      if indexOf(button_data.used,pcol) > 0 then
        button_data.button_on = true
        button_data.visibility = {pcol}
        updateOrderButtonUI(g,button_data)
      end
    end
  elseif special.id == "2_court_or_all_in_1" then
    setLockCourt(pcol,false)
  elseif special.id == "mobile_score_board" then
    a.score_boards = {}
    for g,d in pairs(G.d.MSB) do
      if not(d.quarantine) then
        local locked = false
        for _,r in pairs(G.obj.regions) do
          if r.score_board == g and (r.king or r.quarantine or r.protected) then locked = true; break end
        end
        if not(locked) then getObjectFromGUID(g).setLock(false); table.insert(a.score_boards, g) end
      end
    end
    a.status.waitlist = {}
    a.status.info = a.name..":\n"..a.description
    updateStatusUI(a.status)
    updatePlayerBoardUI(pcol)
  elseif special.id == "king_returns" then
    log("setup king returns")
    a.stage = "waiting"
    a.allow_veto = true
    a.stage_status = "Opp 3 -> Prov"
    a.status = {}
    a.status.info = "Opponents ret 3 to Provinces\nfrom Court or Regions\nDrop on player board"
    --setup opponents in table order (clockwise) starting to left of active player
    a.waitlist = {}
    local n = indexOf(C.table_order, G.d.active_player)
    for i=1,#C.table_order-1 do
      n = n + 1; if n > #C.table_order then n = 1 end
      if indexOf(a.opponents, C.table_order[n]) > 0 then table.insert(a.waitlist, C.table_order[n]) end
    end
    a.status.waitlist = {}
    a.caballeros_moved = {}
    for i,p in ipairs(a.waitlist) do
      local pd = G.d.players[p]
      if i==1 then table.insert(a.status.waitlist,{player_color=p,player_status="Deciding"})
      else table.insert(a.status.waitlist,{player_color=p,player_status=""}) end
      a.caballeros_moved[p]=0
      pd.active = i == 1
      pd.waiting = true
      pd.show_disk = false
      pd.disk_button = false
      pd.undo_button = false
      pd.done_button = false
      pd.action_ui = false
      updatePlayerBoardUI(p)
      setLockCourt(p, false)
    end
    a.waiting = #a.waitlist
    a.status.show = true
    pdata.done_button = false
    updateStatusUI(a.status)
    updatePlayerBoardUI(a.player)
  elseif special.id == "king" then
    log("move the king")
    a.allow_veto = true
    a.status.waitlist = {}
    a.status.info = a.name..":\n"..a.description
    updateStatusUI(a.status)
    updatePlayerBoardUI(pcol)
  elseif special.id == "evict" then
    log("special action 'Evict'")
    a.stage = "waiting"
    a.status.waitlist={}
    a.status.info = a.name.."\n"..a.description
    table.insert(a.status.waitlist,{player_color=pcol,player_status="Deciding"})
    updateStatusUI(a.status)
    pdata.allowed_regions = {}
    for i,g in ipairs(C.region_guids) do
      if not(G.obj.regions[g].king or G.obj.regions[g].quarantine or G.obj.regions[g].protected) then
        table.insert(pdata.allowed_regions,i)
      end
    end
    pdata.selected_region = pdata.allowed_regions[math.random(1,#pdata.allowed_regions)]
    pdata.active = true
    pdata.waiting = true
    pdata.show_disk = true
    pdata.disk_button = true
    pdata.show_stage = false
    pdata.undo_button = false
    pdata.done_button = true
    pdata.action_ui = true
    updatePlayerBoardUI(pcol)
    a.waitlist = {pcol}
    a.waiting = 1
    special.disk = true
    special.evict_stage = 1
  elseif special.id == "IK_coup" then
    log("executing immediate special "..special.id)
    a.stage = "special"
    local castillo = getObjectFromGUID(C.castillo)
    for p,pd in pairs(G.d.players) do
      if p ~= a.player then
        --check for king
        local taboo = false
        for _,r in pairs(G.obj.regions) do
          if r.grandes[p] and r.king then log(p.." skipped, King is taboo"); taboo = true; break
          else r.grandes[p] = false end
        end
        if not(taboo) then
          local grande = getObjectFromGUID(pd.grande)
          castillo.putObject(grande)
          G.obj.castillo.grandes[p] = pd.grande
        end
      end
    end
    a.stage_status = "Special completed"
    a.IK.special.completed = true
    pdata.disable_reset = false
    pdata.allow_undo = true
    pdata.undo_button = true
    pdata.done_button = true
    pdata.action_ui = true
    updatePlayerBoardUI(pcol)
  elseif special.id == "IK_castillo" then
    log("setup I&K Castillo action")
    a.allow_veto = true
    a.total_moved = 0
    local max, count = 0, a.special.count
    for p,pd in pairs(G.d.players) do
      if p ~= a.player then
        local n = 0; for _,r in pairs(G.obj.regions) do n = n + sizeOf(r.caballeros[p]) end
        if n >= count then max = max + count else max = max + n end
      else
        if #pd.court >= count then max = max + count else max = max + #pd.court end
      end
    end
    a.total_max = max
    a.stage_status = "Moved 0 / "..tostring(a.total_max)
    a.caballeros_moved = {}
    for i,p in ipairs(G.d.player_order) do a.caballeros_moved[p]=0 end
    a.status.waitlist = {}
    a.status.info = a.name..":\n"..a.description
    updateStatusUI(a.status)
    updatePlayerBoardUI(pcol)
    setLockCourt(pcol, false)
  elseif special.id == "bridge" then
    log("Place the Bridge action")
    local bridge = getObjectFromGUID(C.bridge)
    assert(bridge, "doSpecial() id='bridge', no bridge object")
    bridge.call("setActive",true)
    if not(G.d.bridge) then
      G.d.bridge = {}; G.d.bridge.regions = {}
    end
    G.d.bridge.active = true
    a.status.waitlist = {}
    a.status.info = a.name..":\n"..a.description
    updateStatusUI(a.status)
    pdata.done_button = false
    pdata.undo_button = false
    G.d.action.disallow_finished = true
    updatePlayerBoardUI(pcol)
  elseif special.id == "IK_quarantine" then
    log("Setup Quarantine action")
    --Enable (unlock) scoreboards availble to be used for the Quarantine
    --if existing quarantine, use it unless taboo
    local found = false
    for g,d in pairs(G.d.MSB) do
      if d.quarantine then
        for _,r in pairs(G.obj.regions) do
          if r.score_board == g then
            if not(r.king or r.protected) then
              getObjectFromGUID(g).setLock(false)
            else
              assert(false,"doSpecial(): current quarantine region is taboo for non-quarantine reason, not possible?")
              return
            end
            found = true
            break
          end
        end
      end
    end
    if not(found) then
      -- use an available unassigned scoreboard
      local unused = false
      for g,d in pairs(G.d.MSB) do
        if not(d.placed) then
          getObjectFromGUID(g).setLock(false)
          unused = true
        end
      end
      if not(unused) then
        --enable both of the used scoreboards unless taboo
        for g,d in pairs(G.d.MSB) do
          for _,r in pairs(G.obj.regions) do
            if r.score_board == g then
              if not(r.king or r.protected) then
                getObjectFromGUID(g).setLock(false)
              end
            end
          end
        end
      end
    end
    a.status.waitlist = {}
    a.status.info = a.name..":\n"..a.description
    updateStatusUI(a.status)
    pdata.done_button = false
    pdata.undo_button = false
    G.d.action.disallow_finished = true
    updatePlayerBoardUI(pcol)
  elseif special.id == "region_score_double" then
    log("Setup select region for double scoring")
    a.status.waitlist = {}
    table.insert(a.status.waitlist,{player_color=pcol,player_status="Deciding"})
    a.status.info = a.name..":\n"..a.description
    a.waitlist = {pcol}
    a.waiting = 1
    a.stage = "waiting"
    updateStatusUI(a.status)
    pdata.undo_button = false
    pdata.done_button = true
    pdata.disk_button = true
    pdata.show_disk = true
    pdata.action_ui = false
    --TODO: should king/quarantine/protection be respected here? saying yes for now
    pdata.allowed_regions = {}
    for i,g in ipairs(C.region_guids) do
      if not(G.obj.regions[g].king or G.obj.regions[g].quarantine or G.obj.regions[g].protected) then
        table.insert(pdata.allowed_regions,i)
      end
    end
    pdata.selected_region = pdata.allowed_regions[math.random(#pdata.allowed_regions)]
    a.disallow_finished = true
    updatePlayerBoardUI(pcol)
  elseif special.id == "take6" then
    log("Setup Take6 region selection")
    pdata.allowed_regions = {}
    for i,g in ipairs(C.region_guids) do
      if not(G.obj.regions[g].king or G.obj.regions[g].quarantine or G.obj.regions[g].protected) then
        local n = 0; for _,list in pairs(G.obj.regions[g].caballeros) do n = n + sizeOf(list) end
        if n <= 6 then table.insert(pdata.allowed_regions,i) end
      end
    end
    if #pdata.allowed_regions == 0 then
      log("handle case no regions allowed")
      a.stage = "special"
      a.stage_status = "No Regions to select!"
      a.disallow_finished = false
      pdata.action_ui = true
      pdata.undo_button = false
      pdata.done_button = false
      updatePlayerBoardUI(pcol)
      return
    end
    a.status.waitlist = {}
    table.insert(a.status.waitlist,{player_color=pcol,player_status="Deciding"})
    a.stage = "waiting"
    a.status.info = a.name..":\n"..a.description
    a.waitlist = {pcol}
    a.waiting = 1
    a.allow_veto = true
    updateStatusUI(a.status)
    pdata.undo_button = false
    pdata.done_button = true
    pdata.disk_button = true
    pdata.show_disk = true
    pdata.action_ui = false
    pdata.selected_region = pdata.allowed_regions[math.random(#pdata.allowed_regions)]
    a.disallow_finished = true
    updatePlayerBoardUI(pcol)
  elseif special.id == "espionage" then
    log("set espionage card for later in general scoring, TODO: review this")
    pdata.espionage = pdata.power_card --TODO: code review this, might still be ok
    pdata.done_button = false
    pdata.undo_button = false
    pdata.action_ui = true
    a.disallow_finished = false
    a.stage_status = "Espionage set"
    updatePlayerBoardUI(pcol)
  elseif special.id == "court_any_region" then
    log("modify the court action to allow any region")
    a.court_any_region = true
    pdata.done_button = false
    pdata.undo_button = false
    pdata.action_ui = true
    a.disallow_finished = false
    a.stage_status = "Court action modified"
    updatePlayerBoardUI(pcol)
  elseif special.id == "remove_face_up" then
    log("Set up action to remove a face up card")
    local cards = {}
    for p,pd in pairs(G.d.players) do
      for g,_ in pairs(pd.held_cards) do
        local c = getObjectFromGUID(g)
        if power_cards[c.value].special.leave_face_up then
          c.createButton(C.face_up_button)
          c.setLock(true) --HACK: some bug in prior code is not locking the card, see code that places the card
          table.insert(cards,g)
        end
      end
    end
    a.undo.special["remove_face_up_"..tostring(Time.time)] = {id="remove_face_up", clear_buttons=true, cards=cards}
    a.status.waitlist = {}
    a.status.info = a.name..":\n"..a.description
    updateStatusUI(a.status)
    pdata.done_button = false
    pdata.undo_button = false
    G.d.action.disallow_finished = true
    updatePlayerBoardUI(pcol)
  elseif special.id == "royal_protection" then
    log("setup region selection for royal protection action")
    pdata.allowed_regions = {}
    for i,g in ipairs(C.region_guids) do
      if not(G.obj.regions[g].king or G.obj.regions[g].quarantine or G.obj.regions[g].protected) then
        local n = 0; for _,list in pairs(G.obj.regions[g].caballeros) do n = n + sizeOf(list) end
        if n <= 6 then table.insert(pdata.allowed_regions,i) end
      end
    end
    if #pdata.allowed_regions == 0 then
      log("handle case no regions allowed")
      a.stage = "special"
      a.stage_status = "No Regions to select!"
      a.disallow_finished = false
      pdata.action_ui = true
      pdata.undo_button = false
      pdata.done_button = false
      updatePlayerBoardUI(pcol)
      return
    end
    a.status.waitlist = {}
    table.insert(a.status.waitlist,{player_color=pcol,player_status="Deciding"})
    a.status.info = a.name..":\n"..a.description
    a.waitlist = {pcol}
    a.waiting = 1
    a.stage = "waiting"
    updateStatusUI(a.status)
    pdata.undo_button = false
    pdata.done_button = true
    pdata.disk_button = true
    pdata.show_disk = true
    pdata.action_ui = false
    pdata.selected_region = pdata.allowed_regions[math.random(#pdata.allowed_regions)]
    a.disallow_finished = true
    updatePlayerBoardUI(pcol)
  elseif special.id == "relocate" then
    log("--- TODO: setup for relocate special action")
    a.stage_status = "Moved 0 / "..tostring(special.max)
    a.caballeros_moved = 0
    a.status.waitlist = {}
    a.status.info = a.name..":\n"..a.description
    a.description = special.desc
    updateStatusUI(a.status)
    a.disallow_finished = true
    updatePlayerBoardUI(pcol)
  elseif special.id == "reserves" then
    log("--- TODO: reserves immediate action")
    a.allow_veto = false
    if #pdata.provinces == 0 then log("WARN: doSpecial():reserves, player "..pcol.." Provinces are empty"); return end
    local o = getObjectFromGUID(pdata.provinces[#pdata.provinces])
    assert(o,"ERROR: doSpecial():reserves unable to locate Provinces cube object") --DEBUG
    local card = getObjectFromGUID(pdata.power_card)
    local pos = card.getPosition()
    pos.y = pos.y + 1
    o.setLock(false)
    o.setPosition(pos)
    Wait.condition(function() o.setLock(true); G.obj.snaps[o.getGUID()] = o.getPosition() end, function() return o.resting end, 5)
    pdata.provinces[#pdata.provinces] = nil
    pdata.reserves = o.getGUID()
    pdata.held_cards[card.getGUID()].cube = o.getGUID()
    a.undo.special[card.getGUID()..tostring(Time.time)] = {id="reserves", pcol=pcol, cube=o.getGUID(), card=card.getGUID()}
    a.stage_status = "Reserves assigned"
    a.special_completed = true --TODO: a.IK.special.completed = true ???
    pdata.undo_button = true
    pdata.allow_undo = true
    pdata.done_button = true
    pdata.action_ui = true
    updatePlayerBoardUI(pcol)
  else
    log("ERROR: processAction() unhandled special id "..tostring(special.id)); return --DEBUG
  end
end
--[[ Add a Caballero to a region. Does nothing if already in region.
  Check region validity and update new region.
  Never allowed in king region.
  If in action phase, check validity and update action/undo.
  Return true if result is ok.  False if not.
  NOTE: Caller is responsible for updating snaps or snapBack based on result.
]]
--  TODO: review shared code between addCaballero, setGrande, setKing
function addCaballero(player, region, color, guid)
  if env.trace then log("addCaballero() "..tostring(region)..", "..tostring(color)..":"..tostring(guid)) end
  if G.d.phase == "bidding" then return false end
  local rdata = G.obj.regions[region]
  local function debug(str) if true then log("DEBUG addCaballero(): "..str) end end --DEBUG: set false to disable
  local function add()
    rdata.caballeros[color][guid] = true
    getObjectFromGUID(region).highlightOn(Color["Yellow"],1)
    for g,r in pairs(G.obj.regions) do
      if g ~= region and r.caballeros[color][guid] then r.caballeros[color][guid] = nil end
    end
    if indexOf(G.d.players[color].court,guid) > 0 then table.remove(G.d.players[color].court,indexOf(G.d.players[color].court,guid)) end
    updateBoardUI()
  end
  local function neighborToKing(r)
    for _,n in ipairs(r.neighbors) do
      if G.obj.regions[C.region_guids[n]].king then return true end
    end
    return false
  end
  -- Make some initial checks on destination region
  if rdata.king then debug("failed king region is taboo"); return false end
  if rdata.quarantine then debug("failed region is quarantined"); return false end
  if rdata.protected then debug("failed region has royal protection"); return false end
  if rdata.caballero_limit then
    local n = 0
    for _,list in pairs(rdata.caballeros) do n = n + sizeOf(list) end
    if n >= rdata.caballero_limit then debug("failed region has been limited to "..tostring(rdata.caballero_limit)); return false end
  end
  if G.d.phase == "placement" or G.d.phase == "IK_extra_placement" then add()
  elseif G.d.phase == "actions" then
    local a = G.d.action
    local allowed, any_region, min, max, total, each, opp, any, either, origin = false, false, nil, nil, nil, false, false, false, false, nil
    if a.stage == "main" and G.d.bridge then
      --special case at beginning of turn only, allow cubes to cross bridge
      if not(color == G.d.bridge.player) then debug("failed, cube does not match bridge color"); return false end
      if not(contains(G.d.bridge.regions, region)) then debug("failed, not a bridge region"); return false end
      if #a.sequence > 0 then debug("failed, not beginning of turn"); return false end --make sure no actions have been taken
      local source = ""
      for g,r in pairs(G.obj.regions) do
        if r.caballeros[color][guid] then
          if r.king or r.quarantine or r.protected then debug("failed, cannot bridge move from a taboo region"); return false end
          source=g; break
        end
      end
      assert(source ~= "","addCaballero(): failed to locate source during bridge move")
      debug("Player "..player.." does a Bridge Move at start of turn")
      add()
      if not(a.undo.main[guid]) then
        a.undo.main[guid]={id="move_caballero",g=guid,color=color,pcol=a.player,origin=source,snap=G.obj.snaps[guid],}
      end
      return true
    end
    if a.stage == "waiting" then
      --special case during staged cube placement with no undo (i.e. Evict).  There may be others.
      local dest = C.region_guids[G.d.players[color].selected_region]
      if region ~= dest then debug("failed destination check during castillo placement"); return false end
      if indexOf(G.d.players[color].staged_cubes,guid) > 0 then
        local i = indexOf(G.d.players[color].cubes_to_place,guid)
        if i > 0 then table.remove(G.d.players[color].cubes_to_place,i) end
        if #G.d.players[color].cubes_to_place == 0 then
          G.d.players[color].disk_button = false
          G.d.players[color].undo_button = false
          G.d.players[color].done_button = true
          G.d.players[color].active = true
          updatePlayerBoardUI(color)
        end
      else
        debug("ERROR: cube "..guid.." not in player "..color.." staged cubes list"); return false
      end
      add()
      return true
    end
    if a.stage == "special" then
      debug("add caballero during special")
      local s = a.special
      if Split(s.id,"_")[1] == "move" then
        log("is a move special action")
        if player ~= G.d.active_player then debug("failed: "..player.." is not the active player"); return false end
        -- any_region = contains(s, "any_region")
        any_region = s.dest == "any_region"
        allowed = true
        if Split(s.id,"_")[2] == "either" then either = true end
        if Split(s.id,"_")[2] == "opp" then opp = true end
        if Split(s.id,"_")[2] == "any" then any = true end
        if Split(s.id,"_")[2] == "court" then origin = "court" end
        max = s.max
        min = s.min
        if s.each then each = true end
        if s.total then total = s.total end
      elseif s.id == "relocate" then
        if not(s.destination) then s.destination = region
        elseif region ~= s.destination then debug("failed: only one destination region allowed"); return false end
        max = s.max
        any_region = s.dest == "any_region"
        allowed = true
      end
      if s.single_origin then
        if s.origin then
          if s.origin == "court" then
            if not(contains(G.d.players[color].court,guid)) then debug("failed origin not court"); return false end
          end
        else
          if contains(G.d.players[color].court,guid) then
            if s.court_ok then s.origin = "court" else debug("failed, origin court not allowed"); return false end
          else
            for g,r in pairs(G.obj.regions) do
              if r.caballeros[color][guid] then s.origin=g; break end
            end
          end
        end
        origin = s.origin
        allowed = true
      end
      if not(allowed) then debug("move caballero not allowed"); return false end
      if not(any_region) then if not(neighborToKing(rdata)) then debug("failed king neigbor check"); return false end end
      if contains(a.pending_cubes,guid) then
        if a.undo[a.stage][guid] and region == a.undo[a.stage][guid].origin then
          log("--- TODO: replacing cube in origin region, reset things for it")
          --TODO: check for replacing in origin and reset things for this cube if it is
          -- clear from pendingCubes
          -- decrement moved cubes counter(s)
          -- reset buttons if needed
          -- update displays
          -- clear undo
        end
        add(); return true --allow pending cubes after king check
      end
      if color == a.player and opp then debug("failed, only opp allowed"); return false
      elseif color ~= a.player and not(opp or any or either) then debug("failed, opp not allowed"); return false end
      --check move limits
      if each then
        if max and a.caballeros_moved[color] >= max then debug("failed limit check for each"); return false end
        if total and a.total_moved >= total then debug("failed limit check for total"); return false end
      else
        if max and a.caballeros_moved >= max then debug("failed limit check"); return false end
        if color ~= a.player and s.max_opp and a.opp_moved >= s.max_opp then debug("failed limit check for opp max"); return false end
        if color == a.player and s.max_own and a.own_moved >= s.max_own then debug("failed limit check for own max"); return false end
      end
    elseif a.stage == "court" then
      debug("add caballero during court")
      if not(a.court_any_region) then
        if not(neighborToKing(rdata)) then debug("failed king neigbor check"); return false end
      end
      if contains(a.pending_cubes,guid) then add(); return true end --allow pending cubes after king check
      if a.caballeros_moved >= a.court then debug("failed move limit check"); return false end
      if not(contains(G.d.players[a.player].court, guid)) then debug("failed source is court check"); return false end
    else
      log("WARN: auto fail caballero placement for unhandled action.stage")
      return false
    end
    -- Passed above checks, now if first time for this guid, setup the undo. Check cube source against action origin if defined.
    local stage = a.stage
    if stage == "special" and a.special.IK then stage = a.special.IK end
    if not(contains(a.sequence,stage)) then table.insert(a.sequence,stage) end
    debug("stage is "..tostring(stage))
    if not(a.undo[stage][guid]) then
      local source = ""
      if a.stage == "court" then
        source = "court"
        a.undo[stage][guid]={id="court",g=guid,pcol=a.player,origin="court"}
        a.caballeros_moved = a.caballeros_moved + 1
        pendingCubes("add",guid)
        updatePlayerBoardUI(a.player)
      elseif a.stage == "special" then
        local source = ""
        if contains(G.d.players[color].court,guid) then source = "court" end
        for g,r in pairs(G.obj.regions) do
          if r.caballeros[color][guid] then
            if r.king or r.quarantine or r.protected then debug("failed, cannot move from a taboo region"); return false end
            source=g; break
          end
        end
        if origin and source ~= origin then debug("failed origin check"); return false end
        if each then
          a.caballeros_moved[color] = a.caballeros_moved[color] + 1
          local n = 0; for _,c in pairs(a.caballeros_moved) do n=n+c end
          if total then a.total_moved = n; a.stage_status = "Moved "..tostring(n).." / "..tostring(total)
          elseif max then a.stage_status = "Moved "..tostring(n).." / "..tostring(max)
          else a.stage_status = "Moved "..tostring(n) end
        else
          if either then
            if color == a.player then
              a.special.id = "move_own_caballero" --HACK: find a better way than modifying id
            else
              a.special.id = "move_opp_caballero" --HACK: find a better way than modifying id
              a.special.max = 1
              max = 1
            end
            a.undo[stage][tostring(Time.time).."_"..guid] = {id="move_either_caballero"} --HACK: need an undo to reset id
          end
          a.caballeros_moved = a.caballeros_moved + 1
          if a.opp_moved and color ~= a.player then a.opp_moved = a.opp_moved + 1 end
          if a.own_moved and color == a.player then a.own_moved = a.own_moved + 1 end
          if max then a.stage_status = "Moved "..tostring(a.caballeros_moved).." / "..tostring(max)
          else a.stage_status = "Moved "..tostring(a.caballeros_moved) end
        end
        pendingCubes("add",guid)
        updatePlayerBoardUI(a.player)
        if source == "court" then
          a.undo[stage][guid]={id="court",g=guid,color=color,pcol=a.player,origin="court",}
        else
          a.undo[stage][guid]={id="move_caballero",g=guid,color=color,pcol=a.player,origin=source,snap=G.obj.snaps[guid],}
        end
      end
    end
    add()
  elseif G.d.phase == "scoring" then
    if not(G.d.players[color].espionage) then
      local dest = C.region_guids[G.d.players[color].selected_region]
      if region ~= dest then debug("failed destination check during castillo placement"); return false end
    end
    if indexOf(G.d.players[color].staged_cubes,guid) > 0 then
      local i = indexOf(G.d.players[color].cubes_to_place,guid)
      if i > 0 then table.remove(G.d.players[color].cubes_to_place,i) end
      if #G.d.players[color].cubes_to_place == 0 then
        G.d.players[color].disk_button = false
        G.d.players[color].undo_button = false
        G.d.players[color].done_button = true
        G.d.players[color].active = true
        updatePlayerBoardUI(color)
      end
    else
      debug("ERROR: cube "..guid.." not in player "..color.." staged cubes list"); return false
    end
    add()
    return true
  else
    log("WARN: addCaballero() unknown phase")
    return false
  end
  return true
end
--[[ Sets a Grande in a region. Does nothing if already in region.
Check region validity and update new region.
Never allowed in king region.
If in action phase, check validity and update action/undo.
Return true if result is ok.  False if not.
NOTE: Caller is responsible for updating snaps or snapBack based on result.
TODO: review shared code between addCaballero, setGrande, setKing
]]
--TODO: handle case Grande has been put in Castillo
function setGrande(region, color)
  if env.trace then log("setGrande() "..tostring(region)..", "..tostring(color)) end
  if G.d.phase == "bidding" then return false end
  local guid = G.d.players[color].grande
  local rdata = G.obj.regions[region]
  local function debug(str) if true then log(str) end end --DEBUG: set false to disable verbose debug in this function
  local function add()
    for g,r in pairs(G.obj.regions) do
      if g == region then
        r.grandes[color] = true
        getObjectFromGUID(g).highlightOn(Color["Yellow"],1)
      else r.grandes[color] = false end
    end
    updateBoardUI()
  end
  local function neighborToKing(r)
    for _,n in ipairs(r.neighbors) do
      if G.obj.regions[C.region_guids[n]].king then return true end
    end
    return false
  end
  if rdata.king or rdata.quarantine or rdata.protected then debug("failed, cannot move to taboo region"); return false end
  if G.d.phase == "placement" then add()
  elseif G.d.phase == "actions" then
    local a = G.d.action
    if a.stage == "special" then
      debug("set Grande during special")
      local allowed, any_region, opp = false, false, false
      if a.special.id == "grande" then
        allowed = true
        any_region = a.special.dest == "any_region"
        if a.special.opp then opp = true end
      elseif a.special.id == "relocate" then
        if color ~= a.player then debug("failed opponent check"); return false end
        if not(a.special.destination) then a.special.destination = region
        elseif region ~= a.special.destination then debug("failed: only one destination region allowed"); return false end
        allowed = true
        any_region = a.special.dest == "any_region"
        a.disallow_finished = false
        updatePlayerBoardUI(a.player)
      end
      if color ~= a.player and not(opp) then debug("failed opponent check"); return false end
      if not(allowed) then debug("failed special check"); return false end
      if not(any_region) then if not(neighborToKing(rdata)) then debug("failed king neigbor check"); return false end end
      if contains(a.pending_cubes,guid) then add(); return true end --allow pending cubes after king and action check
    elseif a.stage == "court" then
      debug("fail set Grande during court")
      return false
    else
      --TODO: any other stages valid?
      log("WARN: fail Grande placement for unhandled action.stage")
      return false
    end
    local stage = a.stage
    if stage == "special" and a.special.IK then stage = a.special.IK end
    if not(contains(a.sequence,stage)) then table.insert(a.sequence,stage) end
    --save an undo on first time to retain origin info
    if not(a.undo[stage][guid]) then
      local old = nil
      for g,r in pairs(G.obj.regions) do
        if r.grandes[color] then old = g; break end
      end
      local rold = G.obj.regions[old]
      if rold.king or rold.quarantine or rold.protected then debug("failed, cannot move from taboo region"); return false end
      pendingCubes("add",guid)
      a.undo[stage][guid]={id="move_grande",g=guid,region=region,origin=old,snap=G.obj.snaps[guid]}
    end
    add()
  elseif G.d.phase == "scoring" then
    --TODO: just return true when auto placing from the castillo during scoring?
    debug("set Grande during scoring")
    if not(G.d.players[color].espionage) then
      local dest = C.region_guids[G.d.players[color].selected_region]
      if region ~= dest then debug("failed destination check during castillo placement"); return false end
    end
    if indexOf(G.d.players[color].staged_cubes,guid) > 0 then
      local i = indexOf(G.d.players[color].cubes_to_place,guid)
      if i > 0 then table.remove(G.d.players[color].cubes_to_place,i) end
      if #G.d.players[color].cubes_to_place == 0 then
        G.d.players[color].disk_button = false
        G.d.players[color].undo_button = false
        G.d.players[color].done_button = true
        G.d.players[color].active = true
        updatePlayerBoardUI(color)
      end
    else
      debug("ERROR: cube "..guid.." not in player "..color.." staged cubes list"); return false
    end
    add()
    return true
  else
    log("WARN: setGrande() unknown phase")
  end
  return true
end
--[[ Sets the King in a region. Does nothing if already in region.
  Only allowed in action phase, check validity and update action/undo.
  Return true if result is ok.  False if not.
  NOTE: Caller is responsible for updating snaps or snapBack based on result.
  TODO: review shared code between addCaballero, setGrande, setKing
]]
function setKing(region)
  if env.trace then log("setKing() "..tostring(region)) end
  local function debug(str) if true then log("DEBUG setKing() "..str) end end --DEBUG: set false to disable verbose debug in this function
  if G.d.phase == "bidding" then debug("fail set king during bidding"); return false end
  local rdata = G.obj.regions[region]
  if rdata.quarantine or rdata.protected then debug("failed, cannot move king to taboo region"); return false end
  local guid = C.king
  local function add()
    for g,r in pairs(G.obj.regions) do
      if g == region then
        r.king = true
        getObjectFromGUID(g).highlightOn(Color["Yellow"],1)
      else r.king = false end
    end
    updateBoardUI()
  end
  if G.d.phase == "placement" then
    for g,r in pairs(G.obj.regions) do if r.king then return false end end --don't allow movement in placement phase if assigned,
    add()
  elseif G.d.phase == "actions" then
    local a = G.d.action
    local stage = a.stage
    if stage == "special" and a.special.IK then stage = a.special.IK end
    if not(contains(a.sequence,stage)) then table.insert(a.sequence,stage) end
    if stage == "special" or stage == "IK_king" then
      debug("set King during special")
      local allowed, any_region, adjacent, origin = false, false, false, nil
      if contains(a.special, "king") then
        allowed = true
        any_region = a.special.dest == "any_region"
      end
      if not(allowed) then debug("failed special check"); return false end
      --save an undo on first time to retain origin info
      if not(a.undo[stage][guid]) then
        if not(any_region) then
          for _,n in ipairs(rdata.neighbors) do if G.obj.regions[C.region_guids[n]].king then adjacent = true end end
          if not(adjacent) then debug("failed King initial adjacency check"); return false end
        end
        for g,r in pairs(G.obj.regions) do if r.king then origin = g; break end end
        a.undo[stage][guid]={id="move_king",g=guid,origin=origin,snap=G.obj.snaps[guid]}
      elseif not(any_region) then
        for _,n in ipairs(rdata.neighbors) do if C.region_guids[n] == a.undo[stage][guid].origin then adjacent = true; break end end
        if not(adjacent) then debug("failed King origin adjacency check"); return false end
      end
      add()
      a.stage_status = "King moved"
      a.disallow_finished = false
      updatePlayerBoardUI(a.player)
    elseif stage == "court" then debug("fail set King during court"); return false
    else debug("WARN: fail set King for unhandled action stage "..tostring(stage)); return false end
  else debug("WARN: setKing() unknown phase"); return false end
  return true
end
--[[ Adds a Caballero to the Castillo when a player drops it over the bag.
]]
function addToCastillo(obj)
  if env.trace then log("addToCastillo()") end
  local function debug(str) if true then log("DEBUG: addToCastillo() "..str) end end --DEBUG: set false to disable
  local color = obj.memo; assert(color,"addToCastillo(): color missing")
  local guid = obj.getGUID()
  local castillo = getObjectFromGUID(C.castillo)
  local function add()
    if contains(G.d.action.pending_cubes,guid) then pendingCubes("remove",guid) end
    castillo.putObject(obj)
    castillo.highlightOn(Color["Yellow"],1)
    table.insert(G.obj.castillo.caballeros[color],guid)
    for g,r in pairs(G.obj.regions) do
      if r.caballeros[color][guid] then r.caballeros[color][guid] = nil end
    end
    updateCastilloUI()
  end
  if obj.hasTag("Caballero") then
    if G.d.phase == "actions" then
      local a = G.d.action
      local allowed, min, max, each, opp, any, origin, total = false, nil, nil, false, false, false, nil, nil
      if a.stage == "special" or a.stage == "waiting" then
        debug("add Caballero to Castillo during action special stage")
        local s = a.special
        if Split(s.id,"_")[1] == "move" then
          allowed = true
          if Split(s.id,"_")[2] == "opp" then opp = true end
          if Split(s.id,"_")[2] == "any" then any = true end
          if Split(s.id,"_")[2] == "court" then origin = "court" end
          max = s.max; min = s.min
          if s.each then each = true end
          if s.total then total = s.total end
        elseif s.id == "IK_castillo" then
          any = true
          each = true
          min = s.count
          max = s.count
          total = a.total_max
          allowed = true
          if color == a.player then origin = "court" end
        elseif s.single_origin then
          if s.origin then
            if s.origin == "court" then
              max = s.max
              if not(contains(G.d.players[color].court,guid)) then debug("failed origin not court"); return false end
            end
          else
            if contains(G.d.players[color].court,guid) then
              if s.court_ok then s.origin = "court" else debug("failed, origin court not allowed"); return false end
            else
              for g,r in pairs(G.obj.regions) do
                if r.caballeros[color][guid] then
                  if r.king or r.quarantine or r.protected then debug("failed, cannot move from taboo region"); return false end
                  s.origin=g; break
                end
              end
            end
          end
          origin = s.origin
          allowed = true
        end
        if not(allowed) then debug("move caballero not allowed"); return false end
        if contains(a.pending_cubes,guid) then --allow pending cubes after above checks
          add(); return true
        end
        if color == a.player and opp then debug("failed, only opp allowed"); return false
        elseif color ~= a.player and not(opp or any) then debug("failed, opp not allowed"); return false end
        --check move limits
        if each then
          if max and a.caballeros_moved[color] >= max then debug("failed limit check for each"); return false end
          if total and a.total_moved >= total then debug("failed limit check for total"); return false end
        else
          if max and a.caballeros_moved >= max then debug("failed limit check"); return false end
          if color ~= a.player and s.max_opp and a.opp_moved >= s.max_opp then debug("failed limit check for opp max"); return false end
          if color == a.player and s.max_own and a.own_moved >= s.max_own then debug("failed limit check for own max"); return false end
        end
      elseif a.stage == "court" then
        debug("add Caballero to Castillo during action court stage")
        if not(contains(a.pending_cubes,guid)) then
          if a.caballeros_moved >= a.court then debug("failed move limit check"); return false end
          if not(contains(G.d.players[a.player].court, guid)) then debug("failed source is court check"); return false end
        end
      else
        debug("ERROR: unhandled action stage "..tostring(a.stage)); return false
      end
      local stage = a.stage
      if stage == "special" and a.special.IK then stage = a.special.IK end
      if not(contains(a.sequence,stage)) then table.insert(a.sequence,stage) end
      --passed checks
      if stage == "court" then
        if a.undo[stage][guid] then --was alread moved so update the undo
          debug("update undo for "..guid)
          a.undo[stage][guid].id = "castillo"
          a.undo[stage][guid].color = obj.memo
          pendingCubes("remove",guid)
        else
          a.undo[stage][guid]={id="castillo",g=guid,color=obj.memo,pcol=a.player,origin="court"}
          a.caballeros_moved = a.caballeros_moved + 1
          local pdata = G.d.players[a.player]
          if indexOf(pdata.court,guid) > 0 then table.remove(pdata.court,indexOf(pdata.court,guid)) end
          updatePlayerBoardUI(a.player)
        end
      else
        --determine source
        local source = ""
        if contains(G.d.players[color].court,guid) then source = "court" end
        for g,r in pairs(G.obj.regions) do
          if r.caballeros[color][guid] then
            if r.king or r.quarantine or r.protected then debug("failed, cannot move from taboo region"); return false end
            source=g; break
          end
        end
        --check action origin requirement
        if origin and source ~= origin then debug("failed origin check"); return false end
        --handle "each" and increment counters, update stage_status
        if each then
          a.caballeros_moved[color] = a.caballeros_moved[color] + 1
          local n = 0; for _,c in pairs(a.caballeros_moved) do n=n+c end
          if total then a.total_moved = n; a.stage_status = "Moved "..tostring(n).." / "..tostring(total)
          elseif max then a.stage_status = "Moved "..tostring(n).." / "..tostring(max)
          else a.stage_status = "Moved "..tostring(n) end
        else
          a.caballeros_moved = a.caballeros_moved + 1
          if a.opp_moved and color ~= a.player then a.opp_moved = a.opp_moved + 1 end
          if a.own_moved and color == a.player then a.own_moved = a.own_moved + 1 end
          if max then a.stage_status = "Moved "..tostring(a.caballeros_moved).." / "..tostring(max)
          else a.stage_status = "Moved "..tostring(a.caballeros_moved) end
        end
        pendingCubes("add",guid)
        updatePlayerBoardUI(a.player)
        if source == "court" then
          local pdata = G.d.players[color]
          a.undo[stage][guid]={id="castillo",g=guid,color=color,player=color,origin="court",}
          if indexOf(pdata.court,guid) > 0 then table.remove(pdata.court,indexOf(pdata.court,guid))
          else assert(false,"addToCastillo(): could not remove guid "..tostring(guid).." from player "..color.." Court ") end
        else
          a.undo[stage][guid]={id="castillo",g=guid,color=color,player=a.player,origin=source,snap=G.obj.snaps[guid],}
        end
      end
      add()
    else
      debug("ERROR: unhandled game phase")
    end
  elseif obj.hasTag("Grande") then
    debug("fail, Grande in Castillo not implemented")
    --base game doesn't do this, but Intrigue expansion might
    return false
  else
    debug("ERROR: unhandled obj tag")
  end
  return true
end
--[[ Adds a mobile score board to a region when dropped on it
  NOTE: region may be a region guid or "castillo" and is handled accordingly
--]]
--TODO: get rid of replace ??? (not allowed)
function addScoreBoard(region, guid)
  if env.trace then log("addScoreBoard() "..tostring(region)..", "..tostring(guid)) end
  local function debug(str) if true then log("addScoreBoard(): "..str) end end --DEBUG: set false to disable verbose debug in this function
  if G.d.phase == "actions" then
    local rdata,origin,replace = nil,nil,nil
    if region == "castillo" then rdata = G.obj.castillo
    else rdata = G.obj.regions[region] end
    if rdata.king or rdata.quarantine or rdata.protected then debug("failed, region is taboo"); snapBack(guid); return end
    if rdata.score_board then debug("failed existing scoreboard check"); snapBack(guid); return end
    debug("placing mobile score board in "..tostring(region))
    --clear this scoreboard from any existing region or castillo
    if G.obj.castillo.score_board == guid then
      debug("moving from castillo, reset it")
      G.obj.castillo.score_board = false
      G.obj.castillo.scoring = simpleDeepCopy(C.castillo_template.scoring)
      origin = "castillo"
    else
      for g,rd in pairs(G.obj.regions) do
        if g ~= region and rd.score_board == guid then
          if rd.king or rd.quarantine or rd.protected then debug("failed, cannot move from taboo region"); snapBack(guid); return end
          debug("moving from another region, reset that region")
          rd.score_board = false
          if G.d.scoring_mask then object_UI_setAttribute(g, "scoreboard_image", "image", G.d.scoring_mask)
          else object_UI_setAttribute(g, "scoreboard", "active", false) end
          rd.scoring = simpleDeepCopy(C.regions_template[g].scoring)
          origin = g
          break
        end
      end
    end
    --set in new region
    rdata.score_board = guid
    rdata.scoring = simpleDeepCopy(G.d.MSB[guid].scoring)
    --place scoreboard under region status panel or on castillo
    if region == "castillo" then pos = C.castillo_mb_position
    else pos = C.score_board_positions[indexOf(C.region_guids,region)] end
    local o = getObjectFromGUID(guid)
    o.setPosition(pos)
    Wait.condition(function()
      for g,_ in pairs(G.d.MSB) do getObjectFromGUID(g).setLock(true) end
    end, function() return o.resting end, 5)
    G.d.MSB[guid].placed = true
    --set the undo data and update object snaps
    G.d.action.undo.special[guid]={id="scoreboard",g=guid,region=region,origin=origin,replace=replace,snap=G.obj.snaps[guid]}
    G.obj.snaps[guid] = pos
    if region ~= "castillo" then
      debug("setting mb_image to "..tostring(G.d.MSB[guid].image))
      object_UI_setAttribute(region, "scoreboard_image", "image", G.d.MSB[guid].image)
      object_UI_setAttribute(region, "scoreboard", "active", true)
    end
    updateBoardUI()
  else
    debug("fail addScoreBoard(): not in actions phase")
    snapBack(guid)
  end
end
--[[ Add a quarantine to the specified region.
  Checks validity and return true if success, false if not.
  region: guid of region
  guid: guid of mobile score board used as quarantine
--]]
function addQuarantine(region, guid)
  if env.trace then log("addQuarantine() "..tostring(region)..", "..tostring(guid)) end
  local function debug(str) if true then log("addQuarantine(): "..str) end end --DEBUG: set false to disable in this function
  --check validity of target region
  local rd = G.obj.regions[region]
  if rd.king or rd.quarantine or rd.protected then debug("failed, target region is taboo"); return false end
  --find out if being moved from source region
  local source,placed = nil,G.d.MSB[guid].placed
  for g,r in pairs(G.obj.regions) do
    if rd.quarantine == guid or rd.score_board == guid then source = g; break end
  end
  --flip the board if not already flipped
  local sb = getObjectFromGUID(guid)
  if not(sb.is_face_down) then sb.flip() end
  -- update regions quarantine status
  rd.quarantine = guid
  object_UI_setAttribute(region,"quarantined","active",true)
  object_UI_setAttribute(region,"label_text","text","Quarantined")
  object_UI_setAttribute(region,"label_text","color","Red")
  object_UI_setAttribute(region,"label","active",true)
  if source and not(placed) then
    G.obj.regions[source].quarantine = nil
    object_UI_setAttribute(source,"quarantined","active",false)
    object_UI_setAttribute(source,"label","active",false)
  elseif source then
    if G.d.scoring_mask then object_UI_setAttribute(source, "scoreboard_image", "image", G.d.scoring_mask)
    else object_UI_setAttribute(source, "scoreboard", "active", false) end
    G.obj.regions[source].scoring = simpleDeepCopy(C.regions_template[source].scoring)
  end
  -- move quarantine board to region score board position, shifted if already a score board there
  local pos = Vector(C.score_board_positions[indexOf(C.region_guids,region)])
  if rd.score_board then pos.z = pos.z + 2 end
  sb.setPosition(pos)
  Wait.condition(function()
    for g,_ in pairs(G.d.MSB) do getObjectFromGUID(g).setLock(true) end
  end, function() return sb.resting end, 5)
  -- create an undo entry & update object data
  G.d.action.undo.special[guid]={id="quarantine",g=guid,region=region,origin=source,placed=placed,snap=G.obj.snaps[guid]}
  G.obj.snaps[guid] = pos
  G.d.MSB[guid].placed = false
  G.d.MSB[guid].quarantine = true
  -- enable player buttons
  local pdata = G.d.players[G.d.action.player]
  G.d.action.disallow_finished = false
  updatePlayerBoardUI(G.d.action.player)
  return true
end
--[[ Player clicked "Done" button.
    NOTE: Done is overloaded.  May be clicked by current player to end current turn, or
    may be clicked by any player while 'waiting' on various player decisions (disk, cube moves, etc.)
    This results in quite a bit of conditional logic here.
]]
function playerDone(pcol)
  if env.trace then log("playerDone() "..tostring(pcol)) end
  local function debug(msg) if true then log("playerDone(): "..msg) end end --DEBUG set false to disable
  local pdata = G.d.players[pcol]
  if not(pdata.active) then debug("ignoring inactive player"); return end
  if G.d.phase == "IK_card_selection" then
    if #pdata.power_cards ~= 13 then return end
    Player[pcol].showConfirmDialog("This will end card selection with no undo",
      function(pcol)
        if #pdata.power_cards ~= 13 then
          broadcastToColor("You must have 13 cards in your hand",pcol)
          pdata.done_button = false
          updatePlayerBoardUI(pcol)
          return
        end
        getObjectFromGUID(C.IK.decks[pcol]).destruct()
        sortHand(pcol)
        if indexOf(G.d.waitlist,pcol) > 0 then
          table.remove(G.d.waitlist,indexOf(G.d.waitlist,pcol))
          object_UI_setAttribute(C.player_boards[pcol],"undo_row","active",true)
          object_UI_setAttribute(C.player_boards[pcol],"card_select_row","active",false)
          pdata.done_button = false
          pdata.active = false
          pdata.done = true
          updatePlayerBoardUI(pcol)
          if #G.d.waitlist == 0 then
            G.d.status.show = false
            startPlacementPhase()
          else
            for i,e in ipairs(G.d.status.waitlist) do
              if e.player_color == pcol then e.player_status = "Done"; break end
            end
            updateStatusUI(G.d.status)
          end
        end
      end)
  elseif G.d.phase == "placement" then
    if indexOf(G.d.waitlist,pcol) > 0 then
      table.remove(G.d.waitlist,indexOf(G.d.waitlist,pcol))
      for i,e in ipairs(G.d.status.waitlist) do
        if e.player_color == pcol then e.player_status = "Set"; break end
      end
      pdata.disk_button = false
      pdata.undo_button = true
      pdata.done_button = false
      pdata.active = false
      pdata.done = true
      updatePlayerBoardUI(pcol)
      if #G.d.waitlist == 0 then
        G.d.status.show = false
        placeStartingCubes()
        if G.env.intrigue_king_exp then
          startIKExtraPlacement()
        else
          startBidPhase()
        end
      else
        updateStatusUI(G.d.status)
      end
    end
  elseif G.d.phase == "IK_extra_placement" then
    if indexOf(G.d.waitlist,pcol) > 0 then
      table.remove(G.d.waitlist,indexOf(G.d.waitlist,pcol))
      for i,e in ipairs(G.d.status.waitlist) do
        if e.player_color == pcol then e.player_status = "Set"; break end
      end
      pdata.disk_button = false
      pdata.undo_button = true
      pdata.done_button = false
      pdata.active = false
      pdata.done = true
      updatePlayerBoardUI(pcol)
      if #G.d.waitlist == 0 then
        G.d.status.show = false
        for _,p in ipairs(G.d.player_order) do
          local pd = G.d.players[p]
          local rg = C.region_guids[pd.selected_region]
          local rd = G.obj.regions[rg]
          if not(rd.king) then
            local pos = Vector(C.region_start_info[rg].grande[p])
            local offset_pos = simpleDeepCopy(pos)
            offset_pos.z = offset_pos.z - 2
            local o = getObjectFromGUID(pd.provinces[#pd.provinces])
            o.setLock(false)
            if rd.grandes[p] then
              o.setPosition(offset_pos)
              G.obj.snaps[o.getGUID()] = offset_pos
            else
              o.setPosition(pos)
              G.obj.snaps[o.getGUID()] = pos
            end
            addCaballero(p, rg, p, o.getGUID())
            table.remove(pd.provinces, #pd.provinces)
          else
            debug("Player "..p.." chose King region, skipping extra Caballero")
          end
        end
        updateBoardUI()
        startBidPhase()
      else
        updateStatusUI(G.d.status)
      end
    end
  elseif G.d.phase == "bidding" then
    pdata.undo_button = false
    pdata.done_button = false
    pdata.active = false
    pdata.done = true
    updatePlayerBoardUI(pcol)
    if #G.d.players_to_bid == 0 then
      startActionPhase()
    elseif pdata.power_bid == 0 then --special case, Joker played
      debug("handle the Joker, reorder player order and continue bidding phase")
      local i = indexOf(G.d.player_order, pcol)
      if i > 0 then
        G.d.players[pcol].active = false
        G.d.players[pcol].done = false
        updatePlayerBoardUI(G.d.active_player)
        table.remove(G.d.player_order,i)
        table.insert(G.d.player_order,pcol) --move to last
        --update display
        local list = G.d.status.waitlist
        for n=1,#list do
          if list[n].player_color == pcol then
            table.remove(list,n)
            table.insert(list,{player_color=pcol,player_status=""}) --move to last
            break
          end
        end
        --set up new current bidder as active player
        G.d.status.waitlist[i].player_status = "Active"
        updateStatusUI(G.d.status)
        G.d.active_player = G.d.player_order[i]
        G.d.players[G.d.active_player].active = true
        updatePlayerBoardUI(G.d.active_player)
      else
        debug("ERROR: player "..tostring(pcol).." not in G.d.player_order"); return
      end
    else
      for i,e in ipairs(G.d.status.waitlist) do
        if e.player_color == pcol then e.player_status = "Set"; break end
      end
      local n = indexOf(G.d.player_order, pcol) + 1
      if n > #G.d.player_order then n = 1 end
      G.d.status.waitlist[n].player_status = "Active"
      updateStatusUI(G.d.status)
      G.d.active_player = G.d.player_order[n]
      G.d.players[G.d.active_player].active = true
      updatePlayerBoardUI(G.d.active_player)
      if G.d.players[G.d.active_player].power_card and G.d.players[G.d.active_player].power_bid == 0 then
        --this player had played a Joker, move it to the trash
        local o = getObjectFromGUID(G.d.players[G.d.active_player].power_card)
        getObjectFromGUID(C.trash).putObject(o)
        G.d.players[G.d.active_player].power_card = nil
      end
      if not(G.env.intrigue_king_exp) then
        for g,d in pairs(G.obj.bid_buttons) do
          if not(d.selected) and indexOf(d.players,G.d.active_player) > 0 then d.visibility = {G.d.active_player}
          else d.visibility = {} end
          updateOrderButtonUI(g,d)
        end
      end
    end
  elseif G.d.phase == "actions" then
    local a = G.d.action
    if a.stage == "waiting" then --TODO: refactor to check on pcol ~= a.player as I did in playerUndo()?  cleaner?
      local index = indexOf(a.waitlist, pcol)
      if index > 0 then
        debug(pcol.." is in action waitlist, action is waiting")
        local e = a.status.waitlist[index]
        if a.special.disk then
          e.player_status = "Set"; debug("action is waiting on disk selections") --DEBUG
        elseif a.special.placing then
          e.player_status = "Done"; debug("action is waiting on cube placement") --DEBUG
        elseif a.special.selecting_regions then
          if not(a.special.regions_selected) then
            e.player_status = "Selecting"; debug("action is waiting on region selections") --DEBUG
            a.special.regions_selected = true
            a.status.info = a.name.."\nActive player select an opponent\nClick on a player board"
          elseif not(a.special.opponent_selected) then
            e.player_status = "Done"; debug("action is waiting on opponent selection") --DEBUG
            a.special.opponent_selected = true
            a.status.info = a.name.."\nOpponent select from region candidates"
          elseif not(a.special.scoring_region_selected) then
            e.player_status = "Done"; debug("action is waiting on final region selection") --DEBUG
            a.special.final_region_selected = true
          else
            log("ERROR: playerDone() invalid state for a.special.selecting_regions") --DEBUG
          end
        else
          e.player_status = "Done"; debug("action is waiting on sequential player decisions") --DEBUG
          pdata.undo_button = false
          --advance to next player in waitlist
          if a.waitlist[index+1] then
            if a.special.placing then a.status.waitlist[index+1].player_status = "Placing"
            else a.status.waitlist[index+1].player_status = "Deciding" end
            local next = a.waitlist[index+1]
            G.d.players[next].active = true
            updatePlayerBoardUI(next)
          end
        end
        updateStatusUI(a.status)
        a.waiting = a.waiting - 1
        pdata.disk_button = false
        if a.special.disk then
          pdata.undo_button = a.waiting > 0
        else
          pdata.undo_button = false
          pendingCubes("clear_player",pcol)
          cleanupCourt(pcol)
          setLockCourt(pcol, true)
        end
        if a.waiting > 0 then
          pdata.done_button = false
          pdata.active = false
          pdata.done = true
          pdata.waiting = false
          pdata.show_stage = false
          updatePlayerBoardUI(pcol)
        else
          debug("waiting on players completed")
          ----////////// Handle special actions after waiting completed ////////////////
          if a.special.id == "ret2provinces" then
            debug("action:ret2provinces, finished wait on opponents")
            for _,c in ipairs(a.waitlist) do
              if c ~= a.player then
                local p = G.d.players[c]
                p.show_disk = false
                p.disk_button = false
                p.undo_button = false
                p.done_button = false
                p.active = false
                p.waiting = false
                updatePlayerBoardUI(c)
                --return a.special.count cubes (or as many as they have up  to that)
                --from the region.  If no special.count then it's all in the region
                local r = G.obj.regions[C.region_guids[p.selected_region]]
                local n = 0
                for g,_ in pairs(r.caballeros[c]) do
                  returnToProvinces(c,g,false)
                  r.caballeros[c][g] = nil; n = n + 1
                  if a.special.count and n >= a.special.count then break end
                end
              end
            end
            a.special_completed = true
            a.stage = "main"
            a.status.info = "Provinces:\nActive Player\nSelect an action"
            a.status.waitlist = {}
            updateStatusUI(a.status)
            G.d.players[G.d.active_player].disable_reset = true
            G.d.players[G.d.active_player].allow_undo = false
            G.d.players[G.d.active_player].undo_button = false
            G.d.players[G.d.active_player].done_button = true
            G.d.players[G.d.active_player].action_ui = true
            updatePlayerBoardUI(G.d.active_player)
            updateBoardUI()
          elseif a.special.id == "king_returns" then
            debug("action:king_returns, finished wait on opponents")
            pdata.done_button = false
            pdata.active = false
            pdata.done = true
            pdata.waiting = false
            pdata.show_stage = false
            updatePlayerBoardUI(pcol)
            G.d.players[G.d.active_player].done_button = true
            a.stage_status = "Opp all done"
            a.stage = "special"
            updatePlayerBoardUI(G.d.active_player)
          elseif a.special.id == "special_scoring" and a.special.secret then
            debug("special_scoring, secret, finished wait on opponents to make secret selections")
            local list = simpleDeepCopy(a.waitlist) --TODO: why copy?
            local unique = a.special.unique or false
            local dupes = a.special.dupes or false
            local undo_ok = false
            if a.special.players == "active" then undo_ok = true --no other player revealed a secret
            else debug("special_scoring, secret, clearing undo"); a.undo = {main={},court={},special={},reset=false} end
            for c,pd in pairs(G.d.players) do
              pd.show_disk = false
              pd.disk_button = false
              pd.action_ui = false
              if c ~= G.d.active_player then pd.active = false; pd.allow_undo = false end
              pd.done = false
              pd.undo_button = false
              pd.done_button = false
              updatePlayerBoardUI(c)
            end
            local regions, rejected, seen = {},{},{}
            for _,p in ipairs(list) do
              local r = G.d.players[p].selected_region
              if unique then
                if indexOf(rejected,r) > 0 then --ignoring this entry
                elseif indexOf(regions,r) > 0 then table.insert(rejected,r); table.remove(regions,indexOf(regions,r))
                else table.insert(regions,r) end
              elseif dupes then
                if indexOf(seen,r) > 0 then --more than on player selected, allow it
                  if indexOf(regions,r) == 0 then
                    table.insert(regions,r)
                    if indexOf(rejected,r) > 0 then table.remove(rejected,indexOf(rejected,r)) end
                  end
                else table.insert(seen,r);table.insert(rejected,r) end
              else table.insert(regions,r) end --no constraints, allow all selected
            end
            if unique then debug("special_scoring, secret, Players selected unique regions: ");log(regions)                --DEBUG
            elseif dupes then debug("special_scoring, secret, Players selected dupe regions: ");log(regions)               --DEBUG
            else debug("special_scoring, secret, Players selected regions: ");log(regions) end                             --DEBUG
            if #rejected > 0 then debug("special_scoring, secret, rejected regions: ");log(rejected) end  --DEBUG
            if #regions > 0 then
              local msg = "Selected: ["
              for _,r in ipairs(regions) do msg = msg..tostring(r).."," end
              msg = msg.."]"
              if #rejected > 0 then
                msg=msg.."\nRejected: ["
                for _,r in ipairs(rejected) do msg = msg..tostring(r).."," end
                msg = msg.."]"
              end
              G.d.players[G.d.active_player].allow_undo = undo_ok
              a.allow_veto = false --TODO: should veto be allowed when secret region(s) is(are) revealed?  Check inside startScoring()?
              a.stage_status = "Special Scoring"
              debug("special_scoring, secret, starting scoring")
              startScoring(regions,true,msg)
            else
              debug("special_scoring, secret, No regions to score") --DEBUG
              local p = a.player
              local pd = G.d.players[p]
              a.stage_status = "Nothing to score"
              a.stage = "special"
              pd.active = true
              pd.action_ui = true
              pd.allow_undo = false
              pd.undo_button = false
              pd.disable_reset = true
              updatePlayerBoardUI(p)
            end
          elseif a.special.id == "special_scoring" and a.special.selected then --special case for score one of 3 selected regions
            if a.special.final_region_selected then
              --launch the scoring
              a.allow_veto = false
              for g,_ in pairs(G.obj.regions) do local o = getObjectFromGUID(g); o.clearButtons(); o.highlightOff() end
              for c,pd in pairs(G.d.players) do
                pd.action_ui = false
                if c ~= a.player then pd.active = false
                else pd.disable_reset = true end
                pd.allow_undo = false
                pd.done = false
                pd.undo_button = false
                pd.done_button = false
                updatePlayerBoardUI(c)
              end
              a.status.show = false
              a.stage_status = "Special Scoring"
              updateStatusUI(a.status)
              debug("special_scoring, 0selected, starting scoring")
              local r = G.obj.regions[a.special.final_region].scoring_order
              startScoring({r},true,"Selected: ["..tostring(r).."]")
            elseif a.special.opponent_selected then
              --setup the opponent to select final region
              for p,_ in pairs(G.d.players) do getObjectFromGUID(C.player_boards[p]).clearButtons() end
              getObjectFromGUID(C.player_boards[a.special.selected_opponent]).highlightOff()
              pdata.done_button = false
              pdata.waiting = false
              pdata.active = true
              updatePlayerBoardUI(pcol)
              a.waitlist = {a.special.selected_opponent}
              a.waiting = 1
              a.status.waitlist = {}
              table.insert(a.status.waitlist,{player_color=a.special.selected_opponent,player_status="Deciding"})
              a.status.info = a.name.."\nOpponent select from region candidates"
              updateStatusUI(a.status)
              local pd = G.d.players[a.special.selected_opponent]
              pd.active = true
              pd.waiting = true
              pd.show_disk = false
              pd.disk_button = false
              pd.undo_button = false
              pd.done_button = false
              pd.action_ui = false
              updatePlayerBoardUI(a.special.selected_opponent)
              for _,g in ipairs(a.special.region_candidates) do getObjectFromGUID(g).createButton(C.region_button) end
            elseif a.special.regions_selected then
              --setup player opponent selection
              for g,_ in pairs(G.obj.regions) do getObjectFromGUID(g).clearButtons() end
              for p,_ in pairs(G.d.players) do
                if p ~= a.player then
                  local board = getObjectFromGUID(C.player_boards[p])
                  board.createButton(C.playerBoard_button)
                end
              end
              pdata.done = false
              pdata.done_button = false
              updatePlayerBoardUI(pcol)
            else
              log("ERROR: playerDone() invalid state for score region selected by opponent from selected region candidates"); return  --DEBUG
            end
          elseif a.special.id == "special_scoring" and a.special.no_maj then --special case for score where 2 but not the majority
            debug("no_maj: start special scoring")
            pdata.show_disk = false
            pdata.disk_button = false
            pdata.action_ui = false
            pdata.done = false
            pdata.undo_button = false
            pdata.done_button = false
            pdata.allow_undo = true
            updatePlayerBoardUI(pcol)
            local regions = {pdata.selected_region}
            a.allow_veto = false --TODO: should veto be allowed when secret region(s) is(are) revealed?  Check inside startScoring()?
            a.stage_status = "Special Scoring"
            startScoring(regions,true,"Selected: ["..tostring(pdata.selected_region).."]")
          elseif a.special.id == "evict" then
            if a.special.evict_stage == 1 then
              debug("action:evict, finished wait on active player to select evict region")
              pdata.allow_undo = false
              pdata.disable_reset = true
              pdata.waiting = false
              pdata.show_disk = false
              pdata.disk_button = false
              pdata.undo_button = false
              pdata.done_button = false
              pdata.action_ui = true
              updatePlayerBoardUI(pcol)
              local evict_region = pdata.selected_region
              a.special.evict_region = evict_region
              getObjectFromGUID(C.region_guids[evict_region]).highlightOn(Color["Yellow"])
              a.undo.special[evict_region] = {id="highlight",g=C.region_guids[evict_region],state="off"}
              local evicted = G.obj.regions[C.region_guids[evict_region]]
              a.status.info = "Evict: "..G.obj.regions[C.region_guids[evict_region]].name
              a.status.info = a.status.info.."\nOpp select destination\nKing region -> Court"
              a.status.waitlist = {}
              a.waitlist = {}
              local allowed = {}
              for i=1,9 do if i ~= evict_region then table.insert(allowed,i) end end
              for _,c in ipairs(a.opponents) do
                if sizeOf(evicted.caballeros[c]) > 0 then
                  table.insert(a.waitlist,c)
                  table.insert(a.status.waitlist,{player_color=c,player_status="Deciding"})
                  local pd = G.d.players[c]
                  pd.active = true
                  pd.waiting = true
                  pd.show_disk = true
                  pd.disk_button = true
                  pd.show_stage = false
                  pd.allowed_regions = allowed
                  pd.undo_button = false
                  pd.done_button = true
                  pd.action_ui = false
                  pd.selected_region = allowed[math.random(#allowed)]
                  updatePlayerBoardUI(c)
                end
              end
              if #a.waitlist == 0 then
                --TODO: handle case the active player selected an empty region!
                local pdata = G.d.players[G.d.active_player]
                pdata.active = true
                pdata.disable_reset = false
                pdata.done_button = true
                pdata.undo_button = true
                pdata.allow_undo = true
                a.special_completed = false
                a.stage_status = "No opp in region"
                a.stage = "special"
                updatePlayerBoardUI(G.d.active_player)
                updateStatusUI(G.d.status)
              else
                a.special.disk = true --allow player undo during disk selection wait
                a.status.show = true
                updateStatusUI(a.status)
                a.waiting = #a.waitlist
                a.special.evict_stage = 2
              end
            elseif a.special.evict_stage == 2 then
              debug("action:evict, finished wait on opponents to select evict destinations")
              local evict_region = a.special.evict_region
              getObjectFromGUID(C.region_guids[evict_region]).highlightOff()
              local evicted = G.obj.regions[C.region_guids[evict_region]]
              for _,c in ipairs(a.waitlist) do
                local pd = G.d.players[c]
                local r = G.obj.regions[C.region_guids[pd.selected_region]]
                if r.king or r.quarantine or r.protected then
                  --immediately return this player's cubes to court & remove from waitlist
                  for g,_ in pairs(evicted.caballeros[c]) do returnToCourt(c,g) end
                  evicted.caballeros[c] = {}
                  table.remove(a.waitlist,indexOf(a.waitlist,c))
                  pd.active = false
                  pd.waiting = false
                  pd.show_disk = false
                  pd.show_stage = false
                  pd.disk_button = false
                  pd.undo_button = false
                  pd.done_button = false
                  pd.action_ui = false
                  updatePlayerBoardUI(c)
                end
              end
              --for remaining waitlist, setup staging
              a.status.info = "Evict: "..G.obj.regions[C.region_guids[evict_region]].name
              a.status.info = a.status.info.."\nOpp move Caballeros\nto selected region"
              a.status.waitlist = {}
              for _,c in pairs(a.waitlist) do
                local pd = G.d.players[c]
                table.insert(a.status.waitlist, {player_color=c,player_status="Placing"})
                pd.active = true
                pd.waiting = true
                pd.show_disk = false
                pd.show_stage = true
                pd.disk_button = false
                pd.undo_button = false
                pd.done_button = false
                pd.action_ui = false
                updatePlayerBoardUI(c)
                local index = 1
                local board = getObjectFromGUID(C.player_boards[c])
                pd.staged_cubes = {}
                pd.cubes_to_place = {}
                for g,_ in pairs(evicted.caballeros[c]) do
                  local pos = board.positionToWorld(C.stage_pos_l[index])
                  getObjectFromGUID(g).setPosition(pos)
                  index = index + 1
                  G.obj.snaps[g] = pos
                  pendingCubes("add",g)
                  table.insert(pd.staged_cubes,g)
                  table.insert(pd.cubes_to_place,g)
                end
              end
              a.special.disk = false
              a.special.placing = true
              updateStatusUI(a.status)
              a.waiting = #a.waitlist
              a.special.evict_stage = 3
            elseif a.special.evict_stage == 3 then
              debug("action:evict, finished wait on opponents to place cubes")
              for _,c in pairs(a.waitlist) do
                local pd = G.d.players[c]
                pd.active = false
                pd.waiting = false
                pd.show_disk = false
                pd.show_stage = false
                pd.disk_button = false
                pd.undo_button = false
                pd.done_button = false
                pd.action_ui = false
                updatePlayerBoardUI(c)
              end
              local pdata = G.d.players[G.d.active_player]
              pdata.active = true
              pdata.done_button = true
              pdata.undo_button = false
              a.special_completed = true
              a.stage = "main"
              updatePlayerBoardUI(G.d.active_player)
              updateStatusUI(G.d.status)
            else
              debug("ERROR: action:evict, unhandled special.evict_stage")
            end
          elseif a.special.id == "region_score_double" then
            log("Player selected region, set region double scoring")
            local region = C.region_guids[pdata.selected_region]
            local r = G.obj.regions[region]
            getObjectFromGUID(region).highlightOn(Color["Yellow"], 1.5)
            a.undo.special["region_score_double_"..region] = {id="region_score_double",r=region,}
            a.stage_status = "Region selected"
            a.stage = "special"
            pdata.undo_button = false
            pdata.done_button = false
            pdata.show_disk = false
            pdata.disk_button = false
            pdata.action_ui = true
            a.disallow_finished = false
            updatePlayerBoardUI(pcol)
            r.double_scoring = true
            updateBoardUI()
          elseif a.special.id == "take6" then
            log("Player selected region, set take6 limit on the region")
            local region = C.region_guids[pdata.selected_region]
            local r = G.obj.regions[region]
            getObjectFromGUID(region).highlightOn(Color["Yellow"], 1.5)
            a.undo.special["take6_"..region] = {id="take6", pcol=pcol, g=pdata.power_card, r=region,}
            a.stage_status = "Region selected"
            a.stage = "special"
            pdata.undo_button = false
            pdata.done_button = false
            pdata.show_disk = false
            pdata.disk_button = false
            pdata.action_ui = true
            a.disallow_finished = false
            updatePlayerBoardUI(pcol)
            r.caballero_limit = a.special.count
            updateBoardUI()
            --update the saved player.held_cards data for the selected region, supports card #125; remove face up
            pdata.held_cards[pdata.power_card].region = region
            object_UI_setAttribute(region,"limit_text","text",tostring(r.caballero_limit))
            object_UI_setAttribute(region,"limit","active",true)
          elseif a.special.id == "royal_protection" then
            log("Player selected region, set royal protection on the region")
            local region = C.region_guids[pdata.selected_region]
            local r = G.obj.regions[region]
            getObjectFromGUID(region).highlightOn(Color["Yellow"], 1.5)
            a.undo.special["royal_protection_"..region] = {id="royal_protection", pcol=pcol, r=region,}
            a.stage_status = "Region selected"
            a.stage = "special"
            pdata.undo_button = false
            pdata.done_button = false
            pdata.show_disk = false
            pdata.disk_button = false
            pdata.action_ui = true
            a.disallow_finished = false
            updatePlayerBoardUI(pcol)
            updateBoardUI()
            r.protected = true
            object_UI_setAttribute(region,"protected","active",true)
          elseif a.special.id == "relocate" then
            debug("--- TODO: player done action for relocate")

          else
            debug("ERROR: no matching special.id to execute after waiting completed")
          end
        end
      else
        log("ERROR: playerDone() player "..pcol.." not in action.waitlist") --DEBUG
      end
    else
      debug("action stage is not waiting")
      if G.env.intrigue_king_exp then
        if (a.IK.king and not(a.IK.king.completed)) or (a.IK.intrigue and not(a.IK.intrigue.completed)) or not(a.IK.special.completed) then
          --incomplete action, warn user with chance to cancel
          G.d.confirm_actions = {}
          G.d.confirm_actions.ok={fn="playerDone",params=pcol,pre={"end_actions"},}
          G.d.confirm_actions.cancel={}
          G.d.confirm_lock = true
          UI_setAttribute("confirm_msg_txt","text","Skip unused actions?")
          UI_setAttribute("confirm_cancel_ok_row","active",true)
          UI_setAttribute("confirm_ack_row","active",false)
          UI_setAttribute("confirm_pnl","visibility",pcol)
          return
        end
        pdata.undo_button = false
        pdata.done_button = false
        pdata.action_ui = false
        pdata.active = false
        pdata.done = true
        updatePlayerBoardUI(pcol)
        for i,e in ipairs(G.d.status.waitlist) do
          if e.player_color == pcol then e.player_status = "Done"; break end
        end
        --cleanup some stuff from the action
        card = getObjectFromGUID(pdata.power_card)
        local veto = false
        if card then
          card.setLock(false)
          if not(power_cards[pdata.power_bid].special.hold_card) then
            getObjectFromGUID(C.trash).putObject(card)
            table.remove(pdata.power_cards,indexOf(pdata.power_cards,card.getGUID()))
          end
        else
          debug("WARN: playerDone(): failed to get active player's power card object; "..tostring(pdata.power_card)) --DEBUG
        end
        cleanupCourt(pcol)
        resetAction()
        table.remove(G.d.players_to_play,indexOf(G.d.players_to_play,pcol))
        --advance to next player or go to bidding phase if all are done
        if #G.d.players_to_play == 0 then
          local temp = {}
          for i=#G.d.player_order,1,-1 do table.insert(temp,G.d.player_order[i]) end
          G.d.player_order = temp
          if G.d.round == 3 or G.d.round == 6 or G.d.round == 9 then startScoring()
          else startBidPhase() end
        else
          for c,pd in pairs(G.d.players) do
            pd.done = not(contains(G.d.players_to_play,c))
            updatePlayerBoardUI(c)
          end
          local n = indexOf(G.d.player_order, pcol) + 1
          if n > #G.d.player_order then n = 1 end
          G.d.active_player = G.d.player_order[n]
          startPlayerActions(G.d.active_player)
          G.d.status.waitlist[n].player_status = "Active"
          updateStatusUI(G.d.status)
        end
      else
        if not(a.court_completed) or not(a.special_completed) then
          --incomplete action, warn user with chance to cancel
          G.d.confirm_actions = {}
          G.d.confirm_actions.ok={fn="playerDone",params=pcol,pre={"end_actions"},}
          G.d.confirm_actions.cancel={}
          G.d.confirm_lock = true
          UI_setAttribute("confirm_msg_txt","text","Skip unused actions?")
          UI_setAttribute("confirm_cancel_ok_row","active",true)
          UI_setAttribute("confirm_ack_row","active",false)
          UI_setAttribute("confirm_pnl","visibility",pcol)
          return
        end
        pdata.undo_button = false
        pdata.done_button = false
        pdata.action_ui = false
        pdata.active = false
        pdata.done = true
        updatePlayerBoardUI(pcol)
        for i,e in ipairs(G.d.status.waitlist) do
          if e.player_color == pcol then e.player_status = "Done"; break end
        end
        --cleanup some stuff from the action
        card = getObjectFromGUID(pdata.action_card)
        if not(card) then debug("WARN: failed to get active player's action card object; "..tostring(pdata.action_card)) end
        local veto = false
        if card then
          card.setLock(false)
          if card.getGUID() == C.stacks[5] then
            card.flip()
            card.setPositionSmooth(C.king_card_position,false,false)
            Wait.condition(function() card.setLock(true) end, function() return card.resting end, 5)
          elseif cards[card.getGUID()].special.id ~= "veto" then
            getObjectFromGUID(C.trash).putObject(card)
          end
        end
        if indexOf(G.d.action_cards, pdata.action_card) > 0 then
          if cards[card.getGUID()].special.id ~= "veto" then table.remove(G.d.action_cards, indexOf(G.d.action_cards, pdata.action_card)) end
        else debug("WARN: player's action card guid not in action_cards table; "..tostring(pdata.action_card)) end
        pdata.action_card = ""
        cleanupCourt(pcol)
        resetAction()
        table.remove(G.d.players_to_play,indexOf(G.d.players_to_play,pcol))
        --advance to next player or go to bidding phase if all are done
        if #G.d.players_to_play == 0 then
          local temp = {}
          for i=#G.d.player_order,1,-1 do table.insert(temp,G.d.player_order[i]) end
          G.d.player_order = temp
          if G.d.round == 3 or G.d.round == 6 or G.d.round == 9 then startScoring()
          else startBidPhase() end
        else
          for c,pd in pairs(G.d.players) do
            pd.done = not(contains(G.d.players_to_play,c))
            updatePlayerBoardUI(c)
          end
          local n = indexOf(G.d.player_order, pcol) + 1
          if n > #G.d.player_order then n = 1 end
          G.d.active_player = G.d.player_order[n]
          G.d.players[G.d.active_player].active = true
          G.d.players[G.d.active_player].waiting = false
          updatePlayerBoardUI(G.d.active_player)
          G.d.status.waitlist[n].player_status = "Active"
          updateStatusUI(G.d.status)
        end
      end
    end
  elseif G.d.phase == "scoring" then
    local player_status = ""
    if G.d.scoring.phase == "reserves_selection" then --player is selecting region to place rexerves
      player_status = "Set"
    elseif G.d.scoring.phase == "reserves_deployment" then --player is placing reserve cubes
      if pdata.staged_cubes and #pdata.cubes_to_place > 0 then  --TODO: why? isn't done button hidden?
        debug("player not finished placing staged cubes")
        return
      end
      pendingCubes("clear_player",pcol)
      pdata.staged_cubes = nil
      pdata.cubes_to_place = nil
      pdata.reserves = nil
      local i = 1
      for g,c in pairs(pdata.held_cards) do
        if c.id == "reserves" then
          getObjectFromGUID(C.trash).putObject(getObjectFromGUID(g))
          pdata.held_cards[g] = nil
        else
          --reposition remaining cards
          local board = getObjectFromGUID(C.player_boards[pcol])
          local pos = board.positionToWorld(C.IK.card_pos_l[i])
          pos.y = pos.y + 2
          local o = getObjectFromGUID(g)
          o.setPosition(pos)
          Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
          i = i + 1
        end
      end
      player_status = "Done"
    elseif G.d.scoring.phase == "castillo_selection" then --players are selecting regions to place castillo cubes
      player_status = "Set"
    elseif G.d.scoring.phase == "castillo_deployment" then -- one or more players have cubes in castillo to place
      if pdata.staged_cubes and #pdata.cubes_to_place > 0 then  --TODO: why? isn't done button hidden?
        debug("player not finished placing staged cubes")
        return
      end
      pendingCubes("clear_player",pcol)
      pdata.staged_cubes = nil
      pdata.cubes_to_place = nil
      player_status = "Done"
    end
    for i,e in ipairs(G.d.scoring.status.waitlist) do
      if e.player_color == pcol then e.player_status = player_status; break end
    end
    pdata.disk_button = false
    pdata.undo_button = pdata.show_disk
    pdata.done_button = false
    pdata.show_stage = false
    pdata.active = false
    pdata.done = true
    pdata.waiting = false
    updatePlayerBoardUI(pcol)
    updateStatusUI(G.d.scoring.status)
    table.remove(G.d.scoring.waitlist,indexOf(G.d.scoring.waitlist,pcol))
  else
    debug("ERROR: playerDone() unkhown game state")
  end
end
--[[ Player clicked "Undo" button.
  NOTE: Undo is overloaded.  May be clicked by current player to rewind entire turn, or
  may be clicked by any player while 'waiting' on various player decisions (disk, cube moves, etc.)
  This results in quite a bit of conditional logic here.
]]
function playerUndo(pcol)
  if env.trace then log("playerUndo() "..tostring(pcol)) end
  local function debug(msg) if true then log("playerUndo(): "..msg) end end --DEBUG enable/disable entire function logging here
  local pdata = G.d.players[pcol]
  if G.d.phase == "placement" or G.d.phase == "IK_extra_placement" then
    if indexOf(G.d.waitlist,pcol) == 0 then table.insert(G.d.waitlist,pcol) end
    for i,e in ipairs(G.d.status.waitlist) do
      if e.player_color == pcol then e.player_status = "Deciding"; break end
    end
    updateStatusUI(G.d.status)
    pdata.disk_button = true
    pdata.undo_button = false
    pdata.done_button = true
    pdata.active = true
    pdata.waiting = true
    updatePlayerBoardUI(pcol)
  elseif G.d.phase == "bidding" then
    if indexOf(G.d.players_to_bid,pcol) == 0 then table.insert(G.d.players_to_bid,pcol) end
    for i,e in ipairs(G.d.status.waitlist) do
      if e.player_color == pcol then e.player_status = ""; break end --TODO: unnecessary???
    end
    pdata.undo_button = false
    pdata.done_button = false
    if G.env.intrigue_king_exp then
      local card = getObjectFromGUID(pdata.power_card)
      card.setLock(false)
      card.deal(1,pcol)
      pdata.power_card = nil
      pdata.power_bid = nil
    else
      --reset selected bid button data
      local guid = C.button_guids[pdata.bid_button]
      local button_data = G.obj.bid_buttons[guid]
      button_data.selected = false
      if indexOf(button_data.players,pcol) == 0 then table.insert(button_data.players,pcol) end
      if indexOf(button_data.used,pcol) > 0 then table.remove(button_data.used,indexOf(button_data.used,pcol)) end
      --re-enable visibility for active player on all unselected buttons this player hasn't used
      for g,d in pairs(G.obj.bid_buttons) do
        if not(d.selected) and indexOf(d.players,pcol) > 0 then d.visibility = {pcol}
        else d.visibility = {} end
        updateOrderButtonUI(g,d)
      end
      pdata.bid_button = nil
    end
    updatePlayerBoardUI(pcol)
  elseif G.d.phase == "actions" then
    local a = G.d.action
    local function rewind()
      debug("rewind entire turn for current player")
      for _,stage in ipairs(a.sequence) do
        if stage == "court" then
          for _,u in pairs(a.undo.court) do undo(u) end
          a.undo.court = {}
          a.court_completed = false
        elseif stage == "special" then
          for _,u in pairs(a.undo.special) do undo(u) end
          a.undo.special = {}
          a.special_completed = false
        elseif stage == "IK_king" then
          for g,u in pairs(a.undo.IK_king) do undo(u) end
          a.undo.IK_king = {}
          a.IK.king.completed = false
        elseif stage == "IK_intrigue" then
          for g,u in pairs(a.undo.IK_intrigue) do undo(u) end
          a.undo.IK_intrigue = {}
          a.IK.intrigue.completed = false
        else
          assert(false,"playerUndo(): unknown stage found in action sequence")
        end
      end
      a.sequence = {}
      for _,u in pairs(a.undo.main) do undo(u) end
      a.undo.main = {}
      if a.undo.reset and not(pdata.power_card) then
        resetAction()
        pdata.action_ui = false
      else
        a.stage = "main"
      end
    end
    if pcol ~= a.player then
      debug(pcol.." is not current player and a.stage is "..tostring(a.stage))
      if a.stage == "waiting" then
        if indexOf(a.waitlist,pcol) > 0 then
          for i,e in ipairs(a.status.waitlist) do
            if e.player_color == pcol then
              if a.special.placing then e.player_status = "Placing" else e.player_status = "Deciding" end; break
            end
          end
          updateStatusUI(a.status)
          if a.special.disk then
            a.waiting = a.waiting + 1
            pdata.disk_button = true
            pdata.done_button = true
          else
            pdata.done_button = false
            debug("undo special for just player "..pcol)
            for g,u in pairs(a.undo.special) do
              if u.player == pcol then undo(u); a.undo.special[g] = nil end
            end
            setLockCourt(pcol, false)
          end
          pdata.undo_button = false
          pdata.active = true
          pdata.waiting = true
          updatePlayerBoardUI(pcol)
        else
          debug("a.stage is 'waiting' but "..pcol.." is not in a.waitlist")
        end
      else
        debug(pcol.." is not current player but a.stage is not 'waiting'")
      end
    else
      debug(pcol.." is current player and a.stage is "..tostring(a.stage))
      if a.stage == "waiting" then
        --current player selected undo, rewind entire turn
        rewind()
        for p,pd in pairs(G.d.players) do --TODO: make this an undo entry? id=reset_opponents ???
          if p ~= pcol then
            pd.undo_button = false
            pd.done_button = false
            pd.disk_button = false
            pd.show_disk = false
            pd.show_stage = false
            pd.action_ui = false
            pd.active = false
            pd.done = false
            updatePlayerBoardUI(p)
          end
        end
        pdata.undo_button = false
        pdata.done_button = false
        pdata.disk_button = false
        pdata.show_disk = false
        pdata.show_stage = false
        updatePlayerBoardUI(pcol)
        updateBoardUI()
        updateCastilloUI()
      else
        rewind()
        if pdata.power_card then
          startPlayerActions(pcol)
        else
          pdata.undo_button = false
          pdata.done_button = false
          updatePlayerBoardUI(pcol)
        end
        updateBoardUI()
        updateCastilloUI()
        if G.obj.bid_buttons then
          for g,d in pairs(G.obj.bid_buttons) do
            if not(d.selected) and indexOf(d.players,pcol) > 0 then d.visibility = {pcol}
            else d.visibility = {} end
            updateOrderButtonUI(g,d)
          end
        end
        updateStatusUI(G.d.status)
      end
    end
  elseif G.d.phase == "scoring" then
    if indexOf(G.d.scoring.waitlist,pcol) == 0 then table.insert(G.d.scoring.waitlist,pcol) end
    for i,e in ipairs(G.d.scoring.status.waitlist) do
      if e.player_color == pcol then e.player_status = "Deciding"; break end
    end
    G.d.players[pcol].active = true
    G.d.players[pcol].waiting = true
    G.d.players[pcol].disk_button = true
    G.d.players[pcol].undo_button = false
    G.d.players[pcol].done_button = true
    updatePlayerBoardUI(pcol)
    updateStatusUI(G.d.scoring.status)
  else
    log("WARN: playerUndo() unkhown game state")
  end
end
--[[ Undo an action step.
]]
function undo(u)
  if env.trace then log("undo()") end
  local function debug(str) if true then log(str) end end --DEBUG: set false to disable verbose debug in this function
  if u.id == "select_card" then --WORKING
    debug("undo select card")
    local o = getObjectFromGUID(u.g)
    o.setLock(false)
    o.setPosition(u.snap)
    o.clearButtons()
    Wait.condition(function() o.setLock(true); o.createButton(C.card_button) end, function() return o.resting end, 5)
    G.d.players[u.pcol].action_card = ""
  elseif u.id == "move_king" then  --WORKING
    debug("undo move king")
    getObjectFromGUID(u.g).setPosition(u.snap)
    G.obj.snaps[u.g] = u.snap
    for g,r in pairs(G.obj.regions) do
      if g == u.origin then r.king = true else r.king = false end
    end
    updateBoardUI()
  elseif u.id == "set_grande" then            --TODO not using this??? handled by move_grande?
  elseif u.id == "court" then  --WORKING
    debug("undo court")
    local pdata = G.d.players[u.pcol]
    local index = indexOf(pdata.court, u.g)
    if index > 0 then table.remove(pdata.court, index) end
    returnToCourt(u.pcol, u.g)
    if contains(G.d.action.pending_cubes,u.g) then pendingCubes("remove",u.g) end
    for _,r in pairs(G.obj.regions) do
      if r.caballeros[u.pcol][u.g] then r.caballeros[u.pcol][u.g] = nil; break end
    end
  elseif u.id == "prov2court" then  --WORKING
    debug("undo prov2court")
    local pdata = G.d.players[u.pcol]
    local board = getObjectFromGUID(C.player_boards[u.pcol])
    local o = getObjectFromGUID(u.g)
    o.setLock(false)
    local pos = board.positionToWorld(C.prov_pos_l[#pdata.provinces+1])
    o.setPosition(pos)
    table.insert(pdata.provinces,o.getGUID())
    table.remove(pdata.court,indexOf(pdata.court,o.getGUID()))
    o.setLock(true)
    G.obj.snaps[o.getGUID()] = pos
  elseif u.id == "court2prov" then  --WORKING
    debug("undo court2prov")
    local pdata = G.d.players[u.pcol]
    local board = getObjectFromGUID(C.player_boards[u.pcol])
    local o = getObjectFromGUID(u.g)
    o.setLock(false)
    local pos = board.positionToWorld(C.court_pos_l[#pdata.court+1])
    o.setPosition(pos)
    table.insert(pdata.court,o.getGUID())
    table.remove(pdata.provinces,indexOf(pdata.provinces,o.getGUID()))
    o.setLock(true)
    G.obj.snaps[o.getGUID()] = pos
  elseif u.id == "move_caballero" then  --WORKING
    debug("undo move caballero")
    local o = getObjectFromGUID(u.g)
    o.setLock(false); o.setPosition(u.snap)
    G.obj.snaps[u.g] = u.snap
    if contains(G.d.action.pending_cubes,u.g) then pendingCubes("remove",u.g) end
    for _,r in pairs(G.obj.regions) do
      if r.caballeros[u.color][u.g] then r.caballeros[u.color][u.g] = nil; break end
    end
    G.obj.regions[u.origin].caballeros[u.color][u.g] = true
  elseif u.id == "ret2provinces" then --WORKING
    for _,c in ipairs(u.opp) do
      log("undo() ret2provinces: reset state for opponent "..c)
      local p = G.d.players[c]
      p.active = false
      p.waiting = false
      p.show_disk = false
      p.disk_button = false
      p.undo_button = false
      p.done_button = false
      p.action_ui = false
      p.allowed_regions = {1,2,3,4,5,6,7,8,9}
      p.selected_region = math.random(1,9)
      updatePlayerBoardUI(c)
    end
  elseif u.id == "move_grande" then --WORKING
    debug("undo move grande")
    if contains(G.d.action.pending_cubes,u.g) then pendingCubes("remove",u.g) end
    local o = getObjectFromGUID(u.g)
    o.setPosition(u.snap)
    o.setVelocity(Vector(0,0,0))
    for g,r in pairs(G.obj.regions) do r.grandes[o.memo] = (g == u.origin) end
    G.obj.snaps[u.g] = u.snap
  elseif u.id == "castillo" then --WORKING
    local castillo = getObjectFromGUID(C.castillo)
    if indexOf(G.obj.castillo.caballeros[u.color],u.g) > 0 then
      table.remove(G.obj.castillo.caballeros[u.color],indexOf(G.obj.castillo.caballeros[u.color],u.g))
    else
      debug("WARN: no castillo table entry for "..tostring(u.g))
    end
    local o = castillo.takeObject({
      guid=u.g,
      callback_function = function(o)
        if u.origin == "court" then
          returnToCourt(o.memo, u.g)
        elseif u.snap then
          o.setPosition(u.snap)
          G.obj.regions[u.origin].caballeros[u.color][u.g] = true
        end
      end
    })
  elseif u.id == "disk" then                  --TODO: not using this???
  elseif u.id == "scoreboard" then --WORKING
    local o = getObjectFromGUID(u.g)
    local rdata = G.obj.castillo
    if u.region ~= "castillo" then rdata = G.obj.regions[u.region] end
    o.setLock(false)
    o.setPosition(u.snap)
    Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
    if u.region == "castillo" then
      rdata.scoring = simpleDeepCopy(C.castillo_template.scoring)
    else
      rdata.scoring = simpleDeepCopy(C.regions_template[u.region].scoring)
      if G.d.scoring_mask then object_UI_setAttribute(u.region, "scoreboard_image", "image", G.d.scoring_mask)
      else object_UI_setAttribute(u.region, "scoreboard", "active", false) end
    end
    rdata.score_board = false
    G.obj.snaps[u.g]=u.snap
    --handle an origin if any
    if u.origin then
      if u.origin == "castillo" then
        G.obj.castillo.scoring = simpleDeepCopy(G.d.MSB[u.g].scoring)
        G.obj.castillo.score_board = u.g
      else
        local r = G.obj.regions[u.origin]
        r.score_board = u.g
        r.scoring = simpleDeepCopy(G.d.MSB[u.g].scoring)
        object_UI_setAttribute(u.origin, "scoreboard_image", "image", G.d.MSB[u.g].image)
        object_UI_setAttribute(u.origin, "scoreboard", "active", true)
      end
    else
      G.d.MSB[guid].placed = false
    end
    updateBoardUI()
  elseif u.id == "score" then --WORKING
    G.d.players[u.pcol].score = G.d.players[u.pcol].score - u.points
    if G.d.players[u.pcol].score < 0 then
      debug("WARN: undo score resulted in < 0, set to 0")
      G.d.players[u.pcol].score = 0
    end
    --locate scoring marker
    local m = getObjectFromGUID(C.score_markers[u.pcol])
    local pos = Vector(C.score_marker_start_pos[u.pcol])
    if G.d.players[u.pcol].score > 0 then pos = getScorePos(u.pcol,G.d.players[u.pcol].score) end
    pos.y = pos.y + 2
    m.setName(u.pcol.." "..tostring(G.d.players[u.pcol].score))
    local scale = Vector(0.6, 0.6, 0.6)
    if G.d.players[u.pcol].score > 150 then scale.y = 6; m.setDescription("+150")
    elseif G.d.players[u.pcol].score > 100 then scale.y = 4; m.setDescription("+100")
    elseif G.d.players[u.pcol].score > 50 then scale.y = 2; m.setDescription("+50") end
    m.setScale(scale)
    m.setLock(false)
    m.setPositionSmooth(pos, false, false)
    Wait.frames(function()
      Wait.condition(function() m.setLock(true) end, function() return m.resting end, 5)
    end,1)
  elseif u.id == "court_completed" then --WORKING
    G.d.action.court_completed = false
  elseif u.id == "special_completed" then --WORKING
    G.d.action.special_completed = false
  elseif u.id == "IK_king_completed" then
    G.d.action.IK.king.completed = false
  elseif u.id == "IK_intrigue_completed" then --WORKING
    G.d.action.IK.intrigue.completed = false
  elseif u.id == "IK_special_completed" then --WORKING
    G.d.action.IK.special.completed = false
  elseif u.id == "IK_special_action" then  --WORKING
    G.d.players[u.pcol].IK_special_action = u.state
  elseif u.id == "IK_king_action" then  --WORKING
    G.d.players[u.pcol].IK_king_action = u.state
  elseif u.id == "IK_intrigue_action" then --TODO: test
    G.d.players[u.pcol].IK_intrigue_action = u.state
  elseif u.id == "restore_bid" then --WORKING
    log("undo restore_bid")
    local button_data = G.obj.bid_buttons[u.g]
    table.insert(button_data.used, u.pcol)
    table.remove(button_data.players,indexOf(button_data.players,u.pcol))
    button_data.button_on = false
    button_data.visibility = {}
    updateOrderButtonUI(u.g,button_data)
  elseif u.id == "ret2prov" then --WORKING
    log("undo ret2prov") --from king returns action
    if u.origin == "court" then
      local o = getObjectFromGUID(u.g)
      o.setLock(false)
      returnToCourt(u.player,u.g)
      --HACK: returnToCourt will lock the cube so unlock it when it does TODO: add a flag to returnToCourt to skip locking
      Wait.condition(function() o.setLock(false) end, function() return o.getLock() end, 5)
    else
      local o = getObjectFromGUID(u.g)
      o.setLock(false)
      o.setPosition(u.snap)
      G.obj.regions[u.origin].caballeros[u.player][u.g] = true
      updateBoardUI()
    end
    table.remove(G.d.players[u.player].provinces, indexOf(G.d.players[u.player].provinces,u.g))
    pendingCubes("remove",u.g)
    G.d.action.caballeros_moved[u.player] = G.d.action.caballeros_moved[u.player] - 1
    if G.d.action.caballeros_moved[u.player] < 0 then
      log("WARN: undo() id=ret2prov, G.d.action.caballeros_moved[u.player] < 0") --DEBUG
      G.d.action.caballeros_moved[u.player] = 0
    end
  elseif u.id == "highlight" then --WORKING
    local o = getObjectFromGUID(u.g)
    if o then
      if u.state == "off" then o.highlightOff()
      else log("WARN: undo highlight: unhandled state "..tostring(u.state)) end
    else log("WARN: undo highlight: can't find object") end
  elseif u.id == "move_either_caballero" then --WORKING HACK: action modifies id? so reset it?  Find a better way.
    G.d.action.special.id = "move_either_caballero"
  elseif u.id == "special_scoring_selected" then --TODO: test
    for g,_ in pairs(G.obj.regions) do o = getObjectFromGUID(g); o.clearButtons(); o.highlightOff() end
    local a = G.d.action
    for p,pd in pairs(G.d.players) do
      o = getObjectFromGUID(C.player_boards[p]); o.clearButtons(); o.highlightOff()
      pd.waiting = false
      pd.active = p == a.player
      updatePlayerBoardUI(p)
    end
    a.special.region_candidates = nil
    a.special.final_region_selected = nil
    a.special.opponent_selected = nil
    a.special.regions_selected = nil
  elseif u.id == "quarantine" then  --WORKING
    log("--- TODO: undo quarantine")
    -- G.d.action.undo.special[guid]={id="quarantine",g=guid,region=region,origin=source,placed=placed,snap=G.obj.snaps[guid]}
    local sb = getObjectFromGUID(u.g)
    local r = G.obj.regions[u.region]
    r.quarantine = nil
    object_UI_setAttribute(u.region,"quarantined","active",false)
    object_UI_setAttribute(u.region,"label","active",false)
    sb.setLock(false)
    if u.source and u.placed then
      if sb.is_face_down then sb.flip() end
      G.obj.regions[u.origin].scoring = simpleDeepCopy(G.d.MSB[u.g].scoring)
      G.d.MSB[u.g].placed = true
      G.d.MSB[u.g].quarantine = false
    elseif u.source then
      if not(sb.is_face_down) then sb.flip() end
      G.obj.regions[u.origin].quarantine = true
      object_UI_setAttribute(u.origin,"quarantined","active",true)
      object_UI_setAttribute(u.origin,"label_text","text","Quarantined")
      object_UI_setAttribute(u.origin,"label_text","color","Red")
      object_UI_setAttribute(u.origin,"label","active",true)
      G.d.MSB[u.g].placed = false
      G.d.MSB[u.g].quarantine = true
    else
      if sb.is_face_down then sb.flip() end
      G.d.MSB[u.g].placed = false
      G.d.MSB[u.g].quarantine = false
    end
    sb.setPosition(u.snap)
    Wait.condition(function() sb.setLock(true) end, function() return sb.resting end, 5)
    G.obj.snaps[u.g] = u.snap
  elseif u.id == "take6" then  --WORKING
    log("undo take6 region limit")
    local pd = G.d.players[u.pcol]
    G.obj.regions[u.r].caballero_limit = nil --clear the limit from the region
    object_UI_setAttribute(u.r,"limit","active",false)  --clear the UI
    --put the card back on player board & back in player's card list
    local board = getObjectFromGUID(C.player_boards[u.pcol])
    local card = getObjectFromGUID(u.g)
    card.setPosition(board.positionToWorld(C.card_pos_l))
    Wait.condition(function() card.setLock(true) end, function() return card.resting end, 5)
    table.insert(pd.power_cards,u.g)
    pd.held_cards[u.g] = nil  --clear the held_cards table entry
  elseif u.id == "region_score_double" then --WORKING
    log("undo double region scoring")
    local rd = G.obj.regions[u.r]
    rd.double_scoring = nil
    updateBoardUI()
  elseif u.id == "remove_face_up" then --WORKING
    log("undo remove face up card action")
    if u.clear_buttons and u.cards then
      log("undo remove face up: clearing buttons")
      for _,g in pairs(u.cards) do local o = getObjectFromGUID(g); if o then o.clearButtons() end end
    elseif u.restore_card then
      log("undo remove face up: restoring card and results")
      --get the restored card from the trash and put it back in front of proper player
      local board = getObjectFromGUID(C.player_boards[u.p])
      local pos = board.positionToWorld(C.IK.card_pos_l[sizeOf(G.d.players[u.p].held_cards)+1])
      getObjectFromGUID(C.trash).takeObject({
        guid = u.g,
        position = pos,
        callback_function = function(c)
          Wait.frames(function()
            Wait.condition(function() c.setLock(true) end, function() return c.resting end, 5)
          end,10)
        end,
      })
      --restore results for the card being recovered.
      --NOTE: messy. Tightly coupled to action code for the specific card in order to restore results of that card's action
      --NOTE: messy. Also tightly coupled to cardClick, has to build the undo info specific to the card being removed
      local pd = G.d.players[u.p]
      if u.a == "take6" then
        pd.held_cards[u.g] = {g=u.g,id="take6",power=v,region=u.r}
        G.obj.regions[u.r].caballero_limit = power_cards[u.v].special.count
        object_UI_setAttribute(u.r,"limit_text","text",tostring(G.obj.regions[u.r].caballero_limit))
        object_UI_setAttribute(u.r,"limit","active",true)
      elseif u.a == "reserves" then
        -- a.undo.special["remove_face_up_"..tostring(Time.time)] = {id="remove_face_up",restore_card=true,g=card.getGUID(),p=p,a="reserves",v=card.value,cube=pd.reserves}
        log("--- TODO: undo remove face up for 'reserves' card")
        -- restore the target player's held_cards table entry
        pd.held_cards[u.g] = {g=u.g,id="reserves",power=v,cube=u.cube}
        -- Put the cube back on the card
        local o = getObjectFromGUID(u.cube)
        pos.y = pos.y + 1
        o.setLock(false)
        o.setPositionSmooth(pos,false,false)
        Wait.condition(function() o.setLock(true); G.obj.snaps[o.getGUID()] = o.getPosition() end, function() return o.resting end, 5)
        table.remove(pd.provinces, indexOf(pd.provinces, o.getGUID()))
        -- restore the target player's reserves setting
        pd.reserves = u.cube
      else
        log("ERROR: undo():remove_face_up: unhandled card action id")
      end
    end
  elseif u.id == "royal_protection" then --WORKING
    log("undo royal protection")
    local rd = G.obj.regions[u.r]
    rd.protected = nil
    object_UI_setAttribute(u.r,"protected","active",false)
  elseif u.id == "scoring_window" then
    log("undo: hide the special scoring window")
    UI_setAttribute("scoring_pnl","visibility","Pink")
  elseif u.id == "relocate" then --TODO: anything?
    log("undo relocate action")
    --TODO anything here?
  elseif u.id == "reserves" then --TODO
    log("undo reserves action")
    local card = getObjectFromGUID(u.card)
    local pd = G.d.players[u.pcol]
    --return cube to Provinces
    returnToProvinces(u.pcol, u.cube)
    --reset player reserves
    pd.reserves = nil
    --return card to board
    local board = getObjectFromGUID(C.player_boards[u.pcol])
    card.setPosition(board.positionToWorld(C.card_pos_l))
    Wait.condition(function() card.setLock(true) end, function() return card.resting end, 5)
    table.insert(G.d.players[u.pcol].power_cards,card.getGUID())
    pd.held_cards[card.getGUID()] = nil
  else
    log("ERROR: undo() unknown id")
  end
end
--[[ Start the scoring sequence for all or some defined regions.
  Handles both special (action) scoring as well as general scoring at end of round.
  NOTE: runs runScoring() in a coro to allow for animations, pause for player input etc.
  regions: list of region numbers to score {1,2,3,4,}, default: {1,2,3,4,5,6,7,8,9}
  special: true: this is a special scoring, false: this is a general scoring; default: false
  subtitle: subtitle text to display in a special scoring; default: empty string
]]
function startScoring(regions, special, subtitle)
  local special = special or false
  local regions = regions or {1,2,3,4,5,6,7,8,9}
  local subtitle = subtitle or ""
  if env.trace then log("startScoring() "..tostring(special)) end
  local function sortRegions(regions)
    local temp = nil
    for _,r in ipairs(regions) do
      if not(temp) then temp = {r}
      else
        local added = false
        for i,e in ipairs(temp) do if r < e then table.insert(temp,i,r); added=true break end end
        if not(added) then table.insert(temp,#temp+1,r) end
      end
    end
    return temp
  end
  --Set up a new scoring run if it is not restarting, (see restoreGame()
  if not(G.d.scoring.restarting) then
    log("startScoring(): new scoring run")
    --Starting a new scoring so initialize persistent scoring data structure
    G.d.scoring = {
      running = false,
      phase = "not_started",
      regions = regions,
      subtitle = subtitle,
      selecting = false,
      placing = false,
      history = {Blue={},Red={},Green={},Purple={},Yellow={}},
      waitlist = {},
      status = {waitlist = {},info=""},
      reserves = {},
      special = special,
      castillo = false,
      first_only = false,
      info = {},
      summary = {},
      regions_completed = {},
    }
    local s = G.d.scoring
    --check for player reserves
    for p,pd in pairs(G.d.players) do
      if pd.reserves then table.insert(s.reserves,p) end
    end
    --Handle end of round pre-scoring things
    if not(special) then
      --clear player boards
      for p,pd in pairs(G.d.players) do
        pd.active=false
        pd.done = false
        updatePlayerBoardUI(p)
      end
      --remove any quarantines
      for r,rd in pairs(G.obj.regions) do
        if rd.quarantine then
          G.d.MSB[rd.quarantine].quarantine = false
          G.d.MSB[rd.quarantine].placed = false
          local o = getObjectFromGUID(rd.quarantine)
          o.setLock(false)
          if o.is_face_down then o.flip() end
          o.setPosition(G.d.MSB[rd.quarantine].home_pos)
          Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
          rd.quarantine = nil
          object_UI_setAttribute(r,"quarantined","active",false)
          object_UI_setAttribute(r,"label","active",false)
        end
      end
    end
    --Set up the regions to be scored
    if contains(regions,"castillo") then
      s.castillo = true
      table.remove(regions,indexOf(regions,"castillo"))
      if #regions > 0 then s.regions = sortRegions(regions) end
    elseif contains(regions,"first_only") then
      s.first_only = true
      s.regions = {1,2,3,4,5,6,7,8,9}
      s.castillo = false
    else
      s.castillo = not(special)
      if #regions > 0 then s.regions = sortRegions(regions) end
    end
  end
  --[[//////////////////////////// Coroutine to run the scoring /////////////////////////// ]]
  function runScoring()
    if env.trace then log("coroutine runScoring() starting") end
    local s = G.d.scoring
    s.running = true
    -- local backup = s.backup
    local marker = getObjectFromGUID(C.round_marker)
    G.d.phase = "scoring"
    --///////////////////// local functions ////////////////////////
    local function debug(msg) if true then log("runScoring(): "..msg) end end --DEBUG set false to disable
    local function pause(seconds)
      if seconds == nil then seconds = 1 end
      -- log("starting pause timer for "..tostring(seconds).." seconds")  --DEBUG
      local count = 0; local t = os.time()
      while count < seconds do
        if os.time() - t > 1 then t = os.time(); count = count + 1 end
        coroutine.yield(0)
      end
      -- log("exiting pause timer")
    end
    local function updateUI(info)
      if info.show then
        UI_setAttribute("scoring_pnl","visibility",G.d.visibility_all)
        UI_setAttribute("scoring_title_txt","text",info.title)
        local h = 140
        if info.subtitle then
          UI_setAttribute("scoring_subtitle_txt","text",info.subtitle)
          h = h + 60
          UI_setAttribute("scoring_subtitle_row","active",true)
        else UI_setAttribute("scoring_subtitle_row","active",false) end
        if info.veto_check then
          UI_setAttribute("scoring_veto_row","active",true)
          UI_setAttribute("scoring_msg_row","active",false)
        else
          UI_setAttribute("scoring_veto_row","active",false)
          UI_setAttribute("scoring_msg_row","active",true)
          UI_setAttribute("scoring_msg_txt","text",info.msg)
        end
        if info.scores then h = h + 125 end
        for _,pcol in ipairs({"Blue","Red","Green","Purple","Yellow"}) do
          if info.region then UI_setAttribute(pcol.."_scoring_region_title_txt","text",info.region)
          else UI_setAttribute(pcol.."_scoring_region_title_txt","text","") end
          if info.scores then
            UI_setAttribute(pcol.."_scoring_region_row","active",true)
            for i=1,3 do
              for _,c in ipairs({"Blue","Red","Green","Purple","Yellow"}) do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_"..c,"active",false) end
              if #info.scores[i] > 0 then
                UI_setAttribute(pcol.."_scoring_"..tostring(i).."_pts_txt","text",tostring(info.scores[i][1].points.." pts"))
                for _,e in ipairs(info.scores[i]) do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_"..e.player,"active",true) end
              else UI_setAttribute(pcol.."_scoring_"..tostring(i).."_pts_txt","text","0 pts") end
              UI_setAttribute(pcol.."_scoring_"..tostring(i).."_row","active",true)
            end
          else
            for i=1,3 do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_row","active",false) end
            UI_setAttribute(pcol.."_scoring_region_row","active",false)
          end
          if info.completed and #s.history[pcol] > 1 then
            UI_setAttribute(pcol.."_scoring_region_prev","active",true)
            UI_setAttribute(pcol.."_scoring_region_next","active",false)
            UI_setAttribute(pcol.."_scoring_region_row","hidden",tostring(#s.history[pcol]))
          else
            UI_setAttribute(pcol.."_scoring_region_prev","active",false)
            UI_setAttribute(pcol.."_scoring_region_next","active",false)
          end
        end
        if info.summary then
          if info.summary_title then UI_setAttribute("scoring_summary_txt","text",info.summary_title)
          else UI_setAttribute("scoring_summary_txt","text","Running Totals") end
          local i = 0;
          -- h = h + 35
          local sh = 35
          for i=1,5 do UI_setAttribute("scoring_summary_"..tostring(i).."_row","active",false) end
          for p,s in pairs(s.summary) do
            i = i + 1;
            -- h = h + 30
            sh = sh + 30
            UI_setAttribute("scoring_summary_"..tostring(i).."_pnl","color",p)
            UI_setAttribute("scoring_summary_"..tostring(i).."_txt","text",p)
            UI_setAttribute("scoring_summary_score_"..tostring(i).."_txt","text",tostring(s))
            UI_setAttribute("scoring_summary_"..tostring(i).."_row","active",true)
          end
          for _,p in ipairs(G.d.player_order) do
            if not(s.summary[p]) then
              i = i + 1;
              -- h = h + 30
              sh = sh + 30
              UI_setAttribute("scoring_summary_"..tostring(i).."_pnl","color",p)
              UI_setAttribute("scoring_summary_"..tostring(i).."_txt","text",p)
              UI_setAttribute("scoring_summary_score_"..tostring(i).."_txt","text","0")
              UI_setAttribute("scoring_summary_"..tostring(i).."_row","active",true)
            end
          end
          UI_setAttribute("scoring_summary_row","preferredHeight",tostring(sh))
          UI_setAttribute("scoring_summary_row","height",tostring(sh))
          UI_setAttribute("scoring_summary_row","active",true)
          h = h + sh
        else UI_setAttribute("scoring_summary_row","active",false) end
        if info.button then UI_setAttribute("scoring_close_row","active",true); h = h + 40
        else UI_setAttribute("scoring_close_row","active",false) end
        UI_setAttribute("scoring_pnl","height",tostring(h))
        UI_setAttribute("scoring_pnl","visibility",G.d.visibility_all)
      else UI_setAttribute("scoring_pnl","visibility","Pink") end
    end
    local function process(scores)
      s.info.scores = {{},{},{},}
      -- log("scores:");log(scores)
      for i,e in ipairs(scores) do
        if s.first_only and i > 1 then break end
        if #e == 1 then
          local d = e[1]
          -- local tmp = "#"..tostring(i)..": "..d.player.." scores "..tostring(d.score)
          -- if i == 1 then
          --   if d.grande or d.king then tmp = tmp.." w/bonus:" end
          --   if d.grande then tmp = tmp.." Grande" end
          --   if d.king then tmp = tmp.." King" end
          -- end
          -- debug(tmp)
          G.d.players[d.player].score = G.d.players[d.player].score + d.score
          if not(s.summary[d.player]) then s.summary[d.player] = d.score
          else s.summary[d.player] = s.summary[d.player] + d.score end
          table.insert(s.info.scores[i],{player=d.player,points=d.score})
          if s.special then G.d.action.undo.special[tostring(Time.time).."_"..tostring(i)] = {id="score",pcol=d.player,points=d.score} end
          setScoringMarkerPosition(d.player)
        elseif #e > 1 then
          local s = "Players"
          for _,d in ipairs(e) do
            G.d.players[d.player].score = G.d.players[d.player].score + d.score
            if not(s.summary[d.player]) then s.summary[d.player] = d.score
            else s.summary[d.player] = s.summary[d.player] + d.score end
            table.insert(s.info.scores[i],{player=d.player,points=d.score})
            if s.special then G.d.action.undo.special[tostring(Time.time).."_"..tostring(i)] = {id="score",pcol=d.player,points=d.score} end
            setScoringMarkerPosition(d.player)
          end
        end
      end
      --save the history of this scoring
      for c,h in pairs(G.d.scoring.history) do
        if contains(G.d.player_order,c) then
          table.insert(h,{region=s.info.region,scores=simpleDeepCopy(s.info.scores)})
        end
      end
    end
    if s.phase == "not_started" then  -- //////////// Start the scoring /////////////
      debug("set up a new scoring data structure")
      -- clear active player buttons
      if not(s.special) then G.d.players[G.d.active_player].active = false end
      G.d.players[G.d.active_player].undo_button = false
      G.d.players[G.d.active_player].done_button = false
      G.d.players[G.d.active_player].action_ui = false
      updatePlayerBoardUI(G.d.active_player)
      --status data for scoring display
      s.info = {
        show = false,
        title = "",
        msg = "",
        region = nil,
        subtitle = nil,
        scores = nil,
        summary = false,
        button = false,
      }
      if s.special then
        if s.subtitle ~= "" then
          s.info.title = "Special Scoring"
          s.info.subtitle = s.subtitle
        else
          local tmp = "[ "
          if s.castillo then tmp = tmp.."Castillo" end
          if s.castillo and #s.regions > 0 then tmp = tmp..", " end
          for i,r in ipairs(s.regions) do
            tmp = tmp..tostring(r)
            if i < #s.regions then tmp = tmp..", " end
          end
          tmp = tmp.." ]"
          s.info.title = "Special Scoring"
          s.info.subtitle = "Regions to be scored:\n"..tmp
          s.info.show = true
        end
      else
        s.info.title = "General Scoring"
        s.info.subtitle = nil
      end
      updateUI(s.info)
      for pcol,pdata in pairs(G.d.players) do
        if pdata.action_ui then
          pdata.action_ui = false
          updatePlayerBoardUI(pcol)
        end
      end
      if s.special then
        s.phase = "veto_check"
      else
        s.phase = "reserves_selection"
      end
    end
    if s.phase == "veto_check" then -- //////////// Veto check for a special scoring //////////
      if G.d.veto_player then
        if s.restarting then
          s.restarting = false
          debug("skip veto_check setup, goto wait loop")
        else
          log("--- TESTING: runScoring(): veto check")
          s.info.veto_check = true --triggers display veto message in scoring UI
          G.d.confirm_lock = true
          UI_setAttribute("veto_player_pnl","color",G.d.veto_player)
          UI_setAttribute("veto_player_txt","text",G.d.veto_player)
          UI_setAttribute("veto_msg_txt","text","Veto _"..G.d.action.name.."_?")
          if G.env.intrigue_king_exp then
            UI_setAttribute("veto_pnl","hidden","")
            getObjectFromGUID(G.d.players[G.d.veto_player].power_card).clearButtons()
          else UI_setAttribute("veto_pnl","hidden","re_deal") end
          UI_setAttribute("veto_pnl","active",true)
          UI_setAttribute("scoring_veto_msg_txt","text","Waiting on Veto Player to decide")
        end
        while G.d.confirm_lock do coroutine.yield(0) end
        if G.d.action.vetoed then
          log("Special scoring canceled by veto")
          UI_setAttribute("scoring_pnl","active",false)
          log("exit runScoring() coro")
          return(1)
        else
          s.info.veto_check = false
          updateUI(s.info)
        end
      else
        s.info.veto_check = false
      end
      if #s.reserves > 0 then
        s.phase = "reserves_selection"
      else
        if s.special and s.castillo then
          s.phase = "score_castillo"
        elseif s.special then
          s.phase = "score_regions"
        else
          s.phase = "castillo_deployment"
        end
      end
    end
    if s.phase == "reserves_selection" then  -- //////////// Select regions for reserves ///////////
      if s.restarting then
        s.restarting = false
        debug("skip setup reserves deployment region selection, goto wait loop")
      else
        debug("set up reserves deployment region selection")
        local allowed = {1,2,3,4,5,6,7,8,9}
        s.status = {}
        s.status.info = "Select a region to deploy\nreserves. Choose a Taboo\nregion to skip reserves"
        s.status.waitlist = {}
        s.waitlist = {}
        for _,p in ipairs(s.reserves) do
          local pd = G.d.players[p]
          table.insert(s.status.waitlist,{player_color=p,player_status="Deciding"})
          table.insert(s.waitlist, p)
          pd.active = true
          pd.waiting = true
          pd.done_button = true
          pd.undo_button = false
          pd.show_disk = true
          pd.show_stage = false
          pd.disk_button = true
          pd.allowed_regions = allowed
          pd.selected_region = allowed[math.random(#allowed)]
          updatePlayerBoardUI(p)
        end
        s.status.show = true
        updateStatusUI(s.status)
      end
      while #s.waitlist > 0 do coroutine.yield(0) end -- pause until waitlist empty
      debug("exit wait on reserve deployment region selection")
      s.phase = "reserves_deployment"
    end
    if s.phase == "reserves_deployment" then  -- //////////// Reserves deployment cube placement ///////////
      if s.restarting then
        s.restarting = false
        debug("skip setup reserves deployment, goto wait loop")
      else
        debug("setup reserves deployment")
        s.info.msg = "Move Reserves to regions\nWaiting on players to place."
        s.info.scores = nil
        s.info.region = nil
        s.info.show = true
        updateUI(s.info)
        if s.special then s.status.info = "Special Scoring"
        else s.status.info = "General Scoring" end
        s.status.info = s.status.info.."\nPlace staged Caballeros\nPress Done when finished"
        s.status.waitlist = {}
        s.waitlist = {}
        for _,p in ipairs(s.reserves) do
          local pd = G.d.players[p]
          local rd = G.obj.regions[C.region_guids[pd.selected_region]]
          if rd.king or rd.quarantine or rd.protected then
            debug("Player "..p.." skipped Reserves")
          else
            local board = getObjectFromGUID(C.player_boards[p])
            local pos = board.positionToWorld(C.stage_pos_l[1])
            local o = getObjectFromGUID(pd.reserves)
            G.obj.snaps[o.getGUID()] = pos
            o.setLock(false)
            o.setPosition(pos)
            pd.staged_cubes = {pd.reserves}
            pd.cubes_to_place = {pd.reserves}
            pendingCubes("add",pd.reserves)
            table.insert(s.status.waitlist,{player_color=p,player_status="Placing"})
            table.insert(s.waitlist, p)
            pd.active = true
            pd.waiting = true
            pd.show_stage = true
            pd.show_disk = false
            pd.undo_button = false
            pd.done_button = false
            updatePlayerBoardUI(p)
          end
        end
      end
      if #s.waitlist > 0 then
        s.status.show = true
        updateStatusUI(s.status)
        while #s.waitlist > 0 do coroutine.yield(0) end -- pause until waitlist empty
        debug("exit waiting on players to place staged reserves")
      end
      --reset player status after waiting
      for p,d in pairs(G.d.players) do
        if p == G.d.active_player then d.active = true end
        d.waiting = false
        --TODO: update player board here?
      end
      if s.special and s.castillo then s.phase = "score_castillo"
      elseif s.special then s.phase = "score_regions"
      else s.phase = "castillo_selection" end
    end
    if s.phase == "castillo_selection" then  -- //////////// Castillo deployment region selection ///////////
      if s.restarting then
        s.restarting = false
        debug("skip setup castillo region selection, goto wait loop")
      else
        debug("setup castillo region selection")
        s.skip_castillo = true --see if Castillo is empty
        for _,l in pairs(G.obj.castillo.caballeros) do
          if #l > 0 then s.skip_castillo = false; break end
        end
        if s.skip_castillo then
          s.info.msg = "No Caballeros in the Castillo"
          s.info.show = true
          updateUI(s.info)
        else
          -- all players select destnation region secretly
          s.info.msg = "Players with Caballeros in \nCastillo secretly select a region"
          s.info.show = true
          updateUI(s.info)
          marker.setLock(false)
          marker.setPositionSmooth(C.round_scoring_positions[1],false,false)
          Wait.condition(function() marker.setLock(true) end, function() return marker.resting end, 5)
          s.status = {}
          s.status.info = "Secretly select a destination region\nTaboo region -> return to Court!"
          s.status.waitlist = {}
          s.waitlist = {}
          for i=1,5 do
            if i <= #G.d.player_order then
              local pcol = G.d.player_order[i]
              local pd = G.d.players[pcol]
              if #G.obj.castillo.caballeros[pcol] > 0 and not(pd.espionage) then
                table.insert(s.status.waitlist,{player_color=pcol,player_status="Deciding"})
                table.insert(s.waitlist, pcol)
                pd.active = true
                pd.waiting = true
                pd.done_button = true
                pd.undo_button = false
                pd.show_disk = true
                pd.show_stage = false
                pd.disk_button = true
                pd.allowed_regions = {1,2,3,4,5,6,7,8,9}
                pd.selected_region = math.random(1,9)
                updatePlayerBoardUI(pcol)
              end
            end
          end
        end
      end
      if #s.waitlist > 0 then
        s.status.show = true
        updateStatusUI(s.status)
        while #s.waitlist > 0 do coroutine.yield(0) end -- pause until waitlist empty
        debug("exit wait on players to select Castillo deployment regions")
        for i,pcol in ipairs(G.d.player_order) do
          local pd = G.d.players[pcol]
          pd.active = pcol == G.d.active_player
          pd.waiting = false
          pd.undo_button = false
          pd.done_button = false
          pd.show_disk = false
          updatePlayerBoardUI(pcol)
        end
      end
      if s.skip_castillo then s.phase = "score_regions"
      else s.phase = "score_castillo" end
    end
    if s.phase == "score_castillo" then  -- //////////// score the Castillo ////////////
      if s.restarting then
        s.restarting = false
        debug("skip castillo scoring, goto pause")
      else
        debug("score the castillo")
        if not(s.special) then
          marker.setLock(false)
          marker.setPositionSmooth(C.round_scoring_positions[2],false,false)
          Wait.condition(function() marker.setLock(true) end, function() return marker.resting end, 5)
        end
        s.info.msg = "Score the Castillo"
        s.info.region = "Castillo"
        s.info.scores = {{},{},{},}
        s.info.summary = true
        s.info.show = true
        updateUI(s.info)
        getObjectFromGUID(C.castillo).highlightOn("Yellow", 1)
        local scores = scoreRegion("castillo")
        if #scores > 0 then process(scores) end
        updateUI(s.info)
      end
      if s.special then
        s.phase = "score_regions"
        pause()
      else
        s.phase = "castillo_deployment"
      end
    end
    if s.phase == "castillo_deployment" then  -- //////////// Place staged cubes from Castillo in regions /////////////
      if s.restarting then
        s.restarting = false
        debug("skip setup castillo deployment, goto wait loop")
      else
        debug("players deploy staged cubes from Castillo")
        local placement = false
        for _,list in pairs(G.obj.castillo.caballeros) do if #list > 0 then placement = true; break end end
        if placement then
          s.info.msg = "Move Caballeros to regions\nWaiting on players to place."
          s.info.scores = nil
          s.info.region = nil
          s.info.show = true
          updateUI(s.info)
          marker.setLock(false)
          marker.setPositionSmooth(C.round_scoring_positions[3],false,false)
          Wait.condition(function() marker.setLock(true) end, function() return marker.resting end, 5)
          s.status.info = "General Scoring\nPlace staged Caballeros\nPress Done when finished"
          s.status.waitlist = {}
          s.waitlist = {}
          local castillo = getObjectFromGUID(C.castillo)
          for p,list in pairs(G.obj.castillo.caballeros) do
            if #list > 0 then
              local board = getObjectFromGUID(C.player_boards[p])
              local pd = G.d.players[p]
              pd.staged_cubes = {}
              pd.cubes_to_place = {}
              local r = G.obj.regions[C.region_guids[pd.selected_region]]
              if (r.king or r.quarantine or r.protected) and not(pd.espionage) then
                --return cubes to player court (replicating returnToCourt() here because of takeObject())
                cleanupCourt(p)
                for _,g in ipairs(list) do
                  local index = #G.d.players[p].court + 1
                  table.insert(G.d.players[p].court, g)
                  castillo.takeObject({
                    guid=g,
                    position=board.positionToWorld(C.court_pos_l[index]),
                    rotation={0,0,0},
                    smooth=true,
                    callback_function = function(o)
                      G.obj.snaps[g] = board.positionToWorld(C.court_pos_l[index])
                      o.setLock(env.lock_player_cubes)
                    end
                  })
                end
              else
                -- add player to waitlist
                table.insert(s.status.waitlist,{player_color=p,player_status="Placing"})
                table.insert(s.waitlist, p)
                pd.active = true
                pd.waiting = true
                pd.show_stage = true
                pd.show_disk = false
                pd.undo_button = false
                pd.done_button = false
                updatePlayerBoardUI(p)
                -- put cubes in player staging area
                for i,g in ipairs(list) do
                  local pos = board.positionToWorld(C.stage_pos_l[i])
                  castillo.takeObject({
                    guid=g,
                    position=pos,
                    rotation={0,0,0},
                    smooth=true, --set false if problems with collisions
                    callback_function = function(o)
                      G.obj.snaps[g] = pos
                      pendingCubes("add",g)
                      table.insert(pd.staged_cubes,g)
                      table.insert(pd.cubes_to_place,g)
                    end
                  })
                end
                if G.obj.castillo.grandes[p] then
                  local n = #list
                  local rem = math.fmod(n,6)
                  if rem == 0 then n = n + 1
                  elseif rem == 5 then n = n + 2 end
                  local pos = nil
                  if n <= 30 then
                    pos = board.positionToWorld(C.stage_pos_l[n])
                    pos.z = pos.z - 1
                  else --place in a reasonable position, below staging area
                    pos = board.positionToWorld(C.stage_pos_l[26])
                    pos.z = pos.z - 1.5
                  end
                  pos.x = pos.x + 1
                  castillo.takeObject({
                    guid=G.obj.castillo.grandes[p],
                    position=pos,
                    rotation={0,0,0},
                    smooth=true, --set false if problems with collisions
                    callback_function = function(o)
                      G.obj.snaps[o.getGUID()] = pos
                      pendingCubes("add",o.getGUID())
                      table.insert(pd.staged_cubes,o.getGUID())
                      table.insert(pd.cubes_to_place,o.getGUID())
                      G.obj.castillo.grandes[p] = false
                    end
                  })
                end
              end
              G.obj.castillo.caballeros[p] = {}
              updateCastilloUI()
            end
          end
          s.status.show = true
          updateStatusUI(s.status)
        end
      end
      while #s.waitlist > 0 do coroutine.yield(0) end -- pause until waitlist empty
      debug("exit waiting on players to place staged cubes")
      --reset player status after waiting
      for p,d in pairs(G.d.players) do
        if p == G.d.active_player then d.active = true end
        d.waiting = false
        --TODO: update player board here?
      end
      if #s.regions > 0 then
        s.phase = "score_regions"
        s.status.show = false
        updateStatusUI(s.status)
      else
        s.phase = "end_scoring"
      end
    end
    if s.phase == "score_regions" then  -- //////////// sequentially score regions in the list ////////////
      for _,i in ipairs(s.regions) do
        if contains(s.regions_completed,i) then
          debug("region "..tostring(i).." already scored, skipping")
        else
          if not(s.special) then
            marker.setLock(false)
            marker.setPositionSmooth(C.round_scoring_positions[3+i],false,false)
            Wait.condition(function() marker.setLock(true) end, function() return marker.resting end, 5)
          end
          getObjectFromGUID(C.region_guids[i]).highlightOn("Yellow")
          local scores = scoreRegion(C.region_guids[i])
          s.info.msg = "Score region "..tostring(i)..": "..G.obj.regions[C.region_guids[i]].name
          s.info.region = G.obj.regions[C.region_guids[i]].name
          s.info.scores = {{},{},{},}
          s.info.summary = true
          s.info.show = true
          updateUI(s.info)
          table.insert(s.regions_completed,i)
          if #scores == 0 then
            s.info.msg = s.info.msg.."\nNo Caballeros in the region"
            updateUI(s.info)
            pause(2)
          else
            process(scores)
            updateUI(s.info)
            pause(2)
          end
          getObjectFromGUID(C.region_guids[i]).highlightOff()
        end
      end
      s.phase = "end_scoring"
    end
    if s.phase == "end_scoring" then  -- //////////// wrap up the scoring run //////////////
      debug("scoring end processing")
      s.info.completed = true
      s.info.msg = "Scoring Finished"
      s.info.summary_title = "Final Summary"
      s.info.summary = true
      s.info.button = true
      s.info.show = true
      updateUI(s.info)
      -- ///////////// handle end of action stuffs if special action  ////////////////
      --TODO: perhaps set an "allow_undo" flag in the action when starting scoring, cleaner
      if s.special then
        local a = G.d.action
        local pdata = G.d.players[G.d.active_player]
        debug("special scoring, action end processing stuffs")
        if G.env.intrigue_king_exp then
          a.IK.special.completed = true
        end
        a.special_completed = true
        if a.special.selected or (a.special.secret and a.special.players == "all") then
          a.stage = "main"
          a.undo = {main={},court={},special={},reset=false}; debug("special scoring, secret, clearing undo") --DEBUG
          pdata.disable_reset = true
          pdata.allow_undo = false
          pdata.undo_button = false
        else
          a.stage = "special"
          pdata.disable_reset = false
          pdata.allow_undo = true
          pdata.undo_button = true
        end
        pdata.done_button = true
        pdata.active = true
        pdata.action_ui = true
        updatePlayerBoardUI(G.d.active_player)
        --handel any post scoring special actions
        if a.special.ret_caballeros then
          --return all caballeros in the region(s) to respective provinces
          for _,i in ipairs(s.regions) do
            local rd = G.obj.regions[C.region_guids[i]]
            if rd.king or rd.quarantine or rd.protected then debug("failed, region is taboo"); break end --TODO: don't allow taboo region in action
            for p,caballeros in pairs(rd.caballeros) do
              for g,_ in pairs(caballeros) do returnToProvinces(p, g, true) end
              rd.caballeros[p] = {}
            end
          end
          updateBoardUI()
        end
      else
        --clear any region/player/modifier flags for general scoring, trash relevant cards, etc.
        for p,pd in pairs(G.d.players) do
          if pd.espionage then
            local trash = getObjectFromGUID(C.trash)
            trash.putObject(getObjectFromGUID(pd.espionage))
            pd.held_cards[pd.espionage] = nil
            pd.espionage = nil
          end
          if G.d.bridge and p == G.d.bridge.player then
            G.d.players[p].score = G.d.players[p].score + 1
            setScoringMarkerPosition(p)
          end
        end
        local update = false
        for _,rd in pairs(G.obj.regions) do
          if rd.double_scoring then rd.double_scoring = nil; update = true end
        end
        if update then updateBoardUI() end
      end
      -- ///////////// return to game state prior to scoring ////////////////
      if s.special then
        G.d.phase = "actions"
        updateStatusUI(G.d.status)
      else
        if G.d.round == 9 then setEndGame()
        else startBidPhase() end
      end
    end
    s.running = false
    debug("exiting coroutine")
    return(1)
  end
  log("startScoring(): starting runScoring() coroutine") --DEBUG
  startLuaCoroutine(Global, "runScoring")
end
--[[ Show game end results. Set game_end phase.
--]]
function setEndGame()
  if env.trace then log("setEndGame()") end
  G.d.phase = "game_end"
  local s = G.d.status
  local temp = nil
  for c,p in pairs(G.d.players) do
    local new = {player=c,score=p.score}
    if not(temp) then temp = {new}
    else
      local found = false
      for i,e in ipairs(temp) do
        if p.score >= e.score then
          table.insert(temp,i,new)
          found=true
          break
        end
      end
      if not(found) then table.insert(temp,#temp+1,new) end
    end
  end
  s.info = "Player "..temp[1].player.." Wins!\n\nFinal Scores:"
  s.waitlist = {}
  for i,e in ipairs(temp) do
    table.insert(s.waitlist,i,{player_color=e.player,player_status=tostring(e.score)})
  end
  s.show = true
  updateStatusUI(G.d.status)
end

-- //////////// User interaction handlers //////////////////

--[[ Handler for I&K Veto card button click
--]]
function vetoCardClick(card, pcol, alt)
  if env.trace then log("vetoCardClick() "..pcol..", "..card.getGUID()) end
  if pcol ~= G.d.veto_player then log("ignore non veto player"); return end --ignore other players
  if not(G.d.action.allow_veto) then log("vetoCardClick(): action veto not allowed"); return end
  card.clearButtons()
  G.d.confirm_lock = true
  UI_setAttribute("veto_player_pnl","color",G.d.veto_player)
  UI_setAttribute("veto_player_txt","text",G.d.veto_player)
  UI_setAttribute("veto_msg_txt","text","Veto _"..G.d.action.name.."_?")
  UI_setAttribute("veto_pnl","hidden","") --no redeal for I&K veto card
  UI_setAttribute("veto_pnl","active",true)
end
--[[ Handler for clicking on a "Leave Face Up" card.
    Used during the action to remove one.
--]]
function clickFaceUpCard(card, pcol, alt)
  if env.trace then log("clickFaceUpCard() "..pcol..", "..card.getGUID()) end
  if G.d.confirm_lock then log("clickFaceUpCard() confirm locked, ignoring"); return end
  if G.d.action.vetoed then log("clickFaceUpCard() action vetoed, ignoring"); return end
  --validate the action
  local a = G.d.action
  if a.player ~= pcol then return end --ignore
  if a.IK and a.IK.special.id ~= "remove_face_up" then log("clickFaceUpCard(): invalid action id "..tostring(a.IK.special.id)); return end
  --disable all card buttons
  for _,d in pairs(G.d.players) do
    for g,_ in pairs(d.held_cards) do getObjectFromGUID(g).clearButtons() end
  end
  --undo the actions for the card being removed using the saved face up card info.
  --NOTE: see undo(): 'remove_face_up'
  local p = card.memo
  local pd = G.d.players[p]
  local undo = pd.held_cards[card.getGUID()]
  if undo.id == "take6" then
    log("clickFaceUpCard(): special case for removing 'take6' card")
    G.obj.regions[undo.region].caballero_limit = nil
    object_UI_setAttribute(undo.region,"limit","active",false)
    a.undo.special["remove_face_up_"..tostring(Time.time)] = {id="remove_face_up",restore_card=true,g=card.getGUID(),p=p,a="take6",v=card.value,r=undo.region}
  elseif undo.id == "reserves" then
    log("clickFaceUpCard(): special case for removing 'reserves' card")
    a.undo.special["remove_face_up_"..tostring(Time.time)] = {id="remove_face_up",restore_card=true,g=card.getGUID(),p=p,a="reserves",v=card.value,cube=pd.reserves}
    returnToProvinces(p, pd.reserves)  -- put cube back in target player Provinces
    pd.reserves = nil  -- clear target player reserves entry
  else
    log("ERROR: clickFaceUpCard() unexpected card undo id"); return
  end
  --trash the card & remove from target player held cards list
  pd.held_cards[card.getGUID()] = nil
  card.setLock(false)
  getObjectFromGUID(C.trash).putObject(card)
  --clean up target player's held cards if any remain
  local i,board = 1,getObjectFromGUID(C.player_boards[p])
  for g,_ in pairs(pd.held_cards) do
    local pos = board.positionToWorld(C.IK.card_pos_l[i])
    pos.y = pos.y + 2
    local c = getObjectFromGUID(g)
    c.setPosition(pos)
    Wait.condition(function() c.setLock(true) end, function() return c.resting end, 5)
    i = i + 1
  end
  -- update active playerboard UI
  G.d.action.stage_status = "Card removed"
  G.d.action.disallow_finished = false
  updatePlayerBoardUI(pcol)
end
--[[ Handler for clicking a player board button. Used during opponent selection
--]]
function playerBoardClick(board, pcol, alt)
  if env.trace then log("playerBoardClick() "..pcol..", "..board.getGUID()) end
  if G.d.confirm_lock then log("playerBoardClick() confirm locked, ignoring"); return end
  if G.d.action.vetoed then log("playerBoardClick() action vetoed, ignoring"); return end
  local s = G.d.action.special
  local pdata = G.d.players[pcol]
  if s.id == "special_scoring" and s.selected then
    log("Selecting an opponent to choose final scoring region from candidates") --DEBUG
    if s.selected_opponent then
      getObjectFromGUID(C.player_boards[s.selected_opponent]).highlightOff()
    end
    s.selected_opponent = keyOf(C.player_boards,board.getGUID())
    board.highlightOn(Color["Yellow"])
    pdata.done_button = true
    updatePlayerBoardUI(pcol)
  else
    log("ERROR: playerBoardClick() unhandled action state")
  end
end
--[[ EXPERIMENTAL: Handler for clicking a region button. Used during region selection
    NOTE: testing an approach.  Maybe useful in other cases vs. disk seleciton.
    Though that works pretty well.
--]]
--TODO: add player color protection
function regionClick(region, pcol, alt)
  if env.trace then log("regionClick() "..pcol..", "..region.getGUID()) end
  if G.d.confirm_lock then log("regionClick() confirm locked, ignoring"); return end
  if G.d.action.vetoed then log("regionClick() action vetoed, ignoring"); return end
  local s = G.d.action.special
  local guid = region.getGUID()
  local rdata = G.obj.regions[guid]
  local pdata = G.d.players[pcol]
  if s.id == "special_scoring" and s.selected then
    if not(s.regions_selected) then
      log("Selecting region candidates") --DEBUG
      if pcol ~= G.d.action.player then log("Ignore non action player"); return end
      if contains(s.region_candidates,guid) then
        table.remove(s.region_candidates,indexOf(s.region_candidates,guid))
        region.highlightOff()
        if pdata.done_button then
          pdata.done_button = false
          updatePlayerBoardUI(pcol)
        end
      else
        if #s.region_candidates == s.selected then return end --ignore
        table.insert(s.region_candidates,guid)
        region.highlightOn(Color["Yellow"])
        if #s.region_candidates == s.selected then
          pdata.done_button = true
          updatePlayerBoardUI(pcol)
        end
      end
    elseif not(s.final_region_selected) then
      log("Opponent is selecting final region from candidates")
      if pcol ~= s.selected_opponent then log("Ignore wrong opponent player"); return end
      if G.d.players[G.d.action.player].allow_undo then --no undo/reset after this point
        G.d.players[G.d.action.player].disable_reset = true
        G.d.players[G.d.action.player].allow_undo = false
        G.d.players[G.d.action.player].undo_button = false
        updatePlayerBoardUI(G.d.action.player)
      end
      if s.final_region then getObjectFromGUID(s.final_region).highlightOn(Color["Yellow"]) end
      region.highlightOn(Color["White"])
      s.final_region = region.getGUID()
      G.d.players[pcol].done_button = true
      updatePlayerBoardUI(pcol)
    else
    end
  else
    log("ERROR: regionClick() unhandled action state")
  end
end
--[[ NOTE: EXPERIMENTAL Handler for confirm dialog clicks.
  G.d.confirm_actions: a data structure that may define a number of posible actions.
    cancel: a table of cancel action parameters.
    ok: a table of ok action parameters.
    ack: a table of ack aaction parameters.
  Each of these tables may contain:
    pre: ids of actions to take before the defined function is called.
    fn: function name to execute, also params: parameters to pass in the call function.
    post: ids of actions to take after the defined function is called.
  All pre, fn, post elements are optional.
  The button id determines which possible action is performed.
  NOTE: This data structure should be TTS save data safe.  Take care when adding
    new parameters to ensure that. pre and post are always lists of ids.  Everything
  else is key:value.
--]]
function confirmClick(player, button, id)
  if env.trace then log("confirmClick() "..player.color..", "..tostring(id)) end
  assert(G.d.confirm_actions,"confirmClick() missing confirm_actions")
  local conf = G.d.confirm_actions
  local pdata = G.d.players[player.color]
  if id == "cancel" then
    if conf.cancel.pre then
      for _,pre in ipairs(conf.cancel.pre) do
        --TODO: any pre cancel fn things
      end
    end
    if conf.cancel.fn then Global.call(conf.cancel.fn,conf.cancel.params) end
    if conf.cancel.post then
      for _,post in ipairs(conf.cancel.post) do
        --TODO: any post cancel fn things
      end
    end
    UI_setAttribute("confirm_pnl","visibility","Pink")
  elseif id == "ok" then
    if conf.ok.pre then
      for _,pre in ipairs(conf.ok.pre) do
        if pre == "end_actions" then
          local a = G.d.action
          if a.IK then
            if a.IK.king then a.IK.king.completed = true end
            if a.IK.intrigue then a.IK.intrigue.completed = true end
            a.IK.special.completed = true
          else
            a.court_completed = true
            a.special_completed = true
          end
        end
      end
    end
    if conf.ok.fn then Global.call(conf.ok.fn,conf.ok.params) end
    if conf.ok.post then
      for _,post in ipairs(conf.ok.post) do
        --TODO: any post ok fn things
      end
    end
    UI_setAttribute("confirm_pnl","visibility","Pink")
  elseif id == "ack" then
    --TODO: ack stuffs
  else
    log("ERROR: confirmClick() unhandled id")
  end
  G.d.confirm_lock = false
end
--[[ Handle object drops by players.
  Object tags supported: Caballero, Grande, King, ScoreBoard
  snapBack() if not in the actions phase.
  Call appropriate handler for the respective object tag.
  NOTE: Multiple Physics.cast() per object dropped.
  TODO: if outside current Region, snapBack if not in a valid move action
  TODO: handle drop on playerboard (return to Court/Province)
  TODO: Add a tile under Castillo (Castillo base?) use that to detect Castillo in Physics.cast.
        Explicity add to Castillo bag in addToCastillo(), then get rid of tryObjectEnter() and
        all script on the Castillo bag
]]
--TODO: handle playing delayed action from card in hand
function onObjectDrop(pcol, obj)
  if env.ignore_drop then return end --DEVELOPMENT
  if G.d.phase == "" then return end --game not started
  if obj.hasTag("Bridge") then
    if G.d.action.vetoed then snapBack(obj.getGUID()); return end
    return --ignore the bridge (handled by itself) TODO: move it's onDrop() code here?
  end
  local function debug(msg) if true then log("DEBUG onObjectDrop(): "..msg) end end --DEBUG
  --Handle moving cards around
  if obj.hasTag("PowerCard") then
    if contains(Player[pcol].getHandObjects(),obj) then return end --ignore
    if pcol ~= obj.memo then obj.deal(1,obj.memo); return end
    if G.d.phase ~= "bidding" then obj.deal(1,obj.memo); return end
  end
  --check for supported objects
  if not(obj.hasTag("Caballero") or obj.hasTag("Grande") or obj.hasTag("King") or obj.hasTag("ScoreBoard") or
    obj.hasTag("Veto") or obj.hasTag("PowerCard")) then debug("WARN: object "..obj.getGUID().." not supported"); return end
  --Don't allow anything during a confirm dialog
  if G.d.confirm_lock then snapBack(obj.getGUID()); return end
  --Where is this being dropped?
  local region,board,castillo = nil,nil,nil
  local pos = Player[pcol].getPointerPosition();pos.y = 0
  local hits = Physics.cast({origin = pos,direction = {0,1,0,},type = 1,debug = false,})
  for _,hit in ipairs(hits) do
    if hit.hit_object.hasTag("Region") then region = hit.hit_object.getGUID(); break
    elseif hit.hit_object.hasTag("PlayerBoard") then board = hit.hit_object.getGUID(); break
    elseif hit.hit_object.getGUID() == C.castillo_base then castillo = true; break
    end
  end
  --Allow movement of some objects within regions, just update snap point
  if region then
    local r = G.obj.regions[region]
    if (obj.hasTag("Caballero") and r.caballeros[obj.memo][obj.getGUID()]) or
        (obj.hasTag("Grande") and r.grandes[obj.memo]) or
        (obj.hasTag("King") and r.king and not(G.d.phase == "placement")) then
      Wait.condition(function() G.obj.snaps[obj.getGUID()] = obj.getPosition() end, function() return obj.resting end, 5)
      return
    end
  end
  --Handle the appropriate game phase
  if G.d.phase == "bidding" then
    if obj.hasTag("PowerCard") then
      for _,pd in pairs(G.d.players) do
        if pd.power_bid == obj.value then obj.deal(1,obj.memo); return end
      end
      local pdata = G.d.players[pcol]
      if not(pdata.active) then obj.deal(1,pcol); return end
      if pdata.power_card then obj.deal(1,pcol); return end
      if obj.value == 0 and #G.d.players_to_bid == 1 then obj.deal(1,pcol); return end --only allowed if > 1 player left in bidding
      local board = getObjectFromGUID(C.player_boards[pcol])
      obj.setPosition(board.positionToWorld(C.card_pos_l))
      Wait.condition(function() obj.setLock(true) end, function() return obj.resting end, 5)
      obj.setHiddenFrom({})
      pdata.undo_button = true
      pdata.done_button = true
      updatePlayerBoardUI(pcol)
      pdata.power_card = obj.getGUID()
      pdata.power_bid = obj.value
      if obj.value > 0 then table.remove(G.d.players_to_bid,indexOf(G.d.players_to_bid,pcol)) end
    else snapBack(obj.getGUID()) end
  elseif G.d.phase == "actions" then
    if obj.hasTag("Veto") then
      --TODO: should this immediately trigger the veto?  Just display dialog for now. confirm_lock should block any actions
      debug(pcol.." dropped Veto card")
      if contains(Player[pcol].getHandObjects(), obj) then debug("in hand"); return end --ignore moving in hand
      if pcol ~= G.d.veto_player then obj.deal(1,G.d.veto); debug("player not veto player"); return end
      if G.d.phase ~= "actions" then obj.deal(1,pcol); debug("not actions phase") return end
      if not(G.d.action.allow_veto) then obj.deal(1,pcol); debug("action veto not allowed"); return end
      G.d.confirm_lock = true
      UI_setAttribute("veto_player_pnl","color",G.d.veto_player)
      UI_setAttribute("veto_player_txt","text",G.d.veto_player)
      UI_setAttribute("veto_msg_txt","text","Veto _"..G.d.action.name.."_?")
      UI_setAttribute("veto_pnl","hidden","re_deal")
      UI_setAttribute("veto_pnl","active",true)
      return
    end
    if G.d.action.vetoed then snapBack(obj.getGUID()); return end
    if not(region or board or castillo) then snapBack(obj.getGUID()); return end
    if obj.hasTag("Caballero") then
      if region then
        --TODO: check for action state == "staging" and if pcol ~= obj.memo then snapBack(obj.getGUID()); return
        if not(addCaballero(pcol, region, obj.memo, obj.getGUID())) then snapBack(obj.getGUID()); return end
        Wait.condition(function() G.obj.snaps[obj.getGUID()] = obj.getPosition() end, function() return obj.resting end, 5)
      elseif board then
        debug("dropped Caballero on player board "..board)
        local a = G.d.action
        local guid = obj.getGUID()
        local success = false
        if a.stage == "waiting" and a.special.id == "king_returns" then
          if not(G.d.players[pcol].active) then debug(pcol.." not the active deciding player"); snapBack(guid); return end
          local origin = nil
          if pcol == obj.memo and pcol == keyOf(C.player_boards, board) then
            if a.caballeros_moved[pcol] == a.special.max then debug(pcol.." has returned max cubes"); snapBack(guid); return end
            --get the object origin (region or court), remove it when found
            if indexOf(G.d.players[pcol].court, guid) > 0 then
              origin = "court"; table.remove(G.d.players[pcol].court,indexOf(G.d.players[pcol].court, guid))
            else
              for g,r in pairs(G.obj.regions) do
                if r.caballeros[pcol][guid] then origin = g; r.caballeros[pcol][guid] = nil; break end
              end
            end
            assert(origin, "onObjectDrop() king_returns action; failed to detect origin")
            a.undo.special[guid] = {id="ret2prov", g=guid, player=pcol, origin=origin, snap=G.obj.snaps[guid]}
            returnToProvinces(pcol, guid)
            pendingCubes("add",guid)
            a.caballeros_moved[pcol] = a.caballeros_moved[pcol] + 1
            if a.caballeros_moved[pcol] == 1 then
              G.d.players[pcol].undo_button = true
              updatePlayerBoardUI(pcol)
            end
            if a.caballeros_moved[pcol] == a.special.max then
              debug(pcol.." has returned the required number of cubes")
              G.d.players[pcol].done_button = true
              updatePlayerBoardUI(pcol)
            end
            updateBoardUI()
            success = true
            --set active player buttons to disable undo/reset/done
            local pd = G.d.players[G.d.active_player]
            pd.undo_button = false
            pd.done_button = false
            pd.disable_reset = true
            pd.allow_undo = false
            updatePlayerBoardUI(G.d.active_player)
          end
        elseif a.special.id == "ret2provinces" then
          if a.special.each then
            local origin = nil
            for g,r in pairs(G.obj.regions) do
              if r.caballeros[obj.memo][guid] then origin = g; r.caballeros[obj.memo][guid] = nil; break end
            end
            if not(origin) then
              debug("ERROR: onObjectDrop(): ret2provinces, caballero "..guid.." not found in any region")
            elseif not(G.d.players[pcol].active) then
              debug("onObjectDrop(): ret2provinces, cube dropped on board by non-active player") --DEBUG
            elseif a.caballeros_moved[obj.memo] >= a.special.count then
              debug("onObjectDrop(): ret2provinces, exceeded count for color "..obj.memo) --DEBUG
            elseif a.total_moved >= a.total_max then
              debug("onObjectDrop(): ret2provinces, exceeded total moved limit of "..tostring(a.total_max)) --DEBUG
            else
              if not(a.caballeros_moved[obj.memo]) then
                debug("ERROR: onObjectDrop(): ret2provinces, cube color "..obj.memo.." not in caballeros_moved list") --DEBUG
              else
                a.caballeros_moved[obj.memo] = a.caballeros_moved[obj.memo] + 1
                G.d.players[pcol].undo_button = true
                a.total_moved = a.total_moved + 1
                a.stage_status = "Moved "..tostring(a.total_moved).." / "..tostring(a.total_max)
                if a.total_moved == a.total_max then
                  debug(pcol.." has moved the required number of cubes") --DEBUG
                  G.d.players[pcol].done_button = true
                end
                a.undo.special[guid] = {id="ret2prov", g=guid, player=obj.memo, origin=origin, snap=G.obj.snaps[guid]}
                returnToProvinces(obj.memo, obj.getGUID(), false)
                pendingCubes("add",obj.getGUID())
                updatePlayerBoardUI(pcol)
                success = true
              end
            end
          else
            debug("onObjectDrop(): ret2provinces, single caballero counter not yet supported")
          end
        else
          debug("ERROR: onObjectDrop(): unhandled state for Caballero dropped on a player board")
        end
        if not(success) then
          debug("onObjectDrop() failed drop on player board")
          snapBack(obj.getGUID())
        end
      elseif castillo then
        local g = obj.getGUID()
        if not(addToCastillo(obj)) then snapBack(obj.getGUID()); return end
        G.obj.snaps[g] = nil
        if G.d.action.pending_cubes[g] then G.d.action.pending_cubes[g] = nil end
        updateBoardUI()
      end
    elseif obj.hasTag("Grande") then
      --TODO: can Grande be dropped on a player board or the Castillo?
      if region then
        if not(setGrande(region, obj.memo)) then snapBack(obj.getGUID()); return end
        Wait.condition(function() G.obj.snaps[obj.getGUID()] = obj.getPosition() end, function() return obj.resting end, 5)
      elseif castillo then
        snapBack(obj.getGUID()) --not supported yet (or maybe not ever)
      else
        snapBack(obj.getGUID())
      end
    elseif obj.hasTag("King") then
      if not(region) or not(setKing(region)) then snapBack(obj.getGUID()); return end
      Wait.condition(function() G.obj.snaps[obj.getGUID()] = obj.getPosition() end, function() return obj.resting end, 5)
    elseif obj.hasTag("ScoreBoard") then
      if G.d.action.special.id == "mobile_score_board" then
        debug("dropped mobile scoreboard") --DEBUG
        if region then addScoreBoard(region, obj.getGUID())
        elseif castillo then addScoreBoard("castillo", obj.getGUID())
        else snapBack(obj.getGUID()) end
      elseif G.d.action.special.id == "IK_quarantine" then
        debug("dropped mobile scoreboard as quarantine") --DEBUG
        if region and addQuarantine(region, obj.getGUID()) then
          Wait.condition(function() G.obj.snaps[obj.getGUID()] = obj.getPosition() end, function() return obj.resting end, 5)
        else snapBack(obj.getGUID()) end
      else
        debug("ERROR: invalid action special for scoreboard drop")
      end
    end
  elseif G.d.phase == "scoring" then
    if not(obj.hasTag("Caballero") or obj.hasTag("Grande")) then
      debug("WARN: onObjectDrop(): object not a Caballero or Grande during general scoring")
      if G.obj.snaps[obj.getGUID()] then snapBack(obj.getGUID()) end
      return
    end
    local region = nil
    local pos = Player[pcol].getPointerPosition();pos.y = 0
    local hits = Physics.cast({origin = pos,direction = {0,1,0,},type = 1,debug = false,})
    for _,hit in ipairs(hits) do
      if hit.hit_object.hasTag("Region") then region = hit.hit_object.getGUID(); break end
    end
    if not(region) then snapBack(obj.getGUID()); return end
    if G.obj.regions[region].caballeros[obj.memo][obj.getGUID()] then
      G.obj.snaps[obj.getGUID()] = obj.getPosition(); return --ignore same region
    else
      if pcol ~= obj.memo then snapBack(obj.getGUID()); return end --disallow other players to move the cube
    end
    if obj.hasTag("Caballero") then
      if not(addCaballero(pcol, region, obj.memo, obj.getGUID())) then snapBack(obj.getGUID()); return end
    elseif obj.hasTag("Grande") then
      if not(setGrande(region, obj.memo)) then snapBack(obj.getGUID()); return end
    end
    G.obj.snaps[obj.getGUID()] = obj.getPosition()
  else
    debug("ERROR: onObjectDrop() unhandled game phase") --DEBUG
  end
end
--[[ Handler for the Veto dialog
--]]
function vetoClick(player, button, id)
  if env.trace then log("vetoClick() "..player.color..", "..tostring(id)) end
  if player.color ~= G.d.veto_player then log("ignore non veto player"); return end --ignore other players
  local ap = G.d.players[G.d.active_player]
  if id == "veto_yes" then
    if G.env.intrigue_king_exp then
      log("--- TODO: handle vetoClick():veto_yes for I&K exp")
      local card = getObjectFromGUID(G.d.players[player.color].power_card)
      assert(card, "vetoClick(): could not get I&K veto card object")
      getObjectFromGUID(C.trash).putObject(card)
    else
      log("base game vetoClick():veto_yes")
      local card = getObjectFromGUID(G.d.players[player.color].veto_card)
      assert(card, "vetoClick(): could not get veto card object")
      --TODO: do something with the card?
      log("--- TODO: vetoClick():veto_yes: do something with the base game veto card")
      G.d.players[player.color].veto_card = nil
      G.d.veto_round = nil
    end
    G.d.veto_player = nil
    G.d.action.vetoed = true --signal to processAction(), onObjectDrop(), runScoring(), etc. that action vetoed
    G.d.action.waitlist = {}
    G.d.action.waiting = 0
    G.d.confirm_lock = false --TODO: before or after processAction()??
    ap.active = true
    ap.allow_undo = false
    ap.action_ui = true
    ap.disable_reset = true
    G.d.phase = "actions"
    processAction(G.d.active_player, "finished") --TODO: do this automatically or just disable undo and make active player click finished?
    UI_setAttribute("veto_pnl","active",false)
    updatePlayerBoardUI(G.d.active_player)
  elseif id == "veto_no" then
    if G.env.intrigue_king_exp then
      log("--- TODO: vetoClick():veto_no: handle for I&K exp")
      --restore the button to the veto player's veto card
      local card = getObjectFromGUID(G.d.players[player.color].power_card)
      card.createButton(C.veto_card_button)
    else
      log("base game vetoClick():veto_no")
      if UI.getAttribute("veto_pnl", "hidden") == "re_deal" then
        local card = getObjectFromGUID(G.d.players[player.color].veto_card)
        assert(card, "vetoClick():veto_no: could not get veto card object to re_deal")
        card.deal(1,player.color)
        UI_setAttribute("veto_pnl","hidden","")
      end
    end
    UI_setAttribute("veto_pnl","active",false)
    G.d.confirm_lock = false
    G.d.veto_declined = true
    if G.d.phase == "actions" then
      if G.d.action.special.immediate then
        processAction(ap, "special")
      end
    elseif G.d.phase == "scoring" then
      log("--- TODO: vetoClick():veto_no: anything during scoring?")
    end
  else
    log("ERROR: vetoClick(): unhandled id")
  end
end
--[[ Game start options handler
]]
function startOptions(player, value, id)
  if env.trace then log("startOptions() player: "..tostring(player.color)..", id: "..tostring(id)) end
  local setting = (value == 'True')
  if id == "verbose" then
    G.env.verbose = setting
  elseif id == "short" then
    G.env.short_game = setting
  elseif id == "intrigue_king" then
    G.env.intrigue_king_exp = setting
  elseif id == "grandissimo" or id == "inquisitor_colonies" then
    broadcastToColor("Not yet implemented", player.color)
    setting = false
  else
    log("ERROR: startOptions(): unknown id: "..tostring(id))
  end
  UI_setAttribute(id,"isOn",setting)
end
--[[ Handler for clicks on base game action cards. Active player selecting a card.
]]
function cardClick(card, pcol, alt)
  if env.trace then log("cardClick() "..pcol..", "..card.getGUID()) end
  if G.d.confirm_lock then log("cardClick() confirm locked, ignoring"); return end
  if pcol ~= G.d.active_player then return end
  if G.d.phase ~= "actions" then log("cardClick() ignore card click in non-actions phase"); return end
  if G.d.players[pcol].action_card ~= "" then log("cardClick() ignore clicks when another card is selected"); return end
  G.d.players[pcol].action_card = card.getGUID()
  startPlayerActions(pcol)
end
--[[ Handler for player clicking on a button in the PlayerBoard action dialog.
]]
function actionClick(player, button, id)
  if env.trace then log("actionClick() "..player.color..", "..tostring(id)) end
  if G.d.confirm_lock then return end
  local board_color = Split(id,"_")[1]
  if player.color ~= board_color then return end
  local opt= Split(id,"_")[3]
  if opt == "IK" then opt = Split(id,"_")[4] end
  processAction(player.color, opt)
end
--[[ Handler for clicks on the scoring dialog.
    Hide the scoring dialog from the player.
--]]
function scoringClick(player, button, id)
  if env.trace then log("scoringClick() "..player.color..", "..id) end
  local tmp = UI.getAttribute(player.color.."_scoring_region_row","hidden")
  local history_index = nil
  if tmp then history_index = tonumber(tmp) end
  -- log("History index is "..tostring(history_index))
  local function updateScoringUI(pcol, info)
    -- log("updateScoringUI() "..tostring(pcol));log(info)
    if info.region then UI_setAttribute(pcol.."_scoring_region_title_txt","text",info.region)
    else UI_setAttribute(pcol.."_scoring_region_title_txt","text","") end
    if info.scores then
      UI_setAttribute(pcol.."_scoring_region_row","active",true)
      for i=1,3 do
        for _,c in ipairs({"Blue","Red","Green","Purple","Yellow"}) do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_"..c,"active",false) end
        if #info.scores[i] > 0 then
          UI_setAttribute(pcol.."_scoring_"..tostring(i).."_pts_txt","text",tostring(info.scores[i][1].points.." pts"))
          for _,e in ipairs(info.scores[i]) do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_"..e.player,"active",true) end
        else UI_setAttribute(pcol.."_scoring_"..tostring(i).."_pts_txt","text","0 pts") end
        UI_setAttribute(pcol.."_scoring_"..tostring(i).."_row","active",true)
      end
    else
      for i=1,3 do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_row","active",false) end
      UI_setAttribute(pcol.."_scoring_region_row","active",false)
    end
    if #info.scores <= 1 then
      UI_setAttribute(pcol.."_scoring_region_prev","active",false)
      UI_setAttribute(pcol.."_scoring_region_next","active",false)
    elseif history_index == #G.d.scoring.history[pcol] then
      UI_setAttribute(pcol.."_scoring_region_prev","active",true)
      UI_setAttribute(pcol.."_scoring_region_next","active",false)
    elseif history_index == 1 then
      UI_setAttribute(pcol.."_scoring_region_prev","active",false)
      UI_setAttribute(pcol.."_scoring_region_next","active",true)
    else
      UI_setAttribute(pcol.."_scoring_region_prev","active",true)
      UI_setAttribute(pcol.."_scoring_region_next","active",true)
    end
  end
  local target = Split(id,"_")[2]
  local action = Split(id,"_")[3]
  if target == "scoring" then action = Split(id,"_")[4] end
  if target == "dlg" and action == "close" then
    local vis = UI.getAttribute("scoring_pnl","visibility")
    local new = "Pink"
    local tmp = Split(vis,"|")
    for i,c in ipairs(tmp) do if c ~= player.color and c ~= "Pink" then new = new.."|"..c end end
    UI_setAttribute("scoring_pnl","visibility",new)
  elseif target == "scoring" and action == "prev" then
    local pcol = Split(id,"_")[1]
    assert(history_index, "ERROR: scoringClick(): action=prev, bad history index "..tostring(history_index)) --DEBUG
    if history_index > 1 then
      history_index = history_index - 1
      updateScoringUI(pcol, G.d.scoring.history[pcol][history_index])
      UI_setAttribute(pcol.."_scoring_region_row","hidden",tostring(history_index))
    end
  elseif target == "scoring" and action == "next" then
    local pcol = Split(id,"_")[1]
    assert(history_index, "ERROR: scoringClick(): action=next, bad history index "..tostring(history_index)) --DEBUG
    if history_index < #G.d.scoring.history[pcol] then
      history_index = history_index + 1
      updateScoringUI(pcol, G.d.scoring.history[pcol][history_index])
      UI_setAttribute(pcol.."_scoring_region_row","hidden",tostring(history_index))
    end
  else
    log("scoringClick(): unhandled action "..id)
  end
end
--[[ Handler for clicks on the secret disk.  Rotate disk to next/previous
    region based on mouse click and set accordingly in player data.
    Left click increments, Right (alt) click decrements.
]]
function diskClick(player, button, id)
  if env.trace then log("diskClick() "..player.color..", "..button..", "..id) end
  if G.d.confirm_lock then log("diskClick() confirm locked, ignoring"); return end
  local color = Split(id,"_")[1]
  if player.color ~= color then return end
  local pdata = G.d.players[player.color]
  if pdata.disk_button then
    local r = pdata.selected_region
    local index = indexOf(pdata.allowed_regions,r)
    local max = #pdata.allowed_regions
    if index == 0 then index = 1
    else
      if button == "-1" then
        if index < max then index = index + 1 else index = 1 end
      else
        if index > 1 then index = index - 1 else index = max end
      end
    end
    pdata.selected_region = pdata.allowed_regions[index]
    pdata.done_button = true
    updatePlayerBoardUI(player.color)
  end
end
--[[ Handler for player buttons on player board.
]]
function playerButton(player, button, id)
  if env.trace then log("playerButton() "..player.color..", "..tostring(id)) end
  if G.d.confirm_lock then log("playerButton() confirm locked, ignoring"); return end
  local color = Split(id,"_")[1]
  local action = Split(id,"_")[2]
  if player.color ~= color then return end
  if action == "done" then playerDone(player.color)
  elseif action == "undo" then playerUndo(player.color)
  else log(" ERROR: playerDone() unknown action")
  end
end
--[[ Handler for player clicking on a order bid button.
]]
function bidButton(player, button, id)
  if env.trace then log("bidButton() "..player.color..", "..tostring(id)) end
  if G.d.confirm_lock then log("bidButton() confirm locked, ignoring"); return end
  if player.color ~= G.d.active_player then return end
  local pdata = G.d.players[player.color]
  local index = tonumber(Split(id,"_")[2])
  pdata.bid_button = index
  local guid = C.button_guids[index]
  local button_data = G.obj.bid_buttons[guid]
  if G.d.phase == "bidding" then
    --normal bidding click
    if not(button_data.selected)  then
      button_data.selected = player.color
      table.remove(button_data.players,indexOf(button_data.players,player.color))
      table.insert(button_data.used,player.color)
      for g,d in pairs(G.obj.bid_buttons) do
        d.visibility = {}
        updateOrderButtonUI(g,d)
      end
    else
      log("WARN: bidButton() button "..tostring(index).." already selected") --DEBUG
    end
    table.remove(G.d.players_to_bid,indexOf(G.d.players_to_bid,player.color))
    pdata.undo_button = true
    pdata.done_button = true
    updatePlayerBoardUI(player.color)
  elseif G.d.phase == "actions" then
    --click during a special action (restore bid token)
    table.remove(button_data.used,indexOf(button_data.used,player.color))
    table.insert(button_data.players,player.color)
    button_data.button_on = false
    button_data.visibility = {}
    updateOrderButtonUI(guid,button_data)
    --clear the buttons
    G.d.action.undo.special[guid] = {id="restore_bid",g=guid,pcol=player.color}
    for g,button_data in pairs(G.obj.bid_buttons) do
      button_data.button_on = false
      button_data.visibility = {}
      updateOrderButtonUI(g,button_data)
    end
    --set playerboard UI
    local a = G.d.action
    a.stage = "special"
    a.stage_status = "Power "..tostring(index).." restored"
    pdata.disable_reset = false
    pdata.allow_undo = true
    pdata.undo_button = true
    pdata.done_button = true
    pdata.action_ui = true
    updatePlayerBoardUI(player.color)
  end
end
--[[ EXTERNAL Call fn, set the I&K bridge regions when dropped.
--]]
function setBridge(params)
  if env.trace then log("setBridge():");log(params) end
  local regions,pcol = params.regions,params.pcol
  assert(regions,"setBridge() missing regions parameter")
  assert(pcol,"setBridge() missing pcol parameter")
  assert(type(regions) == "table","setBridge() parameter regions must be a table")
  assert(#regions == 2,"setBridge() parameter regions must contain exactly two entries")
  log("Bridge player is "..pcol)
  for _,g in ipairs(regions) do
    if G.obj.regions[g].king or G.obj.regions[g].quarantine or G.obj.regions[g].protected then return false end
  end
  G.d.bridge.regions = simpleDeepCopy(regions)
  G.d.bridge.player = pcol
  G.d.action.disallow_finished = false
  updatePlayerBoardUI(pcol)
  return true
end
-- //////////////// UI Updaters ///////////////////

--[[ Update Global status UI
]]
function updateStatusUI(status)
  if env.trace then log("updateStatusUI()") end
  if status.show then
    UI_setAttribute("wait_message_txt","text",status.info)
    for i=1,5 do
      if i<= #status.waitlist then
        local pcol = status.waitlist[i].player_color
        UI_setAttribute("wait_p"..tostring(i).."_pnl","color",pcol)
        UI_setAttribute("wait_p"..tostring(i).."_txt","text",pcol)
        UI_setAttribute("wait_p"..tostring(i).."_status_txt","text",status.waitlist[i].player_status)
        UI_setAttribute("wait_p"..tostring(i).."_row","active",true)
      else
        UI_setAttribute("wait_p"..tostring(i).."_row","active",false)
      end
    end
    UI_setAttribute("player_wait_pnl","height",tostring(120+(40*#status.waitlist)))
    UI_setAttribute("player_wait_pnl","active",true)
  else
    UI_setAttribute("player_wait_pnl","active",false)
  end
end
--[[ Update UIs with current state
]]
function updateBoardUI()
  if env.trace then log("updateBoardUI()") end
  local board = C.board
  for g,info in pairs(G.obj.regions) do
    local r = info.scoring_order
    local rd = G.obj.regions[C.region_guids[r]]
    local s = tostring(info.scoring[1]).." / "..tostring(info.scoring[2]).." / "..tostring(info.scoring[3])
    if rd.double_scoring then s = "(2X) "..s end
    object_UI_setAttribute(board,"R"..tostring(r).."_S_txt","text",s)
    if info.king or info.protected then
      object_UI_setClass(board,"R"..tostring(r).."_H_pnl","Light Base")
      object_UI_setClass(board,"R"..tostring(r).."_H_txt","Title M")
    else
      object_UI_setClass(board, "R"..tostring(r).."_H_pnl","Clear")
      object_UI_setClass(board, "R"..tostring(r).."_H_txt","M LGray")
    end
    for color,present in pairs(info.grandes) do
      object_UI_setAttribute(board, color.."_R"..tostring(r).."_G_pnl","active",present)
    end
    for color,list in pairs(info.caballeros) do
      object_UI_setAttribute(board, color.."_R"..tostring(r).."_C_pnl","active", (sizeOf(list) > 0))
      object_UI_setAttribute(board, color.."_R"..tostring(r).."_C_txt","text", tostring(sizeOf(list)))
    end
  end
end
--[[ Update the player board UI for a given player with current data.
]]
function updatePlayerBoardUI(pcol)
  if env.trace then log("updatePlayerBoardUI() "..tostring(pcol)) end
  local pdata = G.d.players[pcol]
  local board = C.player_boards[pcol]
  if pdata.active then
    object_UI_setAttribute(board, "active_pnl","active",true)
    object_UI_setAttribute(board, "done_pnl","active",false)
  else
    object_UI_setAttribute(board, "active_pnl","active",false)
    object_UI_setAttribute(board, "done_pnl","active",pdata.done)
  end
  if pdata.waiting then object_UI_setAttribute(board,"active_txt","text","Deciding")
  else object_UI_setAttribute(board,"active_txt","text","Active") end
  object_UI_setAttribute(board, "secret_disk","active",pdata.show_disk)
  object_UI_setAttribute(board, "disk","rotation",C.disk_rotations[pdata.selected_region])
  object_UI_setAttribute(board, pcol.."_undo","active",pdata.undo_button)
  if pdata.undo_button then
    if pdata.waiting or pdata.show_disk then object_UI_setAttribute(board, pcol.."_undo","text","Undo")
    else object_UI_setAttribute(board, pcol.."_undo","text","Undo Turn") end
  end
  object_UI_setClass(board, pcol.."_undo","")
  object_UI_setAttribute(board, pcol.."_done","active",pdata.done_button);object_UI_setClass(board, pcol.."_done","")
  if pdata.disk_button then
    object_UI_setClass(board, "pointer","diskButton")
  else
    object_UI_setClass(board, "pointer","") --BUG: doesn't work, workaround: ignore clicks in diskClick()
  end
  if pdata.show_stage then
    if pdata.espionage then
      object_UI_setAttribute(board,"stage_title_txt","text","Move to any region")
    else
      object_UI_setAttribute(board,"stage_title_txt","text","Move to "..G.obj.regions[C.region_guids[pdata.selected_region]].name)
    end
    object_UI_setAttribute(board,"stage_pnl","active",true)
  else
    object_UI_setAttribute(board,"stage_pnl","active",false)
  end
  if pdata.action_ui then
    local a = G.d.action
    object_UI_setAttribute(board, "stage_reset_row","active",false)
    object_UI_setAttribute(board, "stage_status_row","active",false)
    object_UI_setAttribute(board, "action_IK_row","active",false)
    object_UI_setAttribute(board, "action_desc_txt", "text", a.description)
    object_UI_setAttribute(board, "action_stage_row","active",false)
    object_UI_setAttribute(board, "action_court_finished","active",false)
    object_UI_setAttribute(board, "action_court_pnl","active",false)
    object_UI_setAttribute(board, "action_special_pnl","active",false)
    object_UI_setAttribute(board, "action_special_finished","active",false)
    object_UI_setAttribute(board, "action_court_row","active",false)
    object_UI_setAttribute(board, "action_special_row","active",false)
    object_UI_setAttribute(board, "action_IK_special_pnl","active",false)
    object_UI_setAttribute(board, "action_IK_king_row","active",false)
    object_UI_setAttribute(board, "action_IK_king_pnl","active",false)
    object_UI_setAttribute(board, "action_IK_intrigue_row","active",false)
    object_UI_setAttribute(board, "action_IK_intrigue_pnl","active",false)
    object_UI_setAttribute(board, "stage_finished_placeholder_row","active",false)
    object_UI_setAttribute(board, "stage_finished_row","active",false)
    if a.stage == "main" then
      if a.IK then
        object_UI_setAttribute(board, "action_desc_row","active",true)
        object_UI_setAttribute(board, "action_IK_caballero_pnl","active",not(a.court_completed))
        if not(a.special_completed) and pdata.IK_special_action then
          object_UI_setAttribute(board, "action_IK_special_pnl","active",true)
        end
        if a.IK.king and pdata.IK_king_action then object_UI_setAttribute(board, "action_IK_king_row","active",true) end
        if pdata.IK_king_action then object_UI_setAttribute(board, "action_IK_king_pnl","active",true) end
        if a.IK.intrigue and pdata.IK_intrigue_action then object_UI_setAttribute(board, "action_IK_intrigue_row","active",true) end
        if pdata.IK_intrigue_action then object_UI_setAttribute(board, "action_IK_intrigue_pnl","active",true) end
        object_UI_setAttribute(board, "action_IK_row","active",true)
      else
        object_UI_setAttribute(board, "action_desc_row","active",true)
        object_UI_setAttribute(board, "action_court_row","active",true)
        object_UI_setAttribute(board, "action_special_row","active",true)
        if a.court_completed then object_UI_setAttribute(board, "action_court_finished","active",true) end
        object_UI_setAttribute(board, "action_court_pnl","active",not(a.court_completed))
        if a.special_completed then object_UI_setAttribute(board, "action_special_finished","active",true) end
        object_UI_setAttribute(board, "action_special_pnl","active",not(a.special_completed))
      end
    elseif a.stage == "court" then
      object_UI_setAttribute(board, "action_stage_row","active",true)
      local str = "Moved "..tostring(a.caballeros_moved).." / "
      str=str..tostring(a.court)
      object_UI_setAttribute(board, "stage_status_txt","text",str)
      object_UI_setAttribute(board, "stage_status_row","active",true)
      object_UI_setAttribute(board, "stage_finished_row","active",true)
      object_UI_setAttribute(board, "stage_reset_row","active",not(pdata.disable_reset))
    elseif a.stage == "special" then
      object_UI_setAttribute(board, "action_stage_row","active",true)
      object_UI_setAttribute(board, "stage_status_txt","text",a.stage_status)
      object_UI_setAttribute(board, "stage_status_row","active",true)
      if a.total_max and a.total_moved then
        object_UI_setAttribute(board, "stage_finished_placeholder_row","active",not(a.total_moved >= a.total_max))
        object_UI_setAttribute(board, "stage_finished_row","active",a.total_moved >= a.total_max)
      elseif a.disallow_finished then
        object_UI_setAttribute(board, "stage_finished_placeholder_row","active",true)
        object_UI_setAttribute(board, "stage_finished_row","active",false)
      else
        object_UI_setAttribute(board, "stage_finished_row","active",true)
      end
      object_UI_setAttribute(board, "stage_reset_row","active",not(pdata.disable_reset))
    elseif a.stage == "waiting" then
      object_UI_setAttribute(board, "action_stage_row","active",true)
      object_UI_setAttribute(board, "stage_status_txt","text","Waiting on selections")
      object_UI_setAttribute(board, "stage_status_row","active",true)
      object_UI_setAttribute(board, "stage_finished_placeholder_row","active",true)
      object_UI_setAttribute(board, "stage_reset_row","active",not(pdata.disable_reset))
    else
      log("WARN: updatePlayerBoardUI() unknown action stage")
    end
    object_UI_setAttribute(board, "action_pnl","active",true)
  else
    object_UI_setAttribute(board, "action_pnl","active",false)
  end
end
--[[ Update the UI for an Order Bidding button with current state.
]]
function updateOrderButtonUI(guid, button_data)
  if env.trace then log("updateOrderButtonUI() Button "..tostring(button_data.number)) end
  if button_data.button_on then
    local str="Pink"
    for _,c in ipairs(button_data.visibility) do str = str .."|"..c end
    object_UI_setAttribute(guid,"button","visibility",str)
  end
  object_UI_setAttribute(guid,"button","active",button_data.button_on)
  if button_data.selected then
    object_UI_setAttribute(guid,"player_pnl","color",button_data.selected)
    object_UI_setAttribute(guid,"player_txt","text",button_data.selected)
    object_UI_setAttribute(guid,"selected","active",true)
  else
    object_UI_setAttribute(guid,"selected","active",false)
  end
  local str="Pink"
  for _,c in ipairs(button_data.used) do str = str .."|"..c end
  object_UI_setAttribute(guid,"used","visibility",str)
  object_UI_setAttribute(guid,"used","active",#button_data.used > 0)
  if #button_data.players > 0 then
    object_UI_setAttribute(guid,"info_row_2","active",#button_data.players > 3)
    for i,player in ipairs(button_data.players) do
      local initial = string.sub(player, 1, 1)
      object_UI_setAttribute(guid,"info_"..tostring(i).."_pnl","color",player)
      object_UI_setAttribute(guid,"info_"..tostring(i).."_txt","text",initial)
      object_UI_setAttribute(guid,"info_"..tostring(i).."_pnl","active",true)
    end
    for i=#button_data.players+1,5 do
      object_UI_setAttribute(guid,"info_"..tostring(i).."_pnl","active",false)
    end
    object_UI_setAttribute(guid,"info","active",true)
  else
    object_UI_setAttribute(guid,"info","active",false)
  end
end
--[[ Update Castillo UI with current data
]]
function updateCastilloUI()
  if env.trace then log("updateCastilloUI()") end
  for color,list in pairs(G.obj.castillo.caballeros) do
    if #list > 0 then
      object_UI_setAttribute(C.castillo,color.."_txt","text",tostring(#list))
      object_UI_setAttribute(C.castillo,color.."_pnl","active",true)
    else
      object_UI_setAttribute(C.castillo,color.."_pnl","active",false)
    end
  end
end
--[[ TODO: Update Scoring UI with state of scoring progress.
]]
function updateScoringUI()
end

--//////////////// UTILITY ////////////////////////

--[[ Set a scoring marker position for a given player color. ]]
function setScoringMarkerPosition(p)
  if env.trace then log("setScoringMarkerPosition() "..tostring(p)) end
  local pos = getScorePos(p,G.d.players[p].score)
  local m = getObjectFromGUID(C.score_markers[p])
  m.setName(p.." "..tostring(G.d.players[p].score))
  local scale = Vector(0.6, 0.6, 0.6)
  if G.d.players[p].score > 150 then
    scale.y = 6; m.setDescription("+150")
    pos.y = pos.y + 2.8
  elseif G.d.players[p].score > 100 then
    scale.y = 4; m.setDescription("+100")
    pos.y = pos.y + 1.8
  elseif G.d.players[p].score > 50 then
    scale.y = 2; m.setDescription("+50")
    pos.y = pos.y + 0.8
  end
  m.setScale(scale)
  m.setLock(false)
  m.setPositionSmooth(pos, false, false)
  Wait.condition(function() m.setLock(true) end, function() return m.resting end, 5)
end
--[[ Handle cards entering the decks.  Intrigue and the King expansion only ]]
function tryObjectEnterContainer(cont, obj)
  if cont.hasTag("PowerCard") then
    local pcol = Split(cont.getName()," ")[1]
    local pdata = G.d.players[pcol]
    if not(contains(pdata.power_cards,obj.getGUID())) then log("rejecting power card/deck owner missmatch"); return false end --TODO: does this work?
    table.remove(pdata.power_cards, indexOf(pdata.power_cards, obj.getGUID()))
    object_UI_setAttribute(C.player_boards[pcol],"card_select_txt","text","Cards: "..tostring(#pdata.power_cards))
    if #pdata.power_cards == 13 then
      pdata.done_button = true
      updatePlayerBoardUI(pcol)
    elseif pdata.done_button then
      pdata.done_button = false
      updatePlayerBoardUI(pcol)
    end
  end
  return true
end
--[[ Handle cards leaving the start decks.  Intrigue and the King expansion only ]]
function onObjectLeaveContainer(cont, obj)
  if cont.hasTag("PowerCard") then
    local pcol = Split(cont.getName()," ")[1]
    local pdata = G.d.players[pcol]
    if G.d.phase == "IK_card_selection" then
      if cont.memo then obj.setHiddenFrom(JSON.decode(cont.memo)) end
      obj.addTag("PowerCard")
      obj.memo = pcol
      obj.addContextMenuItem("Sort Hand", sortHand)
      table.insert(pdata.power_cards, obj.getGUID())
      object_UI_setAttribute(C.player_boards[pcol],"card_select_txt","text","Cards: "..tostring(#pdata.power_cards))
      if #pdata.power_cards > 13 then
        broadcastToColor("Max 13 cards. Return excess to search window.",pcol)
        pdata.done_button = false
        updatePlayerBoardUI(pcol)
      elseif #pdata.power_cards == 13 then
        pdata.done_button = true
        updatePlayerBoardUI(pcol)
      elseif pdata.done_button then
        pdata.done_button = false
        updatePlayerBoardUI(pcol)
      end
      obj.deal(1,pcol)
    else
      log("ERROR: onObjectLeaveContainer() invalid phase to draw cards.  TODO: handle this better")
      return
    end
  end
end
--[[ Set the cube lock status in a player's court. Save setting in player data.
]]
function setLockCourt(pcol, locked)
  if env.trace then log("setLockCourt() "..tostring(pcol)..", "..tostring(locked)) end
  if locked == nil then locked = true end
  local pdata = G.d.players[pcol]
  for _,g in ipairs(pdata.court) do getObjectFromGUID(g).setLock(locked) end
  pdata.court_locked = locked
end
--[[ TODO: Set the cube lock status in a player's provinces. Save setting in player data.
]]
function setLockProvinces(pcol, locked)
  log("--TODO: implement setLockProvinces()")
end
--[[ Return a Caballero cube to the player's court
]]
function returnToCourt(pcol, guid)
  if env.trace then log("returnToCourt() "..tostring(pcol)..", "..tostring(guid)) end
  if contains(G.d.players[pcol].court, guid) then
    log("WARN: returnToCourt() removing "..tostring(guid).." from court for player "..tostring(pcol))   --DEBUG
    table.remove(G.d.players[pcol].court, indexOf(G.d.players[pcol].court,guid))
  end
  local o = getObjectFromGUID(guid)
  assert(o,"returnToCourt() cannot locate object for "..tostring(guid)) --DEBUG
  assert(o.hasTag("Caballero"),"returnToCourt() object "..tostring(guid).." not a Caballero")   --DEBUG
  assert(o.memo == pcol,"returnToCourt() "..tostring(o.memo).." Caballero not owned by "..pcol)   --DEBUG
  local board = getObjectFromGUID(C.player_boards[pcol])
  cleanupCourt(pcol)
  local index = #G.d.players[pcol].court + 1
  if index < 30 then
    o.setLock(false)
    o.setPosition(board.positionToWorld(C.court_pos_l[index]))
    o.setRotation({0,0,0})
    Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
    table.insert(G.d.players[pcol].court, guid)
    G.obj.snaps[guid] = board.positionToWorld(C.court_pos_l[index])
  else
    log("ERROR: returnToCourt() exceeded 30 cubes. "..tostring(pcol)..", "..tostring(guid)) --DEBUG
  end
end
--[[ Reorder cube positions in the court
]]
function cleanupCourt(pcol)
  if env.trace then log("cleanupCourt() "..tostring(pcol)) end
  local pdata = G.d.players[pcol]
  local board = getObjectFromGUID(C.player_boards[pcol])
  for _,g in ipairs(pdata.court) do
    local o = getObjectFromGUID(g)
    o.setLock(false)
    local pos = o.getPosition()
    pos.y = 4
    o.setPosition(pos)
  end
  for i,g in ipairs(pdata.court) do
    local o = getObjectFromGUID(g)
    o.setPosition(board.positionToWorld(C.court_pos_l[i]))
    o.setLock(pdata.court_locked)
    G.obj.snaps[g]=board.positionToWorld(C.court_pos_l[i])
  end
end
--[[ Return a Caballero cube to the player's Provinces
]]
function returnToProvinces(pcol, guid, fast)
  if not(fast) then fast = true end
  if env.trace then log("returnToProvinces() "..tostring(pcol)..", "..tostring(guid)..", fast="..tostring(fast)) end
  if contains(G.d.players[pcol].provinces, guid) then
    log("WARN: returnToProvinces() "..tostring(guid).." already in Provinces for player "..tostring(pcol))   --DEBUG
    return;
  end
  local o = getObjectFromGUID(guid)
  assert(o,"returnToProvinces() cannot locate object for "..tostring(guid))   --DEBUG
  assert(o.hasTag("Caballero"),"returnToProvinces() object "..tostring(guid).." not a Caballero")   --DEBUG
  assert(o.memo == pcol,"returnToProvinces() "..tostring(o.memo).." Caballero not owned by "..pcol)   --DEBUG
  local board = getObjectFromGUID(C.player_boards[pcol])
  -- cleanupCourt(pcol) --TODO: why? probably copy & paste from returnToCourt ;)
  local index = #G.d.players[pcol].provinces + 1
  if index < 30 then
    o.setLock(false)
    o.setPositionSmooth(board.positionToWorld(C.prov_pos_l[index]), false, fast)
    o.setRotation({0,0,0})
    Wait.condition(function() o.setLock(true) end, function() return o.resting end, 5)
    table.insert(G.d.players[pcol].provinces, guid)
    G.obj.snaps[guid] = board.positionToWorld(C.prov_pos_l[index])
  else
    log("ERROR: returnToProvinces() exceeded 30 cubes. "..tostring(pcol)..", "..tostring(guid)) --DEBUG
  end
end
--[[ Reorder cube positions in the court
]]
function cleanupProvinces(pcol)
  if env.trace then log("cleanupProvinces() "..tostring(pcol)) end
  local pdata = G.d.players[pcol]
  local board = getObjectFromGUID(C.player_boards[pcol])
  for _,g in ipairs(pdata.provinces) do
    local o = getObjectFromGUID(g)
    local pos = o.getPosition()
    pos.y = 4
    o.setLock(false)
    o.setPosition(pos)
  end
  for i,g in ipairs(pdata.provinces) do
    local o = getObjectFromGUID(g)
    o.setPosition(board.positionToWorld(C.prov_pos_l[i]))
    o.setLock(pdata.provinces_locked)
  end
end
--[[ Coroutine: flash pending cubes in an action between cube color and White.
  Checks obj to prevent coro from failing if any cube objects go missing
  from being dropped in a container etc.
]]
function flashCubes()
  if env.trace then log("Starting coro flashCubes()") end
  local n = 0
  local flash = false
  local cycles = 0
  while true do
    if n >= env.flasher_rate then
      cycles = cycles + 1
      if cycles > env.flasher_debug_cycles then
        if env.flasher_debug then log("Flasher queue:");log(G.d.action.pending_cubes);cycles=0 end
      end
      for _,g in ipairs(G.d.action.pending_cubes) do
        local o = getObjectFromGUID(g)
        if o then
          if flash then o.setColorTint(Color["White"])
          else o.setColorTint(Color[o.memo]) end
        end
      end
      n=0
      flash = not(flash)
    end
    n=n+1
    coroutine.yield(0)
  end
  return 1
end
--[[ Manage cubes in the action pending_cubes queue.
  See: flashCubes()
  Required parameters:
  action: "add"|"remvoe"|"clear"|"clear_player"
  guid: guid of cube in pending_cubes queue (or player color in case of action == clear_player)
]]
function pendingCubes(action, guid)
  if env.trace then log("pendingCube() "..tostring(action)..", "..tostring(guid)) end
  assert(action,"pendingCube() missing action")  --DEBUG
  if action == "add" then table.insert(G.d.action.pending_cubes, guid)
  elseif action == "remove" then
    local index = indexOf(G.d.action.pending_cubes, guid)
    if index > 0 then table.remove(G.d.action.pending_cubes, index)
    else log("WARN:  pendingCube() "..tostring(guid).." not in pending_cubes queue")  --DEBUG
    end
    local o = getObjectFromGUID(guid)
    if o then o.setColorTint(Color[o.memo])
    else log("WARN:  pendingCube() no object for "..tostring(guid))  --DEBUG
    end
  elseif action == "clear" then
    local temp = simpleDeepCopy(G.d.action.pending_cubes)
    G.d.action.pending_cubes = {}
    for _,g in ipairs(temp) do
      local o = getObjectFromGUID(g)
      if o then o.setColorTint(Color[o.memo]) end
    end
  elseif action == "clear_player" then
    local temp = {}
    for _,g in ipairs(G.d.action.pending_cubes) do
      local o = getObjectFromGUID(g)
      if o and o.memo == guid then table.insert(temp,g) end
    end
    for _,g in ipairs(temp) do pendingCubes("remove", g) end
  else log("WARN: pendingCube() unknown action "..tostring(action))  --DEBUG
  end
end
--[[ Return an object back to it's most recently saved snap position.
      Used extensively throughout the code.
]]
function snapBack(guid)
  if env.trace then log("snapBack() "..tostring(guid)) end
  local pos = G.obj.snaps[guid]
  assert(pos, "snapBack() no snap pos for "..tostring(guid))
  getObjectFromGUID(guid).setPosition(pos)
end
--[[ Return a scoring marker position for the supplied color and score value.
  Will wrap around the board at 50 and again at 100.  Only valid to 150.
  El Grande scores don't go that high.  :)
]]
function getScorePos(color, val)
  if env.trace then log("getScorePos() "..tostring(color)..", "..tostring(val)) end
  assert(val >= 0 and val <= 150, "getScorePos() score value "..tostring(val).." must be between 0 and 150")
  assert(contains({"Blue","Red","Green","Purple","Yellow"},color),"getScorePos() invalid color "..tostring(color))
  if val == 0 then return C.score_marker_start_pos[color] end
  if val > 50 and val <= 100 then val = val - 50
  elseif val > 100 and val <= 150 then val = val - 100
  end
  val = val - 1
  local pos = Vector(C.score_track_first_pos)
  if val < 13 then
    pos.z = pos.z - (C.delta_Z * val)
  elseif val < 37 then
    pos.z = pos.z - (C.delta_Z * 12)
    pos.x = pos.x - (C.delta_X * (val-12))
  else
    pos.z = pos.z - (C.delta_Z * 12)
    pos.x = pos.x - (C.delta_X * (36-12))
    pos.z = pos.z + (C.delta_Z * (val-36))
  end
  return Vector(pos) - Vector(C.marker_offsets[color])
end
--[[ Return score for a region.  Returns a table of Color:Score.
  if 3 players, only return first two scoring levels.
  if 2 players, only return the first scoring level.
  All tied players drop to next lower level of score.
]]
function scoreRegion(region_guid)
  if env.trace then log("scoreRegion() "..tostring(region_guid)) end
  local region = nil
  if region_guid == "castillo" then
    region = G.obj.castillo
  else
    region=G.obj.regions[region_guid]
  end
  -- log("Scoring region "..region.name) --DEBUG
  --rank players
  local rank={}
  for p,d in pairs(region.caballeros) do
    local new = {player=p,val=sizeOf(d)}
    if #rank == 0 then table.insert(rank,{new})
    else
      local f=false
      for i,e in ipairs(rank) do
        if new.val > e[1].val then table.insert(rank,i,{new}); f=true; break
        elseif new.val == e[1].val then table.insert(e,new); f=true; break end
      end
      if not(f) then table.insert(rank,{new}) end
    end
  end
  -- log("Player rank is: ");log(rank) --DEBUG
  --Assign region score levels to players by rank
  --if 3 players, only use first two scoring levels.
  --if 2 players, only use the first scoring level.
  --ties use next lower level of score.
  local result,index,max,grande,king = {},1,3,false,false
  if #G.d.player_order == 3 then max = 2
  elseif #G.d.player_order == 2 then max = 1 end
  while index <= max do
    if not(rank[index]) then break end
    if sizeOf(rank[index]) == 1 then
      local score = region.scoring[index]
      if rank[index][1].val > 0 then
        if index == 1 then
          --determine Home region and/or King bonus
          if region_guid ~= "castillo" and region.grandes[rank[1][1].player] then score=score + 2; grande = true end
          if region_guid ~= "castillo" and region.king then score = score + 2; king = true end
        end
        if region.double_scoring then score = score * 2 end
        local e = {player=rank[index][1].player,caballeros=rank[index][1].val,score=score,grande=grande,king=king,}
        table.insert(result,{e})
      end
      index = index + 1
    else --there is a tie at this rank index
      if index+1 <= max then
        local new = {}
        table.insert(result,{}) --empty row for the tie?
        for _,e in ipairs(rank[index]) do
          local score = region.scoring[index+1]
          if region.double_scoring then score = score * 2 end
          if e.val > 0 then
            table.insert(new,{player=e.player,caballeros=e.val,score=score,})
          end
        end
        if #new > 0 then table.insert(result,new) end
      end
      index = index + 2 --skip a level
    end
  end
  return result
end
--[[ Force reload of all UI elements when somethign isn't showing.
    HACK: Linked to numpad 1 hotkey for the game.
]]
function reloadUI(player_color)
  if env.trace then log("reloadUI() "..tostring(player_color)) end
  local xml = UI.getXml()
  if xml ~= nil and #xml > 0 then UI.setXml(xml)
  else log("Global:reloadUI(): WARN: no global XML found!") end
  local n = 0
  for _,o in ipairs(getAllObjects()) do
    if not(o.hasTag("Caballero")) and not(o.hasTag("Grande")) then
      local xml = o.UI.getXml()
      if xml ~= nil and #xml > 0 then o.UI.setXml(xml); n=n+1 end
    end
  end
  broadcastToAll("All UIs reloaded.")
  log("UIs reloaded for Global and "..tostring(n).." Objects")
end
--[[ Utility to sort the cards in a player's hand.
  NOTE: uses reverse lookup tables to improve performance.
--]]
function sortHand(player_color)
	local cards = {}  -- Table to store the sortable list of cards present in the hand.
	local handPos = {}  -- Table to store the list of card positions in the hand.
	local handObjects = Player[player_color].getHandObjects()  -- Grab the list of cards in the hand.  We'll use this to populate our tables.
  -- Build a reverse lookup table for card index, avoid iteration in sort function
  local i,refCardOrderIndex = 1,{}
  for v,_ in pairs(power_cards) do refCardOrderIndex[v]=i; i=i+1 end
  -- Comparison function used by table.sort()
  local function sortLogic(card1, card2)
  	return refCardOrderIndex[card1.value] < refCardOrderIndex[card2.value]
  end
	-- Populate both tables.
	for i,j in pairs(handObjects) do
		table.insert(cards, j)
		table.insert(handPos, j.getPosition())
	end
	table.sort(cards, sortLogic)  -- Sort the list of cards.
	-- Take the sorted list of cards and apply the list of card positions in order to physically rearrange them.
	for i,j in ipairs(cards) do j.setPosition(handPos[i]) end
end

#include ~/github/tts-el_grande/Constants.ttslua
#include ~/github/tts-el_grande/Cards.ttslua
#include ~/github/tts-lib/Utils.ttslua

--/////////////// DEVELOPMENT STUFFS //////////////////

function getLocalPos(pcol)
  assert(pcol,"getLocalPos(color): Parameter color is mandatory")
  local board = getObjectFromGUID(C.player_boards[pcol])
  local n = 0
  local s = ""
  for _,o in ipairs(Player[pcol].getSelectedObjects()) do
    n=n+1
    local l = board.positionToLocal(o.getPosition())
    s=s.."{"..string.format("%.4f", l.x)..","..string.format("%.4f", l.y)..","..string.format("%.4f", l.x).."},"
    if n==5 then s=s.."\n"; n=0 end
  end
  Notes.setNotes(s)
end

function w2l(list, guid, format)
  local format = format or false
  local o = getObjectFromGUID(guid)
  local s = ""
  local n = 0
  for _,e in ipairs(list) do
    n=n+1
    local l = o.positionToLocal(e)
    if format then
      s=s.."{"..string.format("%.5f", l.x)..","
      s=s..string.format("%.5f", l.y)..","
      s=s..string.format("%.5f", l.z).."},"
    else
      s=s.."{"..tostring(l.x)..","..tostring(l.y)..","..tostring(l.z).."},"
    end
    if n==5 then s=s.."\n"; n=0 end
  end
  Notes.setNotes(s)
end

mb_color = Color.fromString("White")
function colorPick(pcol)
  assert(pcol,"colorPick(player_color): player_color is required")
  Player[pcol].showColorDialog(mb_color,
    function (c, p)
      mb_color = c
      local str = "rgba("..tostring(c.r)..","..tostring(c.g)..","..tostring(c.b)..","..tostring(c.a)..")"
      log(str)
      Notes.setNotes(str)
      getObjectFromGUID("719679").UI.setAttribute("scoreboard_image","color",str)
    end
  )
end

function cardcheck()
  for i=1,4 do
    log("stack "..tostring(i))
    local stack = getObjectFromGUID(C.stacks[i])
    for _,c in ipairs(stack.getObjects()) do
      if not(cards[c.guid]) then
        log("Card "..c.guid.." not defined")
        stack.takeObject({guid=c.guid})
      end
    end
  end
end

g_vals = {10,15,20,25,30,35,40,50,60,63,66,70,75,80,90,93,95,100,110,120,125,130,135,140,145,150,155,160,170,180,0}
function setDeckValues(g)
  local d = getObjectFromGUID(g)
  assert(d, "Unable to get deck object for guid "..tostring(g))
  local data = d.getData()
  assert(#data.ContainedObjects == #g_vals, "Deck size does not match #g_vals")
  for i,e in ipairs(data.ContainedObjects) do e.Value = g_vals[i] end
  local pos = d.getPosition()
  pos.x = pos.x - 4
  spawnObjectData({data=data,position=pos})
end
