--[[

--TODO: document, credits, etc.
--board art: Francesco Neri https://boardgamegeek.com/image/540942/el-grande

  -DONE: get rid of wait.condition over use. Fails rewind/reload
  -TODO: retest Veto now that wait.condition over use is better
  -TODO: get rid of 'ignore_wait' flag when sure that coros are all safe
  -TODO: break up scoring coroutine. Make rewind/reload safe.

  -TODO: remove cube from pending move when placed back in origin region, reset things back to original state wrt that cube and origin region.
  -TODO: destroy unused scoring markers at startup.
  -TODO: create an undo entry that clears scoring history when action that generated it get's undone (special scoring only)
]]
env = {}
env.version = "0.1 Alpha dev"
env.debug = false
env.trace = true
env.trace2 = false
-- env.test_players = {"Blue","Red","Green","Purple","Yellow"}
env.test_players = {"Green","Red","Purple",}
env.in_dev = false --leave some objects interactable for dev purposes.
env.use_saved_data = true
env.ui_dedupe = false --NOTE: EXPERIMENTAL: trying to ignore dupes in UI setAttribute calls.
env.save_stats = false --log save data size every onSave() call.  Noisy.
env.lock_player_cubes = true --false for testing
env.ignore_drop = false --true for testing
env.hide_start_panel = false --for workng on UIs, don't show start panel.
--[[  defaults for game environment settings ]]
env.game_verbose = true
env.short_game = false
env.intrigue_king_exp = false --TODO: future option
env.grandissimo_exp = false --TODO: future option
env.inquisitor_colonies_exp = false --TODO: future expansion
--[[ EXPERIMENTAL cube flasher settings]]
env.flasher_rate = 30 --frames between cube color changes when pending
env.flasher_debug = false -- periodically log flasher state
env.flasher_debug_cycles = 60 --log every flasher_debug_cycles * flasher_rate frames

G = {} --persistent game data
U = {} --persistent UI state

--[[ TTS Load function
]]
function onLoad(saved_data)
  if not(env.in_dev) then getObjectFromGUID(C.board).interactable = false end
  log("*************************************")
  log("Disigner:       TBD")
  log("Artist:         TBD")
  log("Year Released:  1995")
  log("Publisher:      ")
  log("TTS Scripting:  David Veach; 2024")
  log("Version: "..env.version)
  log("*************************************")
  UI.setAttribute("game_version","text","Version "..env.version)

  if env.test_players then
    UI.setAttribute("start_title","text","After all players seated:\n*** Test Players Enabled ***")
    log("WARN: Test players enabled")
  end
  if not(env.in_dev) then
    local o = getObjectFromGUID(C.trash)
    o.interactable = false
    o.setInvisibleTo(Player.getAvailableColors())
  end
  if not(env.use_saved_data) then saved_data = "" end
  if saved_data ~= "" then
    if env.trace then log("Global:onLoad(): loading from saved data") end
    local restored = JSON.decode(saved_data)
    U = restored.U
    G = restored.G
    setRegionXml() --restore region object UIs before replaying UI state
    Wait.frames(function() restoreGame() end, 5)
  else
    if env.trace then log("Global:onload(): initializing a fresh load") end
    --persistent UI state tables
    U.attributes = {}
    U.class = {}
    U.object_attributes = {}
    U.object_class = {}
    --persistent environment vars
    G.env = {}
    G.env.verbose = env.game_verbose
    G.env.short_game = env.short_game
    G.env.intrigue_king_exp = env.intrigue_king_exp
    G.env.grandissimo_exp = env.grandissimo_exp
    G.env.inquisitor_colonies_exp = env.inquisitor_colonies_exp
    --object tables
    G.obj = {}
    G.obj.snaps = {}
    G.obj.snaps[C.king] = getObjectFromGUID(C.king).getPosition()
    for g,_ in pairs(C.mobile_score_boards) do G.obj.snaps[g] = getObjectFromGUID(g).getPosition() end
    G.obj.bid_buttons = simpleDeepCopy(C.order_buttons)
    for _,e in pairs(G.obj.bid_buttons) do --TODO template like I did with regions
      e.selected = false
      e.button_on = false
      e.players = {}
      e.visibility = {}
      e.used = {}
    end
    G.obj.regions = simpleDeepCopy(C.regions_template)
    G.obj.castillo = simpleDeepCopy(C.castillo_template)
    --Game data
    G.d = {}
    G.d.round = 0
    G.d.started = false
    G.d.phase = ""
    G.d.players = {}
    G.d.player_order = {}
    G.d.active_player = ""
    G.d.action_cards = {}
    G.d.action = {}
    resetAction()
    G.d.waitlist = {}
    G.d.status = {}
    G.d.status.waitlist = {}
    --setup start dialog
    UI_setAttribute("verbose","isOn",G.env.verbose)
    UI_setAttribute("short","isOn",G.env.short_game)
    UI_setAttribute("intrique_king","isOn",G.env.intrigue_king_exp)
    UI_setAttribute("grandissimo","isOn",G.env.grandissimo_exp)
    UI_setAttribute("inquisitor_colonies","isOn",G.env.inquisitor_colonies_exp)
    UI_setAttribute("start_pnl","active",true)
    UI_setAttribute("confirm_pnl","visibility","Pink")
    UI_setAttribute("confirm_pnl","active",true)
    --setup region UIs
    setRegionXml()
  end
  updateCastilloUI()
  math.randomseed(os.time())
  --set up a hotkey to trigger UI reload.
  clearHotkeys()
  addHotkey("Reload all UI", function(player_color) reloadUI(player_color) end)
  --start the cube flasher coro
  startLuaCoroutine(Global, "flashCubes")
  if env.hide_start_panel then UI.setAttribute("start_pnl","active",false) end --DEVELOPMENT
end
--[[ Save game state
]]
function onSave()
  local save_data = JSON.encode({U=U,G=G})
  if env.save_stats then
    log("Saved data length: "..tostring(#save_data))
    if env.debug then log(save_data) end
  end
  return save_data
end
--[[ Replapy saved game state. (Mostly UI)]]
function restoreGame()
  if env.trace then log("restoreGame()") end
  --restore Global UI setAttribute()
  for key,value in pairs(U.attributes) do
    local id = Split(key, ':')[1]
    local field = Split(key, ':')[2]
    if not(UI.setAttribute(id, field, value)) then
      log("WARN: restoreGame() unable to setAttribute() "..tostring(id)..", "..tostring(field)..", "..tostring(value))
    end
  end
  --restore object UI setAttribute()
  for key,value in pairs(U.object_attributes) do
    local params = Split(key,":")
    local guid = params[1]
    local id = params[2]
    local field = params[3]
    local obj = getObjectFromGUID(guid)
    assert(obj, "restoreGame() restore object attributes, unable to locate object for guid "..tostring(guid))
    if not(obj.UI.setAttribute(id, field, value)) then
      log("WARN: restoreGame() unable to setAttribute() "..tostring(guid)..":"..tostring(id)..", "..tostring(field)..", "..tostring(value))
    end
  end
  --restore Global UI setClass()
  for id,value in pairs(U.class) do
    if not(UI.setClass(id,value)) then
      log("WARN: restoreGame() unable to setClass() "..tostring(id)..", "..tostring(value))
    end
  end
  --restore object UI setClass()
  for key,value in pairs(U.object_class) do
    local params = Split(key,":")
    local guid = params[1]
    local id = params[2]
    local obj = getObjectFromGUID(guid)
    assert(obj, "restoreGame() restore object classes, unable to locate object for guid "..tostring(guid))
    if not(obj.UI.setClass(id,value)) then
      log("WARN: restoreGame() unable to setClass() "..tostring(guid)..":"..tostring(id)..", "..tostring(value))
    end
  end
  --card buttons do not survive reload.  Need to recreate them.
  if G.d.phase == "actions" then
    for _,g in ipairs(G.d.action_cards) do
      local o = getObjectFromGUID(g)
      if o then
        o.clearButtons()
        local selected = false
        for _,pdata in pairs(G.d.players) do
          if pdata.action_card == g then selected = true; break end
        end
        if not(selected) then o.createButton(C.card_button) end
      end
    end
  end

  if env.hide_start_panel then UI.setAttribute("start_pnl","active",false) end --DEVELOPMENT
end
--[[ Set xml on all the regions and apply attribute data from Constants
  mb: only used during DEVELOPMENT. Set the mb image accordingly if supplied.
      Otherwise UIs are initialized inactive.
--]]
function setRegionXml(mb)
  if env.trace then log("setRegionXml()") end
  if mb then log("setRegionXml(): Testing with mb: "..tostring(mb)) end
  if mb and not(mb == "MB400" or mb == "MB840") then log("ERROR: setRegionXml(mb) mb must be 'MB400'|'MB840'"); return end
  local xml = JSON.decode(C.region_xml)
  for g,d in pairs(C.region_ui) do
    local r = getObjectFromGUID(g)
    local e = getXmlElement("mb_panel",xml)
    for id,val in pairs(d) do
      e.attributes[id]=val
    end
    if mb then
      e.attributes.active = true
      local b = getXmlElement("mb_image",xml)
      b.attributes.image = mb
    else
      e.attributes.active = false
    end
    r.UI.setXmlTable(xml)
  end
end
--[[ TODO: TESTING ignoring dupes in UI wrapper calls. Cut down UI overhead.
  Need to do some stats testing to see if it is dropping any updates needed.
  NOTE: for setAttribute only, not for setClass. ]]
--[[  Wrapper function for saving Global UI attributes for game restore. ]]
function UI_setAttribute(id, field, value)
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  if env.ui_dedupe and U.attributes[id..":"..field] == value then return end
  if env.trace2 then log("UI_setAttribute(): "..tostring(id)..", "..tostring(field)..", "..tostring(value)) end
  UI.setAttribute(id, field, value)
  U.attributes[id..":"..field] = value
end
--[[  Wrapper function for saving Global UI setClass for game restore.
]]
function UI_setClass(id, value)
  assert(type(id) == "string", "UI_setClass(): id must be a string")
  assert(type(value) == "string", "UI_setClass(): value must be a string")
  -- if U.class[id] == value then log("skip class "..id) return end
  if env.trace2 then log("UI_setClass() "..tostring(id)..", "..tostring(value)) end
  UI.setClass(id, value)
  U.class[id] = value
end
--[[  Wrapper function for saving Global UI setClass for game restore.
]]
function object_UI_setClass(guid, id, value)
  assert(guid, "object_UI_setClass(): missing guid")
  assert(type(id) == "string", "object_UI_setClass(): id must be a string")
  assert(type(value) == "string", "object_UI_setClass(): value must be a string")
  local obj = getObjectFromGUID(guid)
  assert(obj, "object_UI_setAttribute() unable to locate object for guid "..tostring(guid))
  -- if U.object_class[guid..":"..id] == value then log("skip class "..guid..":"..id) return end
  if env.trace2 then log("UI_setClass() "..tostring(id)..", "..tostring(value)) end
  obj.UI.setClass(id, value)
  U.object_class[guid..":"..id] = value
end
--[[  Wrapper function for saving object UI attributes for game restore.
]]
function object_UI_setAttribute(guid, id, field, value)
  assert(guid, "object_UI_setAttribute(): missing guid")
  assert(type(id) == "string", "object_UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "object_UI_setAttribute(): field must be a string")
  assert(value ~= nil, "object_UI_setAttribute(): missing value for id "..tostring(id)..", field "..tostring(field))
  local obj = getObjectFromGUID(guid)
  assert(obj, "object_UI_setAttribute() unable to locate object for guid "..tostring(guid))
  if env.ui_dedupe and U.object_attributes[guid..":"..id..":"..field] == value then return end
  if env.trace2 then log("object_UI_setAttribute() "..tostring(guid)..", "..tostring(id)..", "..tostring(field)..", "..tostring(value)) end
  obj.UI.setAttribute(id, field, value)
  U.object_attributes[guid..":"..id..":"..field] = value
end

-- ////////////// Game logic ////////////////////////

--[[ Set up the game environment.
]]
function setupGame(player, button, id)
  if env.trace then log("setupGame() "..player.color..", "..tostring(id)) end
  UI_setAttribute("start_pnl","active",false)
  for i=1,4 do
    local g = C.stacks[i]
    local stack = getObjectFromGUID(g)
    assert(stack, "setupGame() missing card stack for guid "..tostring(g))
    stack.shuffle()
  end
  -- setup players
  local seated = getSeatedPlayers()
  if env.test_players then seated = env.test_players
  elseif #seated < 2 then
    broadcastToAll("At least 2 players required to play this game")
    return
  end
  local plist="Pink"
  local n = math.random(#C.table_order)
  for i=1,#C.table_order do
    local pcol = C.table_order[n]
    if contains(seated,pcol) then
      plist=plist.."|"..pcol
      table.insert(G.d.player_order,pcol)
      G.d.players[pcol] = {
        score = 0,  --TODO more detailed stats for a cool end game report?
        grande = "",
        start_caballeros = {},
        caballeros = {},
        provinces = {},
        court = {},
        active = false,
        undo_button = false,
        allow_undo = true,  --some actions will not allow an undo
        done_button = false,
        show_disk = true,
        allowed_regions = {},
        disk_button = true,
        selected_region = math.random(1,9),
        court_locked = true,
        provinces_locked = true,
        action_card = "",
      }
      if not(G.env.intrigue_king_exp) then getObjectFromGUID(C.decks[pcol]).destruct() end
    else
      --delete all unused items for non-player colors
      getObjectFromGUID(C.decks[pcol]).destruct()
      getObjectFromGUID(C.player_boards[pcol]).destruct()
    end
    if n == #C.table_order then n=1 else n=n+1 end
  end
  G.d.visibility_all = plist
  if not(G.env.intrigue_king_exp) then
    getObjectFromGUID(C.caballero_deck).destruct()
    getObjectFromGUID(C.intrique_setup_card).destruct()
  end
  --setup bid buttons
  for g,e in pairs(G.obj.bid_buttons) do
    e.players = simpleDeepCopy(G.d.player_order)
    e.visibility = simpleDeepCopy(G.d.player_order)
  end
  object_UI_setAttribute(C.board, "regions","active",true)
  object_UI_setAttribute(C.castillo,"info","active",true)
  -- UI_setAttribute("scoring_pnl","visibility",G.d.visibility_all)
  UI_setAttribute("scoring_pnl","active",true)
  UI_setAttribute("scoring_pnl","visibility","Pink")
  UI_setAttribute("confirm_pnl","visibility","Pink")
  UI_setAttribute("confirm_pnl","active",true)
  startLuaCoroutine(Global, "createPlayerCubes")
  G.d.started = true
end
--[[ Create player cubes and place them.
  Runs in a coro to yield between spawn calls.  Not entirely necessary
  but I like the visual effect it creates. :)
]]
function createPlayerCubes()
  if env.trace then log("createPlayerCubes()") end
  for _,pcol in ipairs(G.d.player_order) do
    local pdata = G.d.players[pcol]
    local board = getObjectFromGUID(C.player_boards[pcol])
    --Grande
    local sd = {
      position = board.positionToWorld(Vector(C.start_pos_l[1])),
      rotation = Vector(0,0,0),
    }
    sd.data = JSON.decode(C.grande_json)
    sd.callback_function = function(o)
      o.setName(pcol.." Grande")
      o.setColorTint(Color[pcol])
      o.memo = pcol
      o.setLock(env.lock_player_cubes)
      pdata.grande = o.getGUID()
      G.obj.snaps[o.getGUID()] = o.getPosition()
    end
    spawnObjectData(sd)
    coroutine.yield(0)
    --Province Caballeros
    sd.data = JSON.decode(C.caballero_json)
    sd.callback_function = function(o)
      o.setName(pcol.." Caballero")
      o.setColorTint(Color[pcol])
      o.memo = pcol
      o.setLock(env.lock_player_cubes)
      table.insert(pdata.caballeros, o.getGUID())
      table.insert(pdata.provinces, o.getGUID())
      G.obj.snaps[o.getGUID()] = o.getPosition()
    end
    -- Province Caballeros
    for i=1,21 do
      sd.position = board.positionToWorld(Vector(C.prov_pos_l[i]))
      spawnObjectData(sd)
      coroutine.yield(0)
    end
    --Court Caballeros
    sd.callback_function = function(o)
      o.setName(pcol.." Caballero")
      o.setColorTint(Color[pcol])
      o.memo = pcol
      o.setLock(env.lock_player_cubes)
      table.insert(pdata.caballeros, o.getGUID())
      table.insert(pdata.court, o.getGUID())
      G.obj.snaps[o.getGUID()] = o.getPosition()
    end
    for i=1,7 do
      sd.position = board.positionToWorld(Vector(C.court_pos_l[i]))
      spawnObjectData(sd)
      coroutine.yield(0)
    end
    --Starting Caballeros
    sd.callback_function = function(o)
      o.setName(pcol.." Caballero")
      o.setColorTint(Color[pcol])
      o.memo = pcol
      o.setLock(env.lock_player_cubes)
      table.insert(pdata.caballeros, o.getGUID())
      table.insert(pdata.start_caballeros, o.getGUID())
      G.obj.snaps[o.getGUID()] = o.getPosition()
    end
    sd.position = board.positionToWorld(Vector(C.start_pos_l[2]))
    spawnObjectData(sd)
    coroutine.yield(0)
    sd.position = board.positionToWorld(Vector(C.start_pos_l[3]))
    spawnObjectData(sd)
    coroutine.yield(0)
  end
  local c = 0
  while c < 30 do c=c+1; coroutine.yield(0) end
  startPlacementPhase()
  return 1
end
--[[ Setup for bidding on initial placement.
]]
function startPlacementPhase()
  if env.trace then log("startPlacementPhase()") end
  G.d.phase = "placement"
  --randomly place the king
  local kings_region = math.random(1,9)
  local g = C.region_guids[kings_region]
  local king = getObjectFromGUID(C.king)
  king.setPosition(C.region_start_info[g].king)
  king.setLock(false)
  if setKing(g) then G.obj.snaps[king.getGUID()]=king.getPosition()
  else log("WARN: startPlacementPhase() king region not set") end --DEBUG
  --set up each player's allowed disk selections
  local allowed = {}
  for i,g in ipairs(C.region_guids) do
    local r = G.obj.regions[g]
    if not(r.king) then table.insert(allowed,r.scoring_order) end
  end
  --set up the selection dialog
  G.d.waitlist = simpleDeepCopy(G.d.player_order)
  G.d.status = {}
  G.d.status.info = "Initial Placement Selection"
  G.d.status.info = G.d.status.info.."\nSecretly select starting region for"
  G.d.status.info = G.d.status.info.."\nGrande and 2 starting Caballeros"
  G.d.status.waitlist = {}
  for i=1,5 do
    if i <= #G.d.player_order then
      local pcol = G.d.player_order[i]
      object_UI_setAttribute(C.player_boards[pcol],"button_pnl","active",true)
      table.insert(G.d.status.waitlist,{player_color=pcol,player_status="Deciding"})
      G.d.players[pcol].active = true
      G.d.players[pcol].waiting = true
      G.d.players[pcol].done_button = true
      G.d.players[pcol].show_disk = true
      G.d.players[pcol].allowed_regions = simpleDeepCopy(allowed)
      G.d.players[pcol].selected_region = allowed[math.random(#allowed)]
      updatePlayerBoardUI(pcol)
    end
  end
  G.d.status.show = true
  updateStatusUI(G.d.status)
end
--[[ Place Grande and 2 starting Caballeros in the Regions
    selected for each player.
]]
function placeStartingCubes()
  if env.trace then log("placeStartingCubes()") end
  for _,pcol in ipairs(G.d.player_order) do
    local pdata = G.d.players[pcol]
    local region_guid = C.region_guids[pdata.selected_region]
    local grande = getObjectFromGUID(pdata.grande)
    grande.setLock(false)
    grande.setPosition(C.region_start_info[region_guid].grande[pcol])
    G.obj.snaps[pdata.grande] = grande.getPosition()
    setGrande(region_guid, pcol)
    --place starting caballeros
    local delta_x = {0.28, -0.32}
    local delta_z = 1.15
    for i,g in ipairs(pdata.start_caballeros) do
      local o = getObjectFromGUID(g)
      o.setLock(false)
      local pos = grande.getPosition()
      pos.x = pos.x - delta_x[i]
      pos.z = pos.z - delta_z
      o.setPosition(pos)
      G.obj.snaps[g] = o.getPosition()
      addCaballero(pcol, region_guid, pcol, g)
    end
    pdata.start_caballeros = nil
  end
end
--[[ Setup and begin the order bidding phase
]]
function startBidPhase()
  if env.trace then log("startBidPhase()") end
  G.d.phase = "bidding"
  if G.env.verbose then broadcastToAll("In current turn order players select action order bids") end
  G.d.players_to_bid = simpleDeepCopy(G.d.player_order)
  G.d.status = {}
  G.d.status.waitlist = {}
  G.d.status.info = "Turn order bidding phase:\nIn the following player order\nchoose an available bid number"
  G.d.active_player = G.d.player_order[1]
  for i,pcol in ipairs(G.d.player_order) do
    local pdata = G.d.players[pcol]
    local s = ""
    if pcol == G.d.active_player then s = "Active" end
    table.insert(G.d.status.waitlist,{player_color=pcol,player_status=s})
    pdata.active = pcol == G.d.active_player
    pdata.done = false
    pdata.waiting = false
    pdata.undo_button = false
    pdata.done_button = false
    pdata.show_disk = false
    pdata.bid_button = nil
    updatePlayerBoardUI(pcol)
  end
  G.d.status.show = true
  updateStatusUI(G.d.status)
  -- Move round marker
  G.d.round = G.d.round + 1
  if G.env.short_game then
    if G.d.round == 1 then G.d.round = 2
    elseif G.d.round == 4 then G.d.round = 5
    elseif G.d.round == 7 then G.d.round = 8
    end
  end
  local marker = getObjectFromGUID(C.round_marker)
  marker.setPosition(C.round_marker_positions[G.d.round])
  -- Check to see if veto card has expired
  if G.d.veto_round and G.d.round - G.d.veto_round >= 2 then
    local card = getObjectFromGUID(G.d.players[G.d.veto].veto_card)
    assert(card, "startBidPhase(): unable to locate veto card object")
    getObjectFromGUID(C.trash).putObject(card)
    G.d.players[G.d.veto].veto_card = nil
    G.d.veto = nil
    G.d.veto_round = nilm
  end
  -- Reveal Action Cards
  if #G.d.action_cards > 0 then
    -- trash all remaining cards except the King card
    local trash = getObjectFromGUID(C.trash)
    for _,g in ipairs(G.d.action_cards) do
      -- if g ~= C.stacks[5] then getObjectFromGUID(g).destruct() end
      local o = getObjectFromGUID(g)
      o.setLock(false)
      if g ~= C.stacks[5] then trash.putObject(o) end
    end
  end
  G.d.action_cards = {}
  for i=1,4 do
    local stack = getObjectFromGUID(C.stacks[i])
    local pos = stack.getPosition()
    pos.y = pos.y + 3
    local card = stack.takeObject({
      position=pos,
      flip=true,
      callback_function = function(o)
        Wait.condition(function() o.setLock(true) end, function() return o.resting end)
      end
    })
    table.insert(G.d.action_cards, card.getGUID())
  end
  local king_card = getObjectFromGUID(C.stacks[5])
  if king_card.resting and king_card.is_face_down then
    king_card.setLock(false)
    king_card.flip()
    Wait.condition(function() king_card.setLock(true) end, function() return king_card.resting end)
  end
  table.insert(G.d.action_cards, king_card.getGUID())
  -- Activate bid buttons
  for g,d in pairs(G.obj.bid_buttons) do
    d.button_on = true
    d.selected = false
    if indexOf(d.players,G.d.active_player) > 0 then
      d.visibility = {G.d.active_player}
    else
      d.visibility = {}
    end
    updateOrderButtonUI(g,d)
  end
end
--[[ Return action data to initial state
--]]
function resetAction()
  if env.trace then log("resetAction()") end
  G.d.action = {
    stage= "",              --"main" | "court" | "special", keys to undo tables
    guid = "",              --card guid
    player = "",            --active player
    opponents = {},         --active player's opponents
    court = 0,              --number of Court Caballeros that can move to Regions
    special = {},           --table of allowed actions ("move_king", "move_grande", etc.)
    description = "",       --description of the action
    pending_cubes = {},     --cubes that have been moved in this action stage (see flasher)
    caballeros = 0;         --caballeros to move
    caballeros_moved = 0;   --caballeros moved so far
    undo = {main={},court={},special={},reset=true},
    flags = {},             --TODO: used???
    stages = {},            --usually {"special, court"}, different if played from hand (delayed) where court previously done
    stage_status = "",      --status of the current action stage when not "main"
    ui = {},                --TODO: used???  no using status instead
    status = {waitlist={},} --TODO: clean up the naming.  waitlist -> players  status->hud or something like that.
  }
end
--[[ Setup and begin the action phase
]]
function startActionPhase()
  if env.trace then log("startActionPhase()") end
  G.d.phase = "actions"
  resetAction()
  -- set player order from highest to lowest bid
  local temp = {}
  for i=13,1,-1 do
    local d = G.obj.bid_buttons[C.button_guids[i]]
    if d.selected then
      table.insert(temp,d.selected)
      G.d.players[d.selected].p2c = d.court
    end
    d.button_on = false
  end
  assert(#temp == #G.d.player_order, "FATAL: startActionPhase() uable to build new player order from selected bids") --DEBUG
  G.d.player_order = temp
  G.d.active_player = G.d.player_order[1]
  G.d.players_to_play = simpleDeepCopy(G.d.player_order)
  G.d.status = {}
  G.d.status.waitlist = {}
  G.d.status.info = "Actions Phase:\nIn the following turn order\nchoose an action card to play"
  -- G.d.status.info = G.d.status.info.."\nCaballeros move Court -> Region"
  G.d.active_player = G.d.player_order[1]
  for i,pcol in ipairs(G.d.player_order) do
    local pdata = G.d.players[pcol]
    local s = ""
    if pcol == G.d.active_player then s = "Active" end
    table.insert(G.d.status.waitlist,{player_color=pcol,player_status=s})
    pdata.active = pcol == G.d.active_player
    pdata.done = false
    pdata.waiting = pcol ~= G.d.active_player
    pdata.undo_button = false
    pdata.allow_undo = true
    pdata.done_button = false
    pdata.show_disk = false
    updatePlayerBoardUI(pcol)
    -- Move Caballeros from Province to Court based on player's order button selection.
    local board = getObjectFromGUID(C.player_boards[pcol])
    for i=1,pdata.p2c do
      if #pdata.provinces > 0 then
        local o = getObjectFromGUID(pdata.provinces[#pdata.provinces])
        table.insert(pdata.court, o.getGUID())
        o.setPosition(board.positionToWorld(C.court_pos_l[#pdata.court]))
        G.obj.snaps[o.getGUID()] = o.getPosition()
        table.remove(pdata.provinces, #pdata.provinces)
      end
    end
  end
  G.d.status.show = true
  updateStatusUI(G.d.status)
  -- Activate buttons on action cards
  for i,g in ipairs(G.d.action_cards) do getObjectFromGUID(g).createButton(C.card_button) end
end
--[[ Process an option selected by the player during actions.
]]
function processAction(pcol, opt)
  if env.trace then log("processAction() "..tostring(pcol)..", "..tostring(opt)) end
  local pdata = G.d.players[pcol]
  local a = G.d.action
  a.ignore_wait = false  --TODO: no coro (remove when all coro's safe)
  if opt == "court" then
    if a.stage == "main" then
      setLockCourt(pcol, false)
      a.stage="court"
      a.description = "Move from Court"
      pdata.disable_reset = false
      updatePlayerBoardUI(pcol)
    else
      log("ERROR: incorrect stage for special: "..tostring(a.stage)); return   --DEBUG
    end
  elseif opt == "special" then
    if a.stage == "main" then
      a.description = cards[a.guid].description
      if not(a.description) then a.description = "Special Action" end
      if a.special.immediate and a.special.id ~= "special_scoring" then
        if G.d.veto and G.d.veto ~= pcol then
          if not(G.d.veto_declined) then
            log("---TESTING: activate veto check for an immediate special action")
            G.d.confirm_lock = true
            UI_setAttribute("veto_msg_txt", "text", "Veto "..a.name.." ?")
            UI_setAttribute("veto_pnl","active",true)
            return
          else
            log("---TESTING: continue with immediate special action after veto declined")
            G.d.veto_declined = nil
          end
        end
      end
      a.stage = "special"
      local desc = a.special.desc
      if not(desc) then desc = "Special Action" end
      a.stage_status = desc
      if a.special.id == "ret2provinces" then
        if a.special.disk then
          a.stage = "waiting"
          a.waitlist = simpleDeepCopy(a.opponents)
          a.status = {waitlist={},}
          local remove = {}
          for _,c in ipairs(a.waitlist) do
            local p = G.d.players[c]
            p.allowed_regions = {}
            if a.special.count then --allow regions with count or more caballeros
              for i,g in ipairs(C.region_guids) do
                local r = G.obj.regions[g]
                if not(r.king) and sizeOf(r.caballeros[c]) >= a.special.count then table.insert(p.allowed_regions,r.scoring_order) end
              end
            end
            if #p.allowed_regions == 0 then --allow any region with 1 or more caballeros
              for i,g in ipairs(C.region_guids) do
                local r = G.obj.regions[g]
                if not(r.king) and sizeOf(r.caballeros[c]) >= 1 then table.insert(p.allowed_regions,r.scoring_order) end
              end
            end
            if #p.allowed_regions == 0 then
              table.insert(remove,c) --player meets no criteria for selection
            else
              p.selected_region = p.allowed_regions[math.random(1,#p.allowed_regions)]
              table.insert(a.status.waitlist,{player_color=c,player_status="Deciding"})
              p.active = true
              p.waiting = true
              p.show_disk = true
              p.disk_button = true
              p.undo_button = false
              p.done_button = true
              p.action_ui = false
              updatePlayerBoardUI(c)
            end
          end
          for _,c in ipairs(remove) do table.remove(a.waitlist,indexOf(a.waitlist,c)) end
          if #a.waitlist > 0 then
            a.undo.special[a.special.id]={id=a.special.id, opp=simpleDeepCopy(a.waitlist),}
            a.status.info = "Provinces:\nOpponents select secretly\nReturn -> Provinces"
            a.status.show = true
            updateStatusUI(a.status)
            a.stage = "waiting"
            a.stage_status = "Waiting on opp"
            a.allow_veto = true
            a.waiting = #a.waitlist
          else
            log("WARN: ret2provinces: no opponents have Caballeros elegible to return")
            a.status.info = "Provinces:\nActive Player\nSelect an action"
            a.status.waitlist = {}
            a.status.show = true
            updateStatusUI(a.status)
            a.special_completed = true
            a.stage_status = "No opp met req"
            a.stage = "special"
          end
          pdata.disable_reset = false
          pdata.allow_undo = false
          pdata.undo_button = false
          pdata.done_button = false
          pdata.action_ui = true
          updatePlayerBoardUI(pcol)
        else
          if a.special.each then
            a.caballeros_moved = {}
            if a.special.all then for _,c in ipairs(G.d.player_order) do a.caballeros_moved[c]=0 end
            else for _,c in ipairs(a.opponents) do a.caballeros_moved[c]=0 end end
            local remove = {}
            for c,_ in pairs(a.caballeros_moved) do
              local valid = false
              for _,rd in pairs(G.obj.regions) do if sizeOf(rd.caballeros[c]) > 1 then valid = true; break end end
              if not(valid) then table.insert(remove, c) end
            end
            for _,c in ipairs(remove) do a.caballeros_moved[c] = nil end
            a.total_max = sizeOf(a.caballeros_moved) * a.special.count
            a.total_moved = 0
            a.stage_status = "Moved 0 / "..tostring(a.total_max)
          else
            log("ERROR: processAction(): ret2provinces, single caballeros_moved counter not yet supported")
            return
          end
          pdata.disable_reset = false
          pdata.allow_undo = true
          pdata.undo_button = false
          pdata.done_button = false
          pdata.action_ui = true
          updatePlayerBoardUI(pcol)
        end
      elseif a.special.id == "prov2court" then
        log("executing immediate special "..a.special.id)
        local board = getObjectFromGUID(C.player_boards[pcol])
        a.caballeros_moved = 0
        for i=1,a.special.count do
          if #pdata.provinces > 1 then
            local o = getObjectFromGUID(pdata.provinces[#pdata.provinces])
            o.setLock(false)
            local pos = C.court_pos_l[#pdata.court+1]
            o.setPosition(board.positionToWorld(pos))
            o.setRotation({0,0,0})
            table.insert(pdata.court,o.getGUID())
            table.remove(pdata.provinces,indexOf(pdata.provinces,o.getGUID()))
            Wait.condition(function() o.setLock(true) end, function() return o.resting end)
            G.obj.snaps[o.getGUID()] = pos
            a.undo.special[o.getGUID()] = {id="prov2court", pcol=pcol, g=o.getGUID()}
            a.caballeros_moved = a.caballeros_moved + 1
          end
        end
        a.allow_veto = false
        a.stage_status = "Moved "..tostring(a.caballeros_moved).." to Court"
        a.special_completed = true
        pdata.undo_button = true
        pdata.allow_undo = true
        pdata.done_button = true
        pdata.action_ui = true
        updatePlayerBoardUI(pcol)
      elseif a.special.id == "grande" then
        log("move Grande")
        a.stage_status = "Move your Grande"
        a.allow_veto = true
        a.status.waitlist = {}
        a.status.info = a.name..":\n"..a.description
        updateStatusUI(a.status)
        updatePlayerBoardUI(pcol)
      elseif a.special.id == "special_scoring" then
        log("executing special scoring "..a.special.id)
        if a.special.castillo then
          a.allow_veto = false
          pdata.undo_button = false
          pdata.done_button = false
          pdata.action_ui = false
          updatePlayerBoardUI(pcol)
          startScoring({"castillo"},true,"[Castillo,]")
        elseif a.special.region_score then
          local regions = {}
          local s = "Regions: ["
          if type(a.special.region_score) == "number" then
            if G.obj.castillo.scoring[1] == a.special.region_score then
              table.insert(regions,"castillo")
              s = s.."Castillo,"
            end
            for _,r in pairs(G.obj.regions) do
              if r.scoring[1] == a.special.region_score then
                table.insert(regions,r.scoring_order)
                s = s..tostring(r.scoring_order)..","
              end
            end
          elseif type(a.special.region_score) == "table" then
            if contains(a.special.region_score, G.obj.castillo.scoring[1]) then
              table.insert(regions,"castillo")
              s = s.."Castillo,"
            end
            for _,r in pairs(G.obj.regions) do
              if contains(a.special.region_score, r.scoring[1]) then
                table.insert(regions,r.scoring_order)
                s = s..tostring(r.scoring_order)..","
              end
            end
          end
          s = s .. "]"
          if #regions > 0 then
            a.allow_veto = false
            pdata.undo_button = false
            pdata.done_button = false
            pdata.action_ui = false
            updatePlayerBoardUI(pcol)
            startScoring(regions,true,s)
          end
        elseif a.special.secret then
          a.stage = "waiting"
          a.status = {waitlist={},}
          a.status.info = a.name.."\n"..a.special.desc
          a.allow_veto = true
          local undo_ok = false
          if a.special.players == "all" then a.waitlist = simpleDeepCopy(G.d.player_order)
          elseif a.special.players == "active" then a.waitlist={G.d.active_player}; undo_ok = true end
          --Show players disk
          for _,pcol in ipairs(a.waitlist) do
            local pdata = G.d.players[pcol]
            pdata.allowed_regions = {1,2,3,4,5,6,7,8,9,}
            table.insert(a.status.waitlist,{player_color=pcol,player_status="Deciding"})
            pdata.active = true
            pdata.waiting = true
            pdata.show_disk = true
            pdata.disk_button = true
            pdata.undo_button = false
            pdata.done_button = true
            pdata.action_ui = undo_ok
            updatePlayerBoardUI(pcol)
          end
          a.status.show = true
          updateStatusUI(a.status)
          a.waiting = #a.waitlist
        elseif a.special.most_caballeros or a.special.least_caballeros then
          --NOTE: castillo is not considered
          local temp = nil
          for _,r in pairs(G.obj.regions) do
            local n = 0
            for _,p in ipairs(G.d.player_order) do n = n + sizeOf(r.caballeros[p]) end
            if n > 0 then
              local new = {r=r.scoring_order,n=n}
              if not(temp) then
                temp = {new}
              else
                if a.special.most_caballeros and new.n > temp[1].n then temp = {new}
                elseif a.special.least_caballeros and new.n < temp[1].n then temp = {new}
                elseif new.n == temp[1].n then table.insert(temp,new) end
              end
            end
          end
          if #temp > 0 then
            local regions = {}
            local s = "Regions: ["
            for _,e in ipairs(temp) do table.insert(regions,e.r); s = s .. tostring(e.r).."," end
            s = s .. "]"
            a.allow_veto = false
            pdata.undo_button = false
            pdata.done_button = false
            pdata.action_ui = false
            updatePlayerBoardUI(pcol)
            startScoring(regions,true,s)
          else
            a.stage_status = "No regions to score"
            a.special_completed = true
            a.stage = "special"
            pdata.disable_reset = false
            pdata.allow_undo = true
            pdata.undo_button = true
            pdata.done_button = true
            pdata.action_ui = true
            updatePlayerBoardUI(pcol)
          end
        elseif a.special.first_only then
          log("special scoring: first_only")
          a.allow_veto = false
          pdata.undo_button = false
          pdata.done_button = false
          pdata.action_ui = false
          updatePlayerBoardUI(pcol)
          startScoring({"first_only"}, true, "1st level of all Regions")
        else
          log("WARN: processAction() unknown special_scoring action")
        end
      elseif Split(a.special.id,"_")[1] == "move" then
        log("move special action")
        a.allow_veto = true
        if a.special.each then a.caballeros_moved = {Blue=0,Red=0,Green=0,Purple=0,Yellow=0} end
        if a.special.total then a.total_moved = 0; a.stage_status = "Moved 0 / "..tostring(a.special.total)
        elseif a.special.max then a.stage_status = "Moved 0 / "..tostring(a.special.max)
        else a.stage_status = "Moved 0" end
        if a.special.max_opp then a.opp_moved = 0 end
        if a.special.max_own then a.own_moved = 0 end
        if a.special.court_ok then setLockCourt(pcol, false) end
        a.status.waitlist = {}
        a.status.info = a.name..":\n"..a.description
        updateStatusUI(a.status)
        updatePlayerBoardUI(pcol)
      elseif a.special.id == "court_2_prov" then
        log("executing immediate special "..a.special.id)
        for _,p in ipairs(a.opponents) do
          local pdata = G.d.players[p]
          local board = getObjectFromGUID(C.player_boards[p])
          local n = 0
          for _,g in ipairs(pdata.court) do
            if a.special.count and n >= a.special.count then break end
            local o = getObjectFromGUID(g)
            o.setLock(false)
            local pos = board.positionToWorld(C.prov_pos_l[#pdata.provinces+1])
            o.setPosition(pos)
            G.obj.snaps[g]=pos
            table.insert(pdata.provinces,g)
            table.remove(pdata.court,indexOf(pdata.court,g))
            Wait.condition(function() o.setLock(true) end, function() return o.resting end)
            a.undo.special[o.getGUID()] = {id="court2prov", pcol=p, g=o.getGUID()}
            n=n+1
          end
          cleanupCourt(p)
        end
        a.special_completed = true
        a.stage_status = "Special completed"
        a.stage = "special"
        pdata.disable_reset = false
        pdata.allow_undo = true
        pdata.undo_button = true
        pdata.done_button = true
        pdata.action_ui = true
        updatePlayerBoardUI(pcol)
      elseif a.special.id == "restore_bid" then
        log("special action: restore_bid")
        a.stage = "waiting"
        a.status.info = "Power Cards:\nActive player select a used\nused power bid to restore"
        a.status.waitlist = {}
        updateStatusUI(a.status)
        a.stage_status = "Pick a used bid"
        pdata.disable_reset = false
        pdata.allow_undo = true
        pdata.undo_button = false
        pdata.done_button = true
        pdata.action_ui = true
        updatePlayerBoardUI(pcol)
        --enable buttons on used bid tokens
        for g,button_data in pairs(G.obj.bid_buttons) do
          if indexOf(button_data.used,pcol) > 0 then
            button_data.button_on = true
            button_data.visibility = {pcol}
            updateOrderButtonUI(g,button_data)
          end
        end
      elseif a.special.id == "2_court_or_all_in_1" then
        setLockCourt(pcol,false)
      elseif a.special.id == "mobile_score_board" then
        a.score_boards = {}
        for g,_ in pairs(C.mobile_score_boards) do
          local locked = false; for _,r in pairs(G.obj.regions) do
            if r.score_board == g and r.king then locked = true; break end
          end
          if not(locked) then getObjectFromGUID(g).setLock(false); table.insert(a.score_boards, g) end
        end
        a.status.waitlist = {}
        a.status.info = a.name..":\n"..a.description
        updateStatusUI(a.status)
        updatePlayerBoardUI(pcol)
      elseif a.special.id == "king_returns" then
        log("setup king returns")
        a.stage = "waiting"
        a.stage_status = "Opp 3 -> Prov"
        a.status = {}
        a.status.info = "Opponents ret 3 to Provinces\nfrom Court or Regions\nDrop on player board"
        --setup opponents in table order (clockwise) starting to left of active player
        a.waitlist = {}
        local n = indexOf(C.table_order, G.d.active_player)
        for i=1,#C.table_order-1 do
          n = n + 1; if n > #C.table_order then n = 1 end
          if indexOf(a.opponents, C.table_order[n]) > 0 then table.insert(a.waitlist, C.table_order[n]) end
        end
        a.status.waitlist = {}
        a.caballeros_moved = {}
        for i,p in ipairs(a.waitlist) do
          local pd = G.d.players[p]
          if i==1 then table.insert(a.status.waitlist,{player_color=p,player_status="Deciding"})
          else table.insert(a.status.waitlist,{player_color=p,player_status=""}) end
          a.caballeros_moved[p]=0
          pd.active = i == 1
          pd.waiting = true
          pd.show_disk = false
          pd.disk_button = false
          pd.undo_button = false
          pd.done_button = false
          pd.action_ui = false
          updatePlayerBoardUI(p)
          setLockCourt(p, false)
        end
        a.waiting = #a.waitlist
        a.status.show = true
        pdata.done_button = false
        updateStatusUI(a.status)
      elseif a.special.id == "king" then
        log("move the king")
        a.allow_veto = true
        a.status.waitlist = {}
        a.status.info = a.name..":\n"..a.description
        updateStatusUI(a.status)
        updatePlayerBoardUI(pcol)
      elseif a.special.id == "evict" then
        log("special action 'Evict'")
        a.stage = "waiting"
        a.status.waitlist={}
        a.status.info = "Evict: Active Player\nSelect a region\nto evict opponents"
        table.insert(a.status.waitlist,{player_color=pcol,player_status="Deciding"})
        updateStatusUI(a.status)
        local pdata = G.d.players[pcol]
        pdata.active = true
        pdata.waiting = true
        pdata.show_disk = true
        pdata.disk_button = true
        pdata.show_stage = false
        pdata.allowed_regions = {}
        for i,g in ipairs(C.region_guids) do if not(G.obj.regions[g].king) then table.insert(pdata.allowed_regions,i) end end
        pdata.undo_button = false
        pdata.done_button = true
        pdata.action_ui = true
        updatePlayerBoardUI(pcol)
        a.waitlist = {pcol}
        a.waiting = 1
        a.special.disk = true
        a.special.evict_stage = 1
      else
        log("ERROR: processAction() unhandled special id"); return --DEBUG
      end
    else
      log("ERROR: incorrect stage for special: "..tostring(a.stage)); return   --DEBUG
    end
  elseif opt == "finished" then
    if a.stage == "court" then
      for _,g in ipairs(a.pending_cubes) do
        local i = indexOf(pdata.court, g); if i > 0 then table.remove(pdata.court, i) end
      end
      a.court_completed = true
      a.undo.main["court"]={id="court_completed"}
    elseif a.stage == "special" or a.stage == "waiting" then
      a.special_completed = true
      if pdata.allow_undo then a.undo.main["special"]={id="special_completed"}
      else a.undo.special = {} end
    else
      log("ERROR: incorrect stage for finished: "..tostring(a.stage)); return   --DEBUG
    end
    if #a.pending_cubes > 0 then
      cleanupCourt(pcol)
      pendingCubes("clear")
    end
    a.caballeros_moved = 0
    a.stage = "main"
    if a.court_completed and a.special_completed then
      a.description = "All actions completed"
      a.status.info = "Active Player\nActions completed for\n"..a.name
    else
      a.status.info = "Active Player\nChoose actions for\n"..a.name
      a.description = "Choose an action"
    end
    if pdata.allow_undo then pdata.undo_button = true else pdata.undo_button = false end
    pdata.done_button = true
    setLockCourt(pcol, true)
    setLockProvinces(pcol, true)
    updatePlayerBoardUI(pcol)
    updateBoardUI()
    updateCastilloUI()
    a.ignore_wait = true --TODO: no coro (remove when all coro's safe)
    a.waiting = 0
    a.status.waitlist = {}
    updateStatusUI(a.status)
  elseif opt == "reset" then
    if a.stage == "court" then
      log("processAction(): reset court stage")
      for _,u in pairs(a.undo.court) do undo(u) end
      a.undo.court = {}
      a.court_completed = false
    elseif a.stage == "special" then
      log("processAction(): reset special stage")
      for g,u in pairs(a.undo.special) do undo(u) end
      a.undo.special = {}
      a.special_completed = false
      a.special.origin = nil --HACK: should this be an undo?  not sure why I'm doing this
    elseif a.stage == "waiting" then
      log("processAction(): reset special while waiting")
      --TODO: clean up this mess! why the conditional? move stuff to an undo.special entry??
      if a.waitlist and #a.waitlist == 1 and a.waitlist[1] == pcol then --TODO: used when active is doing something (disk?), move to an undo.special entry
        if a.undo.special ~= {} then
          log("WARN: undoing specials while active player is in waiting state") --DEBUG
          for g,u in pairs(a.undo.special) do undo(u) end
        end
        -- a.undo.special = {}
        -- a.special_completed = false
        local pdata = G.d.players[pcol]
        pdata.waiting = false
        pdata.show_disk = false
        pdata.disk_button = false
        pdata.undo_button = false
        pdata.done_button = true
        pdata.action_ui = true
      else
        if a.undo.special ~= {} then
          for g,u in pairs(a.undo.special) do undo(u) end
        else
          log("WARN: processAction() reset while waiting but no undo.special to do") --DEBUG
        end
        pdata.disable_reset = false
        pdata.allow_undo = true
        pdata.undo_button = true
        pdata.done_button = true
        pdata.action_ui = true
        updatePlayerBoardUI(pcol)
      end
      a.undo.special = {}
      a.special_completed = false
      log("clearing wait on reset")
      a.status.info = "Active Player\nChoose actions for\n"..cards[a.guid].name
      a.ignore_wait = true --TODO: no coro (remove when all coro's safe)
      a.waitlist = {}
      a.waiting = 0
      a.status.waitlist={}
      updateStatusUI(a.status)
    else
      log("ERROR: processAction() incorrect stage for reset: "..tostring(a.stage)); return   --DEBUG
    end
    --reset a bunch of stuff in the action, TODO: more undo.special entries?
    a.caballeros_moved = 0
    if #a.pending_cubes > 0 then
      cleanupCourt(pcol)
      pendingCubes("clear")
    end
    a.stage = "main"
    a.description = "Choose an action"
    setLockCourt(pcol, true)
    setLockProvinces(pcol, true)
    updatePlayerBoardUI(pcol)
    updateBoardUI()
    updateCastilloUI()
  else
    log("ERROR: processAction() unknown action")   --DEBUG
  end
end
--[[ Add a Caballero to a region. Does nothing if already in region.
  Check region validity and update new region.
  Never allowed in king region.
  If in action phase, check validity and update action/undo.
  Return true if result is ok.  False if not.
  NOTE: Caller is responsible for updating snaps or snapBack based on result.
  TODO: can snapBack be moved in here?
  TODO: review shared code between addCaballero, setGrande, setKing
]]
--TODO: handle differentiation of court move vs. region move in action, extra UI on playerboard for these stages of the action
--TODO figure out how to handle move N cubes for each color (see card 38358d)
--TODO: handle forced moves (players selected region, just like the Castillo but during an action)
--TODO: handle origin region requirements (move all your caballeros out of one region to any region/castillo)
function addCaballero(player, region, color, guid)
  if env.trace then log("addCaballero() "..tostring(region)..", "..tostring(color)..":"..tostring(guid)) end
  if G.d.phase == "bidding" then return false end
  local rdata = G.obj.regions[region]
  local function debug(str) if true then log("DEBUG addCaballero(): "..str) end end --DEBUG: set false to disable
  local function add()
    rdata.caballeros[color][guid] = true
    getObjectFromGUID(region).highlightOn(Color["Yellow"],1)
    for g,r in pairs(G.obj.regions) do
      if g ~= region and r.caballeros[color][guid] then r.caballeros[color][guid] = nil end
    end
    if indexOf(G.d.players[color].court,guid) > 0 then table.remove(G.d.players[color].court,indexOf(G.d.players[color].court,guid)) end
    updateBoardUI()
  end
  local function neighborToKing(r)
    for _,n in ipairs(r.neighbors) do
      if G.obj.regions[C.region_guids[n]].king then return true end
    end
    return false
  end
  if rdata.king then return false end
  if G.d.phase == "placement" then add()
  elseif G.d.phase == "actions" then
    local a = G.d.action
    local allowed, any_region, min, max, total, each, opp, any, origin = false, false, nil, nil, nil, false, false, false, nil
    if a.stage == "waiting" then
      --special case during staged cube placement with no und (i.e. Evict).  There may be others.
      local dest = C.region_guids[G.d.players[color].selected_region]
      if region ~= dest then debug("failed destination check during castillo placement"); return false end
      if indexOf(G.d.players[color].staged_cubes,guid) > 0 then
        table.remove(G.d.players[color].staged_cubes,indexOf(G.d.players[color].staged_cubes,guid))
        if #G.d.players[color].staged_cubes == 0 then
          G.d.players[color].disk_button = false
          G.d.players[color].undo_button = false
          G.d.players[color].done_button = true
          G.d.players[color].active = true
          updatePlayerBoardUI(color)
        end
      else
        debug("ERROR: cube "..guid.." not in player "..color.." staged cubes list"); return false
      end
      add()
      return true
    end
    if a.stage == "special" then
      debug("add caballero during special")
      local s = a.special
      if Split(s.id,"_")[1] == "move" then
        log("is a move special action")
        if player ~= G.d.active_player then debug("failed: "..player.." is not the active player"); return false end
        any_region = contains(s, "any_region")
        allowed = true
        if Split(s.id,"_")[2] == "opp" then opp = true end
        if Split(s.id,"_")[2] == "any" then any = true end
        if Split(s.id,"_")[2] == "court" then origin = "court" end
        max = s.max
        min = s.min
        if s.each then each = true end
        if s.total then total = s.total end
      end
      if s.single_origin then
        if s.origin then
          if s.origin == "court" then
            if not(contains(G.d.players[color].court,guid)) then debug("failed origin not court"); return false end
          end
        else
          if contains(G.d.players[color].court,guid) then
            if s.court_ok then s.origin = "court" else debug("failed, origin court not allowed"); return false end
          else
            for g,r in pairs(G.obj.regions) do
              if r.caballeros[color][guid] then s.origin=g; break end
            end
          end
        end
        origin = s.origin
        allowed = true
      end
      if not(allowed) then debug("move caballero not allowed"); return false end
      if not(any_region) then if not(neighborToKing(rdata)) then debug("failed king neigbor check"); return false end end
      if contains(a.pending_cubes,guid) then
        if a.undo[a.stage][guid] and region == a.undo[a.stage][guid].origin then
          log("--- TODO: replacing cube in origin region, reset things for it")
          --TODO: check for replacing in origin and reset things for this cube if it is
          -- clear from pendingCubes
          -- decrement moved cubes counter(s)
          -- reset buttons if needed
          -- update displays
          -- clear undo
        end
        add(); return true --allow pending cubes after king check
      end
      if color == a.player and opp then debug("failed, only opp allowed"); return false
      elseif color ~= a.player and not(opp or any) then debug("failed, opp not allowed"); return false end
      --check move limits
      if each then
        if max and a.caballeros_moved[color] >= max then debug("failed limit check for each"); return false end
        if total and a.total_moved >= total then debug("failed limit check for total"); return false end
      else
        if max and a.caballeros_moved >= max then debug("failed limit check"); return false end
        if color ~= a.player and s.max_opp and a.opp_moved >= s.max_opp then debug("failed limit check for opp max"); return false end
        if color == a.player and s.max_own and a.own_moved >= s.max_own then debug("failed limit check for own max"); return false end
      end
    elseif a.stage == "court" then
      debug("add caballero during court")
      if not(neighborToKing(rdata)) then debug("failed king neigbor check"); return false end
      if contains(a.pending_cubes,guid) then add(); return true end --allow pending cubes after king check
      if a.caballeros_moved >= a.court then debug("failed move limit check"); return false end
      if not(contains(G.d.players[a.player].court, guid)) then debug("failed source is court check"); return false end
    else
      --TODO: any other stages valid?
      log("WARN: auto fail caballero placement for unhandled action.stage")
      return false
    end
    -- Passed above checks, now if first time for this guid, setup the undo. Check cube source against action origin if defined.
    if not(a.undo[a.stage][guid]) then
      local source = ""
      if a.stage == "court" then
        source = "court"
        a.undo.court[guid]={id="court",g=guid,pcol=a.player,origin="court"}
        a.caballeros_moved = a.caballeros_moved + 1
        pendingCubes("add",guid)
        updatePlayerBoardUI(a.player)
      elseif a.stage == "special" then
        local source = ""
        if contains(G.d.players[color].court,guid) then source = "court" end
        for g,r in pairs(G.obj.regions) do
          if r.caballeros[color][guid] then
            if r.king then debug("failed, cannot move from king region"); return false end
            source=g; break
          end
        end
        if origin and source ~= origin then debug("failed origin check"); return false end
        if each then
          a.caballeros_moved[color] = a.caballeros_moved[color] + 1
          local n = 0; for _,c in pairs(a.caballeros_moved) do n=n+c end
          if total then a.total_moved = n; a.stage_status = "Moved "..tostring(n).." / "..tostring(total)
          elseif max then a.stage_status = "Moved "..tostring(n).." / "..tostring(max)
          else a.stage_status = "Moved "..tostring(n) end
        else
          a.caballeros_moved = a.caballeros_moved + 1
          if a.opp_moved and color ~= a.player then a.opp_moved = a.opp_moved + 1 end
          if a.own_moved and color == a.player then a.own_moved = a.own_moved + 1 end
          if max then a.stage_status = "Moved "..tostring(a.caballeros_moved).." / "..tostring(max)
          else a.stage_status = "Moved "..tostring(a.caballeros_moved) end
        end
        pendingCubes("add",guid)
        updatePlayerBoardUI(a.player)
        if source == "court" then a.undo.special[guid]={id="court",g=guid,color=color,pcol=a.player,origin="court",}
        else a.undo.special[guid]={id="move_caballero",g=guid,color=color,pcol=a.player,origin=source,snap=G.obj.snaps[guid],} end
      end
    end
    add()
  elseif G.d.phase == "scoring" then
    local dest = C.region_guids[G.d.players[color].selected_region]
    if region ~= dest then debug("failed destination check during castillo placement"); return false end
    if indexOf(G.d.players[color].staged_cubes,guid) > 0 then
      table.remove(G.d.players[color].staged_cubes,indexOf(G.d.players[color].staged_cubes,guid))
      if #G.d.players[color].staged_cubes == 0 then
        G.d.players[color].disk_button = false
        G.d.players[color].undo_button = false
        G.d.players[color].done_button = true
        G.d.players[color].active = true
        updatePlayerBoardUI(color)
      end
    else
      debug("ERROR: cube "..guid.." not in player "..color.." staged cubes list"); return false
    end
    add()
    return true
  else
    log("WARN: addCaballero() unknown phase")
    return false
  end
  return true
end
--[[ Sets a Grande in a region. Does nothing if already in region.
Check region validity and update new region.
Never allowed in king region.
If in action phase, check validity and update action/undo.
Return true if result is ok.  False if not.
NOTE: Caller is responsible for updating snaps or snapBack based on result.
TODO: can snapBack be moved in here?
TODO: review shared code between addCaballero, setGrande, setKing
]]
--TODO: handle case Grande has been put in Castillo
function setGrande(region, color)
  if env.trace then log("setGrande() "..tostring(region)..", "..tostring(color)) end
  if G.d.phase == "bidding" then return false end
  local guid = G.d.players[color].grande
  local rdata = G.obj.regions[region]
  local function debug(str) if true then log(str) end end --DEBUG: set false to disable verbose debug in this function
  local function add()
    for g,r in pairs(G.obj.regions) do
      if g == region then
        r.grandes[color] = true
        getObjectFromGUID(g).highlightOn(Color["Yellow"],1)
      else r.grandes[color] = false end
    end
    updateBoardUI()
  end
  local function neighborToKing(r)
    for _,n in ipairs(r.neighbors) do
      if G.obj.regions[C.region_guids[n]].king then return true end
    end
    return false
  end
  if rdata.king then return false end
  if G.d.phase == "placement" then add()
  elseif G.d.phase == "actions" then
    local a = G.d.action
    if a.stage == "special" then
      debug("set Grande during special")
      local allowed, any_region, opp = false, false, false
      if contains(a.special, "grande") then
        allowed = true
        any_region = a.special.dest == "any_region"
        if a.special.opp then opp = true end
      end
      if color ~= a.player and not(opp) then debug("failed opponent check"); return false end
      if not(allowed) then debug("failed special check"); return false end
      if not(any_region) then if not(neighborToKing(rdata)) then debug("failed king neigbor check"); return false end end
      if contains(a.pending_cubes,guid) then add(); return true end --allow pending cubes after king and action check
    elseif a.stage == "court" then
      debug("fail set Grande during court")
      return false
    else
      --TODO: any other stages valid?
      log("WARN: fail Grande placement for unhandled action.stage")
      return false
    end
    --save an undo on first time to retain origin info
    if not(a.undo[a.stage][guid]) then
      local old = nil
      for g,r in pairs(G.obj.regions) do
        if r.grandes[color] then old = g; break end
      end
      if G.obj.regions[old].king then debug("failed, cannot move from king region"); return false end
      pendingCubes("add",guid)
      a.undo["special"][guid]={id="move_grande",g=guid,region=region,origin=old,snap=G.obj.snaps[guid]}
    end
    add()
  elseif G.d.phase == "castillo" then
    --TODO: just return true when auto placing from the castillo during scoring? (TODO: can grande be there?)
    return true
  else
    log("WARN: setGrande() unknown phase")
  end
  return true
end
--[[ Sets the King in a region. Does nothing if already in region.
  Only allowed in action phase, check validity and update action/undo.
  Return true if result is ok.  False if not.
  NOTE: Caller is responsible for updating snaps or snapBack based on result.
  TODO: can snapBack be moved in here?
  TODO: review shared code between addCaballero, setGrande, setKing
]]
function setKing(region)
  if env.trace then log("setKing() "..tostring(region)) end
  local function debug(str) if true then log("DEBUG setKing() "..str) end end --DEBUG: set false to disable verbose debug in this function
  if G.d.phase == "bidding" then debug("fail set king during bidding"); return false end
  local rdata = G.obj.regions[region]
  local guid = C.king
  local function add()
    for g,r in pairs(G.obj.regions) do
      if g == region then
        r.king = true
        getObjectFromGUID(g).highlightOn(Color["Yellow"],1)
      else r.king = false end
    end
    updateBoardUI()
  end
  if G.d.phase == "placement" then
    for g,r in pairs(G.obj.regions) do if r.king then return false end end --don't allow movement in placement phase if assigned,
    add()
  elseif G.d.phase == "actions" then
    local a = G.d.action
    if a.stage == "special" then
      debug("set King during special")
      local allowed, any_region, adjacent, origin = false, false, false, nil
      if contains(a.special, "king") then
        allowed = true
        any_region = a.special.dest == "any_region"
      end
      if not(allowed) then debug("failed special check"); return false end
      --save an undo on first time to retain origin info
      if not(a.undo.special[guid]) then
        if not(any_region) then
          for _,n in ipairs(rdata.neighbors) do if G.obj.regions[C.region_guids[n]].king then adjacent = true end end
          if not(adjacent) then debug("failed King initial adjacency check"); return false end
        end
        for g,r in pairs(G.obj.regions) do if r.king then origin = g; break end end
        a.undo.special[guid]={id="move_king",g=guid,origin=origin,snap=G.obj.snaps[guid]}
      elseif not(any_region) then
        for _,n in ipairs(rdata.neighbors) do if C.region_guids[n] == a.undo.special[guid].origin then adjacent = true; break end end
        if not(adjacent) then debug("failed King origin adjacency check"); return false end
      end
      add()
      a.stage_status = "King moved"
      updatePlayerBoardUI(a.player)
    elseif a.stage == "court" then debug("fail set King during court"); return false
    else debug("WARN: fail set King for unhandled action.stage"); return false end
  else debug("WARN: setKing() unknown phase"); return false end
  return true
end
--[[ Adds a Caballero to the Castillo when a player drops it over the bag.
    TODO: still pretty EXPERIMENTAL
    TODO: more validation/game state checks
    TODO: handling this in undo could be fun
]]
function addToCastillo(obj)
  if env.trace then log("addToCastillo()") end
  local function debug(str) if true then log("DEBUG: addToCastillo() "..str) end end --DEBUG: set false to disable
  local color = obj.memo; assert(color,"addToCastillo(): color missing")
  local guid = obj.getGUID()
  local castillo = getObjectFromGUID(C.castillo)
  local function add()
    if contains(G.d.action.pending_cubes,guid) then pendingCubes("remove",guid) end
    castillo.putObject(obj)
    castillo.highlightOn(Color["Yellow"],1)
    table.insert(G.obj.castillo.caballeros[color],guid)
    for g,r in pairs(G.obj.regions) do
      if r.caballeros[color][guid] then r.caballeros[color][guid] = nil end
    end
    updateCastilloUI()
  end
  if obj.hasTag("Caballero") then
    if G.d.phase == "actions" then
      local a = G.d.action
      local allowed, min, max, each, opp, any, origin = false, nil, nil, false, false, false, nil
      if a.stage == "special" then
        debug("add Caballero to Castillo during action special stage")
        local s = a.special
        if Split(s.id,"_")[1] == "move" then
          allowed = true
          if Split(s.id,"_")[2] == "opp" then opp = true end
          if Split(s.id,"_")[2] == "any" then any = true end
          if Split(s.id,"_")[2] == "court" then origin = "court" end
          max = s.max; min = s.min
          if s.each then each = true end
          if s.total then total = s.total end
        elseif s.single_origin then
          if s.origin then
            if s.origin == "court" then
              max = s.max
              if not(contains(G.d.players[color].court,guid)) then debug("failed origin not court"); return false end
            end
          else
            if contains(G.d.players[color].court,guid) then
              if s.court_ok then s.origin = "court" else debug("failed, origin court not allowed"); return false end
            else
              for g,r in pairs(G.obj.regions) do
                if r.caballeros[color][guid] then
                  if r.king then debug("failed, cannot move from king region"); return false end
                  s.origin=g; break
                end
              end
            end
          end
          origin = s.origin
          allowed = true
        end
        if not(allowed) then debug("move caballero not allowed"); return false end
        if contains(a.pending_cubes,guid) then --allow pending cubes after above checks
          add(); return true
        end
        if color == a.player and opp then debug("failed, only opp allowed"); return false
        elseif color ~= a.player and not(opp or any) then debug("failed, opp not allowed"); return false end
        --check move limits
        if each then
          if max and a.caballeros_moved[color] >= max then debug("failed limit check for each"); return false end
          if total and a.total_moved >= total then debug("failed limit check for total"); return false end
        else
          if max and a.caballeros_moved >= max then debug("failed limit check"); return false end
          if color ~= a.player and s.max_opp and a.opp_moved >= s.max_opp then debug("failed limit check for opp max"); return false end
          if color == a.player and s.max_own and a.own_moved >= s.max_own then debug("failed limit check for own max"); return false end
        end
      elseif a.stage == "court" then
        debug("add Caballero to Castillo during action court stage")
        if not(contains(a.pending_cubes,guid)) then
          if a.caballeros_moved >= a.court then debug("failed move limit check"); return false end
          if not(contains(G.d.players[a.player].court, guid)) then debug("failed source is court check"); return false end
        end
      else
        debug("ERROR: unhandled action stage"); return false
      end
      --passed checks
      if a.stage == "court" then
        if a.undo.court[guid] then --was alread moved so update the undo
          debug("update undo for "..guid)
          a.undo.court[guid].id = "castillo"
          a.undo.court[guid].color = obj.memo
          pendingCubes("remove",guid)
        else
          a.undo.court[guid]={id="castillo",g=guid,color=obj.memo,pcol=a.player,origin="court"}
          a.caballeros_moved = a.caballeros_moved + 1
          local pdata = G.d.players[a.player]
          if indexOf(pdata.court,guid) > 0 then table.remove(pdata.court,indexOf(pdata.court,guid)) end
          updatePlayerBoardUI(a.player)
        end
      elseif a.stage == "special" then
        --determine source
        local source = ""
        if contains(G.d.players[color].court,guid) then source = "court" end
        for g,r in pairs(G.obj.regions) do
          if r.caballeros[color][guid] then
            if r.king then debug("failed, cannot move from king region"); return false end
            source=g; break
          end
        end
        --check action origin requirement
        if origin and source ~= origin then debug("failed origin check"); return false end
        --handle "each" and increment counters, update stage_status
        if each then
          a.caballeros_moved[color] = a.caballeros_moved[color] + 1
          local n = 0; for _,c in pairs(a.caballeros_moved) do n=n+c end
          if total then a.total_moved = n; a.stage_status = "Moved "..tostring(n).." / "..tostring(total)
          elseif max then a.stage_status = "Moved "..tostring(n).." / "..tostring(max)
          else a.stage_status = "Moved "..tostring(n) end
        else
          a.caballeros_moved = a.caballeros_moved + 1
          if a.opp_moved and color ~= a.player then a.opp_moved = a.opp_moved + 1 end
          if a.own_moved and color == a.player then a.own_moved = a.own_moved + 1 end
          if max then a.stage_status = "Moved "..tostring(a.caballeros_moved).." / "..tostring(max)
          else a.stage_status = "Moved "..tostring(a.caballeros_moved) end
        end
        pendingCubes("add",guid)
        updatePlayerBoardUI(a.player)
        if source == "court" then a.undo.special[guid]={id="castillo",g=guid,color=color,player=a.player,origin="court",}
        else a.undo.special[guid]={id="castillo",g=guid,color=color,player=a.player,origin=source,snap=G.obj.snaps[guid],} end
      end
      add()
    else
      debug("ERROR: unhandled game phase")
    end
  elseif obj.hasTag("Grande") then
    debug("fail, Grande in Castillo not implemented")
    --base game doesn't do this, but Intrigue expansion might
    return false
  else
    debug("ERROR: unhandled obj tag")
  end
  return true
end
--[[ Adds a mobile score board to a region when dropped on it
  NOTE: region may be a region guid or "castillo" and is handled accordingly
--]]
function addScoreBoard(region, guid)
  if env.trace then log("addScoreBoard() "..tostring(region)..", "..tostring(guid)) end
  local function debug(str) if true then log("addScoreBoard(): "..str) end end --DEBUG: set false to disable verbose debug in this function
  if G.d.phase == "actions" then
    local rdata,origin,replace = nil,nil,nil
    if region == "castillo" then rdata = G.obj.castillo
    else rdata = G.obj.regions[region] end
    if rdata.king then debug("failed king check"); snapBack(guid); return end
    if rdata.score_board then debug("failed existing scoreboard check"); snapBack(guid); return end
    debug("placing mobile score board in "..tostring(region))
    --clear this scoreboard from any existing region or castillo
    if G.obj.castillo.score_board == guid then
      debug("moving from castillo, reset it")
      G.obj.castillo.score_board = false
      G.obj.castillo.scoring = simpleDeepCopy(C.castillo_template.scoring)
      origin = "castillo"
    else
      for g,rd in pairs(G.obj.regions) do
        if g ~= region and rd.score_board == guid then
          debug("moving from another region, reset that region")
          rd.score_board = false
          object_UI_setAttribute(g, "mb_panel", "active", false)
          rd.scoring = simpleDeepCopy(C.regions_template[g].scoring)
          origin = g
          break
        end
      end
    end
    --set in new region
    rdata.score_board = guid
    rdata.scoring = simpleDeepCopy(C.mobile_score_boards[guid].scoring)
    --place scoreboard under region status panel or on castillo
    if region == "castillo" then pos = C.castillo_mb_position
    else pos = C.score_board_positions[indexOf(C.region_guids,region)] end
    local o = getObjectFromGUID(guid)
    o.setPosition(pos)
    Wait.condition(function()
      for g,_ in pairs(C.mobile_score_boards) do getObjectFromGUID(g).setLock(true) end
    end, function() return o.resting end)
    --set the undo data and update object snaps
    G.d.action.undo.special[guid]={id="scoreboard",g=guid,region=region,origin=origin,replace=replace,snap=G.obj.snaps[guid]}
    G.obj.snaps[guid] = pos
    if region ~= "castillo" then
      debug("setting mb_image to "..tostring(C.mobile_score_boards[guid].image))
      object_UI_setAttribute(region, "mb_image", "image", C.mobile_score_boards[guid].image)
      object_UI_setAttribute(region, "mb_panel", "active", true)
    end
    updateBoardUI()
  else
    debug("fail addScoreBoard(): not in actions phase")
    snapBack(guid)
  end
end
--[[ Player clicked "Done" button.
]]
function playerDone(pcol)
  if env.trace then log("playerDone() "..tostring(pcol)) end
  local function debug(msg) if true then log("playerDone(): "..msg) end end --DEBUG set false to disable
  local pdata = G.d.players[pcol]
  if not(pdata.active) then debug("ignoring inactive player"); return end
  if G.d.phase == "placement" then
    if indexOf(G.d.waitlist,pcol) > 0 then
      table.remove(G.d.waitlist,indexOf(G.d.waitlist,pcol))
      for i,e in ipairs(G.d.status.waitlist) do
        if e.player_color == pcol then e.player_status = "Set"; break end
      end
      pdata.disk_button = false
      pdata.undo_button = true
      pdata.done_button = false
      pdata.active = false
      pdata.done = true
      updatePlayerBoardUI(pcol)
      if #G.d.waitlist == 0 then
        G.d.status.show = false
        placeStartingCubes()
        startBidPhase()
      else
        updateStatusUI(G.d.status)
      end
    end
  elseif G.d.phase == "bidding" then
    pdata.undo_button = false
    pdata.done_button = false
    pdata.active = false
    pdata.done = true
    updatePlayerBoardUI(pcol)
    if #G.d.players_to_bid == 0 then
      startActionPhase()
    else
      for i,e in ipairs(G.d.status.waitlist) do
        if e.player_color == pcol then e.player_status = "Set"; break end
      end
      local n = indexOf(G.d.player_order, pcol) + 1
      if n > #G.d.player_order then n = 1 end
      G.d.status.waitlist[n].player_status = "Active"
      updateStatusUI(G.d.status)
      G.d.active_player = G.d.player_order[n]
      G.d.players[G.d.active_player].active = true
      updatePlayerBoardUI(G.d.active_player)
      for g,d in pairs(G.obj.bid_buttons) do
        if not(d.selected) and indexOf(d.players,G.d.active_player) > 0 then
          d.visibility = {G.d.active_player}
        else
          d.visibility = {}
        end
        updateOrderButtonUI(g,d)
      end
    end
  elseif G.d.phase == "actions" then
    local a = G.d.action
    if a.stage == "waiting" then
      local index = indexOf(a.waitlist, pcol)
      if index > 0 then
        debug(pcol.." is in action waitlist, action is waiting")
        local e = a.status.waitlist[index]
        if a.special.disk then
          e.player_status = "Set"; debug("action is waiting on disk selections") --DEBUG
        elseif a.special.placing then
          e.player_status = "Done"; debug("action is waiting on cube placement") --DEBUG
        else
          e.player_status = "Done"; debug("action is waiting on sequential player decisions") --DEBUG
          --advance to next player in waitlist
          if a.waitlist[index+1] then
            if a.special.placing then a.status.waitlist[index+1].player_status = "Placing"
            else a.status.waitlist[index+1].player_status = "Deciding" end
            local next = a.waitlist[index+1]
            G.d.players[next].active = true
            updatePlayerBoardUI(next)
          end
        end
        updateStatusUI(a.status)
        a.waiting = a.waiting - 1
        pdata.disk_button = false
        if a.special.disk then
          pdata.undo_button = a.waiting > 0
        else
          pdata.undo_button = false
          pendingCubes("clear_player",pcol)
          cleanupCourt(pcol)
          setLockCourt(pcol, true)
        end
        if a.waiting > 0 then
          pdata.done_button = false
          pdata.active = false
          pdata.done = true
          pdata.waiting = false
          pdata.show_stage = false
          updatePlayerBoardUI(pcol)
        else
          ----////////// Handle special actions after waiting completed ////////////////
          if a.special.id == "ret2provinces" then
            debug("action:ret2provinces, finished wait on opponents")
            for _,c in ipairs(a.waitlist) do
              if c ~= a.player then
                local p = G.d.players[c]
                p.show_disk = false
                p.disk_button = false
                p.undo_button = false
                p.done_button = false
                p.active = false
                p.waiting = false
                updatePlayerBoardUI(c)
                --return a.special.count cubes (or as many as they have up  to that)
                --from the region.  If no special.count then it's all in the region
                local r = G.obj.regions[C.region_guids[p.selected_region]]
                local n = 0
                for g,_ in pairs(r.caballeros[c]) do
                  returnToProvinces(c,g,false)
                  r.caballeros[c][g] = nil; n = n + 1
                  if a.special.count and n >= a.special.count then break end
                end
              end
            end
            a.special_completed = true
            a.stage = "main"
            a.status.info = "Provinces:\nActive Player\nSelect an action"
            a.status.waitlist = {}
            updateStatusUI(a.status)
            G.d.players[G.d.active_player].disable_reset = true
            G.d.players[G.d.active_player].allow_undo = false
            G.d.players[G.d.active_player].undo_button = false
            G.d.players[G.d.active_player].done_button = true
            G.d.players[G.d.active_player].action_ui = true
            updatePlayerBoardUI(G.d.active_player)
            updateBoardUI()
          elseif a.special.id == "king_returns" then
            debug("action:king_returns, finished wait on opponents")
            G.d.players[G.d.active_player].done_button = true
            a.stage_status = "Opp all done"
            a.stage = "special"
            updatePlayerBoardUI(G.d.active_player)
          elseif a.special.id == "special_scoring" and a.special.secret then
            debug("special_scoring, secret, finished wait on opponents to make secret selections")
            local list = simpleDeepCopy(a.waitlist) --TODO: why copy?
            local unique = a.special.unique or false
            local undo_ok = false
            if a.special.players == "active" then undo_ok = true --no other player revealed a secret
            else debug("special_scoring, secret, clearing undo"); a.undo = {main={},court={},special={},reset=false} end
            for c,pd in pairs(G.d.players) do
              pd.show_disk = false
              pd.disk_button = false
              pd.action_ui = false
              if c ~= G.d.active_player then pd.active = false; pd.allow_undo = false end
              pd.done = false
              pd.undo_button = false
              pd.done_button = false
              updatePlayerBoardUI(c)
            end
            local regions, rejected = {},{}
            for _,p in ipairs(list) do
              local r = G.d.players[p].selected_region
              if unique then
                if indexOf(rejected,r) > 0 then --ignoring this entry
                elseif indexOf(regions,r) > 0 then table.insert(rejected,r); table.remove(regions,indexOf(regions,r))
                else table.insert(regions,r) end
              else table.insert(regions,r) end
            end
            if unique then debug("special_scoring, secret, Players selected unique regions: ");log(regions)                --DEBUG
            else debug("special_scoring, secret, Players selected regions: ");log(regions) end                             --DEBUG
            if #rejected > 0 then debug("special_scoring, secret, Multiple players selected regions: ");log(rejected) end  --DEBUG
            if #regions > 0 then
              local msg = "Selected: ["
              for _,r in ipairs(regions) do msg = msg..tostring(r).."," end
              msg = msg.."]"
              if #rejected > 0 then
                msg=msg.."\nRejected: ["
                for _,r in ipairs(rejected) do msg = msg..tostring(r).."," end
                msg = msg.."]"
              end
              G.d.players[G.d.active_player].allow_undo = undo_ok
              a.allow_veto = false
              a.stage_status = "Special Scoring"
              debug("special_scoring, secret, starting scoring")
              startScoring(regions,true,msg)
            else
              debug("special_scoring, secret, No regions to score") --DEBUG
              a.stage_status = "Nothing to score"
            end
          elseif a.special.id == "evict" then
            if a.special.evict_stage == 1 then
              debug("action:evict, finished wait on active player to select evict region")
              pdata.allow_undo = false
              pdata.disable_reset = true
              pdata.waiting = false
              pdata.show_disk = false
              pdata.disk_button = false
              pdata.undo_button = false
              pdata.done_button = false
              pdata.action_ui = true
              updatePlayerBoardUI(pcol)
              local evict_region = pdata.selected_region
              a.special.evict_region = evict_region
              getObjectFromGUID(C.region_guids[evict_region]).highlightOn(Color["Yellow"])
              a.undo.special[evict_region] = {id="highlight",g=C.region_guids[evict_region],state="off"}
              local evicted = G.obj.regions[C.region_guids[evict_region]]
              a.status.info = "Evict: "..G.obj.regions[C.region_guids[evict_region]].name
              a.status.info = a.status.info.."\nOpp select destination\nKing region -> Court"
              a.status.waitlist = {}
              a.waitlist = {}
              local allowed = {}
              for i=1,9 do if i ~= evict_region then table.insert(allowed,i) end end
              for _,c in ipairs(a.opponents) do
                if sizeOf(evicted.caballeros[c]) > 0 then
                  table.insert(a.waitlist,c)
                  table.insert(a.status.waitlist,{player_color=c,player_status="Deciding"})
                  local pd = G.d.players[c]
                  pd.active = true
                  pd.waiting = true
                  pd.show_disk = true
                  pd.disk_button = true
                  pd.show_stage = false
                  pd.allowed_regions = allowed
                  pd.undo_button = false
                  pd.done_button = true
                  pd.action_ui = false
                  pd.selected_region = allowed[math.random(#allowed)]
                  updatePlayerBoardUI(c)
                end
              end
              if #a.waitlist == 0 then
                --TODO: handle case the active player selected an empty region!
                local pdata = G.d.players[G.d.active_player]
                pdata.active = true
                pdata.disable_reset = false
                pdata.done_button = true
                pdata.undo_button = true
                pdata.allow_undo = true
                a.special_completed = false
                a.stage_status = "No opp in region"
                a.stage = "special"
                updatePlayerBoardUI(G.d.active_player)
                updateStatusUI(G.d.status)
              else
                a.special.disk = true --allow player undo during disk selection wait
                a.status.show = true
                updateStatusUI(a.status)
                a.waiting = #a.waitlist
                a.special.evict_stage = 2
              end
            elseif a.special.evict_stage == 2 then
              debug("action:evict, finished wait on opponents to select evict destinations")
              local evict_region = a.special.evict_region
              getObjectFromGUID(C.region_guids[evict_region]).highlightOff()
              local evicted = G.obj.regions[C.region_guids[evict_region]]
              for _,c in ipairs(a.waitlist) do
                local pd = G.d.players[c]
                if G.obj.regions[C.region_guids[pd.selected_region]].king then
                  --immediately return this player's cubes to court & remove from waitlist
                  for g,_ in pairs(evicted.caballeros[c]) do returnToCourt(c,g) end
                  evicted.caballeros[c] = {}
                  table.remove(a.waitlist,indexOf(a.waitlist,c))
                  pd.active = false
                  pd.waiting = false
                  pd.show_disk = false
                  pd.show_stage = false
                  pd.disk_button = false
                  pd.undo_button = false
                  pd.done_button = false
                  pd.action_ui = false
                  updatePlayerBoardUI(c)
                end
              end
              --for remaining waitlist, setup staging
              a.status.info = "Evict: "..G.obj.regions[C.region_guids[evict_region]].name
              a.status.info = a.status.info.."\nOpp move Caballeros\nto selected region"
              a.status.waitlist = {}
              for _,c in pairs(a.waitlist) do
                local pd = G.d.players[c]
                table.insert(a.status.waitlist, {player_color=c,player_status="Placing"})
                pd.active = true
                pd.waiting = true
                pd.show_disk = false
                pd.show_stage = true
                pd.disk_button = false
                pd.undo_button = false
                pd.done_button = false
                pd.action_ui = false
                updatePlayerBoardUI(c)
                local index = 1
                local board = getObjectFromGUID(C.player_boards[c])
                pd.staged_cubes = {}
                for g,_ in pairs(evicted.caballeros[c]) do
                  local pos = board.positionToWorld(C.stage_pos_l[index])
                  getObjectFromGUID(g).setPosition(pos)
                  index = index + 1
                  G.obj.snaps[g] = pos
                  pendingCubes("add",g)
                  table.insert(pd.staged_cubes,g)
                end
              end
              a.special.disk = false
              a.special.placing = true
              updateStatusUI(a.status)
              a.waiting = #a.waitlist
              a.special.evict_stage = 3
            elseif a.special.evict_stage == 3 then
              debug("action:evict, finished wait on opponents to place cubes")
              for _,c in pairs(a.waitlist) do
                local pd = G.d.players[c]
                pd.active = false
                pd.waiting = false
                pd.show_disk = false
                pd.show_stage = false
                pd.disk_button = false
                pd.undo_button = false
                pd.done_button = false
                pd.action_ui = false
                updatePlayerBoardUI(c)
              end
              local pdata = G.d.players[G.d.active_player]
              pdata.active = true
              pdata.done_button = true
              pdata.undo_button = false
              a.special_completed = true
              a.stage = "main"
              updatePlayerBoardUI(G.d.active_player)
              updateStatusUI(G.d.status)
            else
              debug("ERROR: action:evict, unhandled special.evict_stage")
            end
          end
        end
      else
        log("ERROR: playerDone() player "..pcol.." not in action.waitlist") --DEBUG
      end
    else
      debug("action is not waiting")
      if not(a.court_completed) or not(a.special_completed) then
        --incomplete action, warn user with chance to cancel
        G.d.confirm_actions = {}
        G.d.confirm_actions.ok={fn="playerDone",params=pcol,pre={"end_actions"},}
        G.d.confirm_actions.cancel={}
        G.d.confirm_lock = true
        UI_setAttribute("confirm_msg_txt","text","Skip unused actions?")
        UI_setAttribute("confirm_cancel_ok_row","active",true)
        UI_setAttribute("confirm_ack_row","active",false)
        UI_setAttribute("confirm_pnl","visibility",pcol)
        return
      end
      pdata.undo_button = false
      pdata.done_button = false
      pdata.action_ui = false
      pdata.active = false
      pdata.done = true
      updatePlayerBoardUI(pcol)
      for i,e in ipairs(G.d.status.waitlist) do
        if e.player_color == pcol then e.player_status = "Done"; break end
      end
      --cleanup some stuff from the action
      card = getObjectFromGUID(pdata.action_card)
      if not(card) then debug("WARN: failed to get active player's action card object; "..tostring(pdata.action_card)) end
      local veto = false
      if card then
        card.setLock(false)
        if card.getGUID() == C.stacks[5] then
          card.flip()
          card.setPositionSmooth(C.king_card_position,false,false)
          Wait.condition(function() card.setLock(true) end, function() return card.resting end)
        elseif cards[card.getGUID()].special.id ~= "veto" then
          getObjectFromGUID(C.trash).putObject(card)
        end
      end
      if indexOf(G.d.action_cards, pdata.action_card) > 0 then
        if cards[card.getGUID()].special.id ~= "veto" then table.remove(G.d.action_cards, indexOf(G.d.action_cards, pdata.action_card)) end
      else
        debug("WARN: player's action card guid not in action_cards table; "..tostring(pdata.action_card))
      end
      pdata.action_card = ""
      cleanupCourt(pcol)
      resetAction()
      table.remove(G.d.players_to_play,indexOf(G.d.players_to_play,pcol))
      --advance to next player or go to bidding phase if all are done
      if #G.d.players_to_play == 0 then
        local temp = {}
        for i=#G.d.player_order,1,-1 do table.insert(temp,G.d.player_order[i]) end
        G.d.player_order = temp
        if G.d.round == 3 or G.d.round == 6 or G.d.round == 9 then startScoring()
        else startBidPhase() end
      else
        for c,pd in pairs(G.d.players) do
          pd.done = not(contains(G.d.players_to_play,c))
          updatePlayerBoardUI(c)
        end
        local n = indexOf(G.d.player_order, pcol) + 1
        if n > #G.d.player_order then n = 1 end
        G.d.active_player = G.d.player_order[n]
        G.d.players[G.d.active_player].active = true
        G.d.players[G.d.active_player].waiting = false
        updatePlayerBoardUI(G.d.active_player)
        G.d.status.waitlist[n].player_status = "Active"
        updateStatusUI(G.d.status)
      end
    end
  elseif G.d.phase == "scoring" then
    --check staged cubes, if not all placed just return doing nothing
    if pdata.staged_cubes and #pdata.staged_cubes > 0 then
      debug("player not finished placing staged cubes")
      return
    end
    pendingCubes("clear_player",pcol)
    if indexOf(G.d.waitlist,pcol) > 0 then
      for i,e in ipairs(G.d.status.waitlist) do
        if e.player_color == pcol then e.player_status = "Set"; break end
      end
      pdata.disk_button = false
      pdata.undo_button = pdata.show_disk
      pdata.done_button = false
      pdata.show_stage = false
      pdata.active = false
      pdata.done = true
      pdata.waiting = false
      updatePlayerBoardUI(pcol)
      updateStatusUI(G.d.status)
      table.remove(G.d.waitlist,indexOf(G.d.waitlist,pcol))
    else
      debug("WARN: player "..tostring(pcol).." not found in waitlist, phase: scoring")
    end
  else
    log("ERROR: playerDone() unkhown game state")
  end
end
--[[ Player clicked "Undo" button.
]]
function playerUndo(pcol)
  if env.trace then log("playerUndo() "..tostring(pcol)) end
  local pdata = G.d.players[pcol]
  if G.d.phase == "placement" then
    if indexOf(G.d.waitlist,pcol) == 0 then table.insert(G.d.waitlist,pcol) end
    for i,e in ipairs(G.d.status.waitlist) do
      if e.player_color == pcol then e.player_status = "Deciding"; break end
    end
    updateStatusUI(G.d.status)
    pdata.disk_button = true
    pdata.undo_button = false
    pdata.done_button = true
    pdata.active = true
    pdata.waiting = true
    updatePlayerBoardUI(pcol)
  elseif G.d.phase == "bidding" then
    if indexOf(G.d.players_to_bid,pcol) == 0 then table.insert(G.d.players_to_bid,pcol) end
    for i,e in ipairs(G.d.status.waitlist) do
      if e.player_color == pcol then e.player_status = ""; break end
    end
    pdata.undo_button = false
    pdata.done_button = false
    --reset selected bid button data
    local guid = C.button_guids[pdata.bid_button]
    local button_data = G.obj.bid_buttons[guid]
    button_data.selected = false
    if indexOf(button_data.players,pcol) == 0 then table.insert(button_data.players,pcol) end
    if indexOf(button_data.used,pcol) > 0 then table.remove(button_data.used,indexOf(button_data.used,pcol)) end
    --re-enable visibility for active player on all unselected buttons this player hasn't used
    for g,d in pairs(G.obj.bid_buttons) do
      if not(d.selected) and indexOf(d.players,pcol) > 0 then d.visibility = {pcol}
      else d.visibility = {} end
      updateOrderButtonUI(g,d)
    end
    pdata.bid_button = nil
    updatePlayerBoardUI(pcol)
  elseif G.d.phase == "actions" then
    local a = G.d.action
    if a.stage == "waiting" then
      if indexOf(a.waitlist,pcol) > 0 then
        for i,e in ipairs(a.status.waitlist) do
          if e.player_color == pcol then
            if a.special.placing then e.player_status = "Placing" else e.player_status = "Deciding" end; break
          end
        end
        updateStatusUI(a.status)
        if a.special.disk then
          a.waiting = a.waiting + 1
          pdata.disk_button = true
          pdata.done_button = true
        else
          pdata.done_button = false
          for g,u in pairs(a.undo.special) do
            if u.player == pcol then undo(u); a.undo.special[g] = nil end
          end
          setLockCourt(pcol, false)
        end
        pdata.undo_button = false
        pdata.active = true
        pdata.waiting = true
        updatePlayerBoardUI(pcol)
      else
        --current player selected undo, rewind entire turn
        for _,u in pairs(a.undo.court) do undo(u) end
        a.undo.court = {}
        for _,u in pairs(a.undo.special) do undo(u) end
        a.undo.special = {}
        for _,u in pairs(a.undo.main) do undo(u) end
        a.undo.main = {}
        if a.undo.reset then
          resetAction()
          pdata.action_ui = false
        end
        pdata.undo_button = false
        pdata.done_button = false
        updatePlayerBoardUI(pcol)
        updateBoardUI()
        updateCastilloUI()
      end
    else
      for _,u in pairs(a.undo.court) do undo(u) end
      a.undo.court = {}
      for _,u in pairs(a.undo.special) do undo(u) end
      a.undo.special = {}
      for _,u in pairs(a.undo.main) do undo(u) end
      a.undo.main = {}
      if a.undo.reset then
        resetAction()
        pdata.action_ui = false
      end
      pdata.undo_button = false
      pdata.done_button = false
      updatePlayerBoardUI(pcol)
      updateBoardUI()
      updateCastilloUI()
      for g,d in pairs(G.obj.bid_buttons) do
        if not(d.selected) and indexOf(d.players,pcol) > 0 then d.visibility = {pcol}
        else d.visibility = {} end
        updateOrderButtonUI(g,d)
      end
      updateStatusUI(G.d.status)
    end
  elseif G.d.phase == "scoring" then
    if indexOf(G.d.waitlist,pcol) == 0 then table.insert(G.d.waitlist,pcol) end
    for i,e in ipairs(G.d.status.waitlist) do
      if e.player_color == pcol then e.player_status = "Deciding"; break end
    end
    G.d.players[pcol].active = true
    G.d.players[pcol].waiting = true
    G.d.players[pcol].disk_button = true
    G.d.players[pcol].undo_button = false
    G.d.players[pcol].done_button = true
    updatePlayerBoardUI(pcol)
    updateStatusUI(G.d.status)
  else
    log("WARN: playerUndo() unkhown game state")
  end
end
--[[ Undo an action step.
]]
function undo(u)
  if env.trace then log("undo()") end
  local function debug(str) if true then log(str) end end --DEBUG: set false to disable verbose debug in this function
  if u.id == "select_card" then --WORKING
    debug("undo select card")
    local o = getObjectFromGUID(u.g)
    o.setLock(false)
    o.setPosition(u.snap)
    o.clearButtons()
    Wait.condition(function() o.setLock(true); o.createButton(C.card_button) end, function() return o.resting end)
    G.d.players[u.pcol].action_card = ""
  elseif u.id == "move_king" then  --WORKING
    debug("undo move king")
    getObjectFromGUID(u.g).setPosition(u.snap)
    G.obj.snaps[u.g] = u.snap
    for g,r in pairs(G.obj.regions) do
      if g == u.origin then r.king = true else r.king = false end
    end
    updateBoardUI()
  elseif u.id == "set_grande" then --TODO not using this???
  elseif u.id == "court" then  --WORKING
    debug("undo court")
    local pdata = G.d.players[u.pcol]
    local index = indexOf(pdata.court, u.g)
    if index > 0 then table.remove(pdata.court, index) end
    returnToCourt(u.pcol, u.g)
    if contains(G.d.action.pending_cubes,u.g) then pendingCubes("remove",u.g) end
    for _,r in pairs(G.obj.regions) do
      if r.caballeros[u.pcol][u.g] then r.caballeros[u.pcol][u.g] = nil; break end
    end
  elseif u.id == "prov2court" then  --WORKING
    debug("undo prov2court")
    local pdata = G.d.players[u.pcol]
    local board = getObjectFromGUID(C.player_boards[u.pcol])
    local o = getObjectFromGUID(u.g)
    o.setLock(false)
    local pos = board.positionToWorld(C.prov_pos_l[#pdata.provinces+1])
    o.setPosition(pos)
    table.insert(pdata.provinces,o.getGUID())
    table.remove(pdata.court,indexOf(pdata.court,o.getGUID()))
    o.setLock(true)
    G.obj.snaps[o.getGUID()] = pos
  elseif u.id == "court2prov" then  --WORKING
    debug("undo court2prov")
    local pdata = G.d.players[u.pcol]
    local board = getObjectFromGUID(C.player_boards[u.pcol])
    local o = getObjectFromGUID(u.g)
    o.setLock(false)
    local pos = board.positionToWorld(C.court_pos_l[#pdata.court+1])
    o.setPosition(pos)
    table.insert(pdata.court,o.getGUID())
    table.remove(pdata.provinces,indexOf(pdata.provinces,o.getGUID()))
    o.setLock(true)
    G.obj.snaps[o.getGUID()] = pos
  elseif u.id == "move_caballero" then  --WORKING
    debug("undo move caballero")
    local o = getObjectFromGUID(u.g)
    o.setLock(false); o.setPosition(u.snap)
    G.obj.snaps[u.g] = u.snap
    if contains(G.d.action.pending_cubes,u.g) then pendingCubes("remove",u.g) end
    for _,r in pairs(G.obj.regions) do
      if r.caballeros[u.color][u.g] then r.caballeros[u.color][u.g] = nil; break end
    end
    G.obj.regions[u.origin].caballeros[u.color][u.g] = true
  elseif u.id == "ret2provinces" then --WORKING
    for _,c in ipairs(u.opp) do
      log("undo() ret2provinces: reset state for opponent "..c)
      local p = G.d.players[c]
      p.active = false
      p.waiting = false
      p.show_disk = false
      p.disk_button = false
      p.undo_button = false
      p.done_button = false
      p.action_ui = false
      p.allowed_regions = {1,2,3,4,5,6,7,8,9}
      p.selected_region = math.random(1,9)
      updatePlayerBoardUI(c)
    end
  elseif u.id == "move_grande" then --WORKING
    debug("undo move grande")
    if contains(G.d.action.pending_cubes,u.g) then pendingCubes("remove",u.g) end
    local o = getObjectFromGUID(u.g)
    o.setPosition(u.snap)
    o.setVelocity(Vector(0,0,0))
    for g,r in pairs(G.obj.regions) do r.grandes[o.memo] = (g == u.origin) end
    G.obj.snaps[u.g] = u.snap
  elseif u.id == "castillo" then --WORKING
    local castillo = getObjectFromGUID(C.castillo)
    if indexOf(G.obj.castillo.caballeros[u.color],u.g) > 0 then
      table.remove(G.obj.castillo.caballeros[u.color],indexOf(G.obj.castillo.caballeros[u.color],u.g))
    else
      debug("WARN: no castillo table entry for "..tostring(u.g))
    end
    local o = castillo.takeObject({
      guid=u.g,
      callback_function = function(o)
        if u.origin == "court" then
          returnToCourt(o.memo, u.g)
        elseif u.snap then
          o.setPosition(u.snap)
          G.obj.regions[u.origin].caballeros[u.color][u.g] = true
        end
      end
    })
  elseif u.id == "disk" then --TODO: not using this?
  elseif u.id == "scoreboard" then --WORKING
    local o = getObjectFromGUID(u.g)
    local rdata = G.obj.castillo
    if u.region ~= "castillo" then rdata = G.obj.regions[u.region] end
    o.setLock(false)
    o.setPosition(u.snap)
    Wait.condition(function() o.setLock(true) end, function() return o.resting end)
    if u.region == "castillo" then
      rdata.scoring = simpleDeepCopy(C.castillo_template.scoring)
    else
      rdata.scoring = simpleDeepCopy(C.regions_template[u.region].scoring)
      object_UI_setAttribute(u.region, "mb_panel", "active", false)
    end
    rdata.score_board = false
    G.obj.snaps[u.g]=u.snap
    --handle an origin if any
    if u.origin then
      if u.origin == "castillo" then
        G.obj.castillo.scoring = simpleDeepCopy(C.mobile_score_boards[u.g].scoring)
        G.obj.castillo.score_board = u.g
      else
        local r = G.obj.regions[u.origin]
        r.score_board = u.g
        r.scoring = simpleDeepCopy(C.mobile_score_boards[u.g].scoring)
        object_UI_setAttribute(u.origin, "mb_image", "image", C.mobile_score_boards[u.g].image)
        object_UI_setAttribute(u.origin, "mb_panel", "active", true)
      end
    end
    updateBoardUI()
  elseif u.id == "score" then --WORKING
    G.d.players[u.pcol].score = G.d.players[u.pcol].score - u.points
    if G.d.players[u.pcol].score < 0 then
      debug("WARN: undo score resulted in < 0, set to 0")
      G.d.players[u.pcol].score = 0
    end
    --locate scoring marker
    local m = getObjectFromGUID(C.score_markers[u.pcol])
    local pos = Vector(C.score_marker_start_pos[u.pcol])
    if G.d.players[u.pcol].score > 0 then pos = getScorePos(u.pcol,G.d.players[u.pcol].score) end
    pos.y = pos.y + 2
    m.setName(u.pcol.." "..tostring(G.d.players[u.pcol].score))
    local scale = Vector(0.6, 0.6, 0.6)
    if G.d.players[u.pcol].score > 150 then scale.y = 6; m.setDescription("+150")
    elseif G.d.players[u.pcol].score > 100 then scale.y = 4; m.setDescription("+100")
    elseif G.d.players[u.pcol].score > 50 then scale.y = 2; m.setDescription("+50") end
    m.setScale(scale)
    m.setLock(false)
    m.setPositionSmooth(pos, false, false)
    Wait.frames(function()
      Wait.condition(function() m.setLock(true) end, function() return m.resting end)
    end,1)
  elseif u.id == "court_completed" then --WORKING
    G.d.action.court_completed = false
  elseif u.id == "special_completed" then --WORKING
    G.d.action.special_completed = false
  elseif u.id == "restore_bid" then --WORKING
    log("undo restore_bid")
    local button_data = G.obj.bid_buttons[u.g]
    table.insert(button_data.used, u.pcol)
    table.remove(button_data.players,indexOf(button_data.players,u.pcol))
    button_data.button_on = false
    button_data.visibility = {}
    updateOrderButtonUI(u.g,button_data)
  elseif u.id == "ret2prov" then --WORKING
    log("undo ret2prov") --from king returns action
    if u.origin == "court" then
      local o = getObjectFromGUID(u.g)
      o.setLock(false)
      returnToCourt(u.player,u.g)
      --HACK: returnToCourt will lock the cube so unlock it when it does TODO: add a flag to returnToCourt to skip locking
      Wait.condition(function() o.setLock(false) end, function() return o.getLock() end,2)
    else
      local o = getObjectFromGUID(u.g)
      o.setLock(false)
      o.setPosition(u.snap)
      G.obj.regions[u.origin].caballeros[u.player][u.g] = true
      updateBoardUI()
    end
    table.remove(G.d.players[u.player].provinces, indexOf(G.d.players[u.player].provinces,u.g))
    pendingCubes("remove",u.g)
    G.d.action.caballeros_moved[u.player] = G.d.action.caballeros_moved[u.player] - 1
    if G.d.action.caballeros_moved[u.player] < 0 then
      log("WARN: undo() id=ret2prov, G.d.action.caballeros_moved[u.player] < 0") --DEBUG
      G.d.action.caballeros_moved[u.player] = 0
    end
  elseif u.id == "highlight" then
    local o = getObjectFromGUID(u.g)
    if o then
      if u.state == "off" then o.highlightOff()
      else
        log("WARN: undo highlight: unhandled state "..tostring(u.state))
      end
    else
      log("WARN: undo highlight: can't find object")
    end
  else
    log("ERROR: undo() unknown id")
  end
end
--[[ Run the scoring sequence for all or some regions.
  NOTE: runs runScoring() in a coro to allow for animations, pause for player input etc.
  regions: list of region numbers to score {1,2,3,4,}, default: {1,2,3,4,5,6,7,8,9}
  special: true: this is a special scoring, false: this is a general scoring; default: false
  subtitle: subtitle text to display in a special scoring; default: empty string
]]
function startScoring(regions, special, subtitle)
  if env.trace then log("startScoring() "..tostring(special)) end
  local s_special = special or false
  local s_regions = regions or {1,2,3,4,5,6,7,8,9}
  local function sortRegions(reg)
    local temp = nil
    for _,r in ipairs(reg) do
      if not(temp) then temp = {r}
      else
        local added = false
        for i,e in ipairs(temp) do if r < e then table.insert(temp,i,r); added=true break end end
        if not(added) then table.insert(temp,#temp+1,r) end
      end
    end
    return temp
  end
  local s_castillo = false
  local s_first_only = false
  local s_sub = subtitle or ""
  if contains(s_regions,"castillo") then
    s_castillo = true
    table.remove(s_regions,indexOf(s_regions,"castillo"))
    if #s_regions > 0 then s_regions = sortRegions(s_regions) end
  elseif contains(s_regions,"first_only") then
    s_first_only = true
    s_regions = {1,2,3,4,5,6,7,8,9}
    s_castillo = false
  else
    s_castillo = not(special)
    if #s_regions > 0 then s_regions = sortRegions(s_regions) end
  end
  -- log("Scoring Special: "..tostring(s_special)) --DEBUG
  -- log("Scoring Castillo: "..tostring(s_castillo)) --DEBUG
  -- log("Scoring regions:");log(s_regions) --DEBUG
  function runScoring()
    if env.trace then log("coroutine runScoring() starting") end
    local backup = {} -- keep a backup of game state to restore at end (status UI and player buttons)
    backup.phase = G.d.phase
    backup.status = simpleDeepCopy(G.d.status)
    backup.active_player = {}
    backup.active_player.undo = G.d.players[G.d.active_player].undo_button
    backup.active_player.done = G.d.players[G.d.active_player].done_button
    backup.active_player.action_ui = G.d.players[G.d.active_player].action_ui
    -- clear active player buttons
    if not(s_special) then G.d.players[G.d.active_player].active = false end
    G.d.players[G.d.active_player].undo_button = false
    G.d.players[G.d.active_player].done_button = false
    G.d.players[G.d.active_player].action_ui = false
    updatePlayerBoardUI(G.d.active_player)
    --status data for scoring display
    local s_info = {
      show = false,
      title = "",
      msg = "",
      region = nil,
      subtitle = nil,
      scores = nil,
      summary = false,
      button = false,
    }
    --per player scoring history
    G.d.scoring_history = {Blue={},Red={},Green={},Purple={},Yellow={}}
    local summary = {}
    if s_special then
      if s_sub ~= "" then
        s_info.title = "Special Scoring"
        s_info.subtitle = s_sub
      else
        local s = ""
        for _,r in ipairs(regions) do s = s ..tostring(r)..", " end
        s_info.title = "Special Scoring"
        s_info.subtitle = "Regions to be scored:\n{"..s.."}"
      end
    else
      s_info.title = "General Scoring"
      s_info.subtitle = nil
    end
    for pcol,pdata in pairs(G.d.players) do
      log(pcol..": "..tostring(pdata.action_ui))
      if pdata.action_ui then log("set action_ui false for "..pcol); pdata.action_ui = false; updatePlayerBoardUI(pcol) end
    end
    local region_list = s_regions
    local marker = getObjectFromGUID(C.round_marker)
    G.d.phase = "scoring"
    --///////////////////// local functions ////////////////////////
    local function pause(seconds)
      if seconds == nil then seconds = 1 end
      -- log("starting pause timer for "..tostring(seconds).." seconds")  --DEBUG
      local count = 0; local t = os.time()
      while count < seconds do
        if os.time() - t > 1 then t = os.time(); count = count + 1 end
        coroutine.yield(0)
      end
      -- log("exiting pause timer")
    end
    local function updateUI(info)
      if info.show then
        UI_setAttribute("scoring_pnl","visibility",G.d.visibility_all)
        UI_setAttribute("scoring_title_txt","text",info.title)
        local h = 140
        if info.subtitle then
          UI_setAttribute("scoring_subtitle_txt","text",info.subtitle)
          h = h + 60
          UI_setAttribute("scoring_subtitle_row","active",true)
        else UI_setAttribute("scoring_subtitle_row","active",false) end
        if info.veto_check then
          UI_setAttribute("scoring_veto_row","active",true)
          UI_setAttribute("scoring_msg_row","active",false)
        else
          UI_setAttribute("scoring_veto_row","active",false)
          UI_setAttribute("scoring_msg_row","active",true)
          UI_setAttribute("scoring_msg_txt","text",info.msg)
        end
        if info.scores then h = h + 125 end
        for _,pcol in ipairs({"Blue","Red","Green","Purple","Yellow"}) do
          if info.region then UI_setAttribute(pcol.."_scoring_region_title_txt","text",info.region)
          else UI_setAttribute(pcol.."_scoring_region_title_txt","text","") end
          if info.scores then
            UI_setAttribute(pcol.."_scoring_region_row","active",true)
            for i=1,3 do
              for _,c in ipairs({"Blue","Red","Green","Purple","Yellow"}) do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_"..c,"active",false) end
              if #info.scores[i] > 0 then
                UI_setAttribute(pcol.."_scoring_"..tostring(i).."_pts_txt","text",tostring(info.scores[i][1].points.." pts"))
                for _,e in ipairs(info.scores[i]) do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_"..e.player,"active",true) end
              else UI_setAttribute(pcol.."_scoring_"..tostring(i).."_pts_txt","text","0 pts") end
              UI_setAttribute(pcol.."_scoring_"..tostring(i).."_row","active",true)
            end
          else
            for i=1,3 do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_row","active",false) end
            UI_setAttribute(pcol.."_scoring_region_row","active",false)
          end
          if info.completed and #G.d.scoring_history[pcol] > 1 then
            UI_setAttribute(pcol.."_scoring_region_prev","active",true)
            UI_setAttribute(pcol.."_scoring_region_next","active",false)
            UI_setAttribute(pcol.."_scoring_region_row","hidden",tostring(#G.d.scoring_history[pcol]))
          else
            UI_setAttribute(pcol.."_scoring_region_prev","active",false)
            UI_setAttribute(pcol.."_scoring_region_next","active",false)
          end
        end
        if info.summary then
          if info.summary_title then UI_setAttribute("scoring_summary_txt","text",info.summary_title)
          else UI_setAttribute("scoring_summary_txt","text","Running Totals") end
          local i = 0;
          -- h = h + 35
          local sh = 35
          for i=1,5 do UI_setAttribute("scoring_summary_"..tostring(i).."_row","active",false) end
          for p,s in pairs(summary) do
            i = i + 1;
            -- h = h + 30
            sh = sh + 30
            UI_setAttribute("scoring_summary_"..tostring(i).."_pnl","color",p)
            UI_setAttribute("scoring_summary_"..tostring(i).."_txt","text",p)
            UI_setAttribute("scoring_summary_score_"..tostring(i).."_txt","text",tostring(s))
            UI_setAttribute("scoring_summary_"..tostring(i).."_row","active",true)
          end
          for _,p in ipairs(G.d.player_order) do
            if not(summary[p]) then
              i = i + 1;
              -- h = h + 30
              sh = sh + 30
              UI_setAttribute("scoring_summary_"..tostring(i).."_pnl","color",p)
              UI_setAttribute("scoring_summary_"..tostring(i).."_txt","text",p)
              UI_setAttribute("scoring_summary_score_"..tostring(i).."_txt","text","0")
              UI_setAttribute("scoring_summary_"..tostring(i).."_row","active",true)
            end
          end
          UI_setAttribute("scoring_summary_row","preferredHeight",tostring(sh))
          UI_setAttribute("scoring_summary_row","height",tostring(sh))
          UI_setAttribute("scoring_summary_row","active",true)
          h = h + sh
        else UI_setAttribute("scoring_summary_row","active",false) end
        if info.button then UI_setAttribute("scoring_close_row","active",true); h = h + 40
        else UI_setAttribute("scoring_close_row","active",false) end
        UI_setAttribute("scoring_pnl","height",tostring(h))
        UI_setAttribute("scoring_pnl","visibility",G.d.visibility_all)
      else UI_setAttribute("scoring_pnl","visibility","Pink") end
    end
    local function process(scores)
      s_info.scores = {{},{},{},}
      -- log("scores:");log(scores)
      for i,e in ipairs(scores) do
        if s_first_only and i > 1 then break end
        if #e == 1 then
          local d = e[1]
          local s = "#"..tostring(i)..": "..d.player.." scores "..tostring(d.score)
          if i == 1 then
            if d.grande or d.king then s = s.." w/bonus:" end
            if d.grande then s = s.." Grande" end
            if d.king then s = s.." King" end
          end
          G.d.players[d.player].score = G.d.players[d.player].score + d.score
          if not(summary[d.player]) then summary[d.player] = d.score
          else summary[d.player] = summary[d.player] + d.score end
          table.insert(s_info.scores[i],{player=d.player,points=d.score})
          if s_special then table.insert(G.d.action.undo.special, {id="score",pcol=d.player,points=d.score}) end
          local pos = getScorePos(d.player,G.d.players[d.player].score)
          local m = getObjectFromGUID(C.score_markers[d.player])
          m.setName(d.player.." "..tostring(G.d.players[d.player].score))
          local scale = Vector(0.6, 0.6, 0.6)
          if G.d.players[d.player].score > 150 then scale.y = 6; m.setDescription("+150")
          elseif G.d.players[d.player].score > 100 then scale.y = 4; m.setDescription("+100")
          elseif G.d.players[d.player].score > 50 then scale.y = 2; m.setDescription("+50") end
          m.setScale(scale)
          m.setLock(false)
          m.setPositionSmooth(pos, false, false)
          Wait.condition(function() m.setLock(true) end, function() return m.resting end)
        elseif #e > 1 then
          local s = "Players"
          for _,d in ipairs(e) do
            G.d.players[d.player].score = G.d.players[d.player].score + d.score
            if not(summary[d.player]) then summary[d.player] = d.score
            else summary[d.player] = summary[d.player] + d.score end
            table.insert(s_info.scores[i],{player=d.player,points=d.score})
            if s_special then table.insert(G.d.action.undo.special, {id="score",pcol=d.player,points=d.score}) end
            local pos = getScorePos(d.player,G.d.players[d.player].score)
            local m = getObjectFromGUID(C.score_markers[d.player])
            m.setName(d.player.." "..tostring(G.d.players[d.player].score))
            local scale = Vector(0.6, 0.6, 0.6)
            if G.d.players[d.player].score > 150 then scale.y = 6; m.setDescription("+150")
            elseif G.d.players[d.player].score > 100 then scale.y = 4; m.setDescription("+100")
            elseif G.d.players[d.player].score > 50 then scale.y = 2; m.setDescription("+50") end
            m.setScale(scale)
            m.setLock(false)
            m.setPositionSmooth(pos, false, false)
            Wait.condition(function() m.setLock(true) end, function() return m.resting end)
          end
        end
      end
      --save the history of this scoring
      for c,h in pairs(G.d.scoring_history) do
        if contains(G.d.player_order,c) then
          table.insert(h,{region=s_info.region,scores=simpleDeepCopy(s_info.scores)})
        end
      end
    end
    -- /////////////////// Veto check for a special scoring //////////
    if s_special then
      local s = "[ "
      if s_castillo then s = s.."Casatillo" end
      if s_castillo and #s_regions > 0 then s = s..", " end
      for i,r in ipairs(s_regions) do
        s = s..tostring(r)
        if i < #s_regions then s = s..", " end
      end
      s = s.." ]"
      s_info.subtitle = "Regions to be scored:\n"..s
      s_info.show = true
      if G.d.veto then
        s_info.veto_check = true
        updateUI(s_info)
        log("Pause a special scoring for a veto check. ---TODO: move out of coro into startScoring()?")
        G.d.confirm_lock = true
        UI_setAttribute("veto_msg_txt","text","Veto Special Scoring?")
        UI_setAttribute("veto_pnl","active",true)
        UI_setAttribute("scoring_veto_msg_txt","text","Waiting on Veto Player")
        while G.d.confirm_lock do coroutine.yield(0) end --TODO: can this veto check move into startScoring()?? get it out of the coroutine
        if G.d.action.vetoed then
          log("Special scoring canceled by veto")
          UI_setAttribute("scoring_pnl","active",false)
          log("exit runScoring() coro")
          return(1)
        else
          s_info.veto_check = false
          updateUI(s_info)
        end
      else
        s_info.veto_check = false
        updateUI(s_info)
      end
    end
    -- /////////////////// Secret region selection ///////////////////
    local skip_castillo = false --flag for no cubes in Castillo, set in next block if not
    if not(s_special) then
      --see if Castillo is empty
      skip_castillo = true
      for _,l in pairs(G.obj.castillo.caballeros) do
        if #l > 0 then skip_castillo = false; break end
      end
      -- log("skip castillo is "..tostring(skip_castillo)) --DEBUG
      if skip_castillo then
        s_info.msg = "No Caballeros in the Castillo"
        s_info.show = true
        updateUI(s_info)
      else
        -- all players select destnation region secretly
        s_info.msg = "Players with Caballeros in \nCastillo secretly select a region"
        s_info.show = true
        updateUI(s_info)
        marker.setLock(false)
        marker.setPositionSmooth(C.round_scoring_positions[1],false,false)
        Wait.condition(function() marker.setLock(true) end, function() return marker.resting end)
        G.d.status = {}
        G.d.status.info = "Secretly select a destination region\nKing's region -> return to Court!"
        G.d.status.waitlist = {}
        G.d.waitlist = {}
        for i=1,5 do
          if i <= #G.d.player_order then
            local pcol = G.d.player_order[i]
            if #G.obj.castillo.caballeros[pcol] > 0 then
              table.insert(G.d.status.waitlist,{player_color=pcol,player_status="Deciding"})
              table.insert(G.d.waitlist, pcol)
              G.d.players[pcol].active = true
              G.d.players[pcol].waiting = true
              G.d.players[pcol].done_button = true
              G.d.players[pcol].undo_button = false
              G.d.players[pcol].show_disk = true
              G.d.players[pcol].show_stage = false
              G.d.players[pcol].disk_button = true
              G.d.players[pcol].allowed_regions = {1,2,3,4,5,6,7,8,9}
              G.d.players[pcol].selected_region = math.random(1,9)
              updatePlayerBoardUI(pcol)
            end
          end
        end
        if #G.d.waitlist > 0 then
          G.d.status.show = true
          updateStatusUI(G.d.status)
          while #G.d.waitlist > 0 do coroutine.yield(0) end -- pause until waitlist empty
          log("runScoring(): exit wait 1")
          for i,pcol in ipairs(G.d.player_order) do
            local pdata = G.d.players[pcol]
            pdata.active = pcol == G.d.active_player
            pdata.waiting = false
            pdata.undo_button = false
            pdata.done_button = false
            pdata.show_disk = false
            updatePlayerBoardUI(pcol)
          end
        end
      end
    end
    -- /////////////////// score the Castillo ////////////////////////
    if s_castillo and not(skip_castillo) then
      if not(s_special) then
        marker.setLock(false)
        marker.setPositionSmooth(C.round_scoring_positions[2],false,false)
        Wait.condition(function() marker.setLock(true) end, function() return marker.resting end)
      end
      s_info.msg = "Score the Castillo"
      s_info.region = "Castillo"
      s_info.scores = {{},{},{},}
      s_info.summary = true
      s_info.show = true
      updateUI(s_info)
      getObjectFromGUID(C.castillo).highlightOn("Yellow")
      local scores = scoreRegion("castillo")
      if #scores > 0 then process(scores) end
      pause()
      updateUI(s_info)
      getObjectFromGUID(C.castillo).highlightOff()
      pause(2)
    end
    -- /////////// Place cubes from Castillo in regions ///////////////
    if not(s_special) then
      local placement = false
      for _,list in pairs(G.obj.castillo.caballeros) do if #list > 0 then placement = true; break end end
      if placement then
        s_info.msg = "Move Caballeros to regions\nWaiting on players to place."
        s_info.scores = nil
        s_info.region = nil
        s_info.show = true
        updateUI(s_info)
        marker.setLock(false)
        marker.setPositionSmooth(C.round_scoring_positions[3],false,false)
        Wait.condition(function() marker.setLock(true) end, function() return marker.resting end)
        G.d.status.info = "General Scoring\nPlace staged Caballeros"
        G.d.status.info = G.d.status.info.."\nPress Done when finished"
        G.d.status.waitlist = {}
        G.d.waitlist = {}
        local castillo = getObjectFromGUID(C.castillo)
        for p,list in pairs(G.obj.castillo.caballeros) do
          if #list > 0 then
            local board = getObjectFromGUID(C.player_boards[p])
            local pdata = G.d.players[p]
            pdata.staged_cubes = {}
            if G.obj.regions[C.region_guids[pdata.selected_region]].king then
              --return cubes to player court (replicating returnToCourt() here because of takeObject())
              cleanupCourt(p)
              for _,g in ipairs(list) do
                local index = #G.d.players[p].court + 1
                table.insert(G.d.players[p].court, g)
                castillo.takeObject({
                  guid=g,
                  position=board.positionToWorld(C.court_pos_l[index]),
                  rotation={0,0,0},
                  smooth=true,
                  callback_function = function(o)
                    G.obj.snaps[g] = board.positionToWorld(C.court_pos_l[index])
                    o.setLock(env.lock_player_cubes)
                  end
                })
              end
            else
              -- add player to waitlist
              table.insert(G.d.status.waitlist,{player_color=p,player_status="Deciding"})
              table.insert(G.d.waitlist, p)
              pdata.active = true
              pdata.waiting = true
              pdata.show_stage = true
              pdata.show_disk = false
              pdata.undo_button = false
              pdata.done_button = false
              updatePlayerBoardUI(p)
              -- put cubes in player staging area
              for i,g in ipairs(list) do
                local pos = board.positionToWorld(C.stage_pos_l[i])
                castillo.takeObject({
                  guid=g,
                  position=pos,
                  rotation={0,0,0},
                  smooth=true, --set false if problems with collisions
                  callback_function = function(o)
                    G.obj.snaps[g] = pos
                    pendingCubes("add",g)
                    table.insert(pdata.staged_cubes,g)
                  end
                })
              end
            end
            G.obj.castillo.caballeros[p] = {}
            updateCastilloUI()
            pause()
          end
        end
        G.d.status.show = true
        updateStatusUI(G.d.status)
        while #G.d.waitlist > 0 do coroutine.yield(0) end -- pause until waitlist empty
        --reset player status after waiting
        for p,d in pairs(G.d.players) do
          if p == G.d.active_player then d.active = true end
          d.waiting = false
        end
      end
    end
    G.d.status.show = false
    updateStatusUI(G.d.status)
    -- ///////// sequentially score regions in the list ///////////////
    for _,i in ipairs(region_list) do --
      if not(s_special) then
        marker.setLock(false)
        marker.setPositionSmooth(C.round_scoring_positions[3+i],false,false)
        Wait.condition(function() marker.setLock(true) end, function() return marker.resting end)
      end
      getObjectFromGUID(C.region_guids[i]).highlightOn("Yellow")
      local scores = scoreRegion(C.region_guids[i])
      s_info.msg = "Score region "..tostring(i)..": "..G.obj.regions[C.region_guids[i]].name
      s_info.region = G.obj.regions[C.region_guids[i]].name
      s_info.scores = {{},{},{},}
      s_info.summary = true
      s_info.show = true
      updateUI(s_info)
      pause()
      if #scores == 0 then
        s_info.msg = s_info.msg.."\nNo Caballeros in the region"
        updateUI(s_info)
        pause(2)
      else
        process(scores)
        updateUI(s_info)
        pause(2)
      end
      getObjectFromGUID(C.region_guids[i]).highlightOff()
    end
    log("END OF SCORING")
    s_info.completed = true
    s_info.msg = "Scoring Finished"
    s_info.summary_title = "Final Summary"
    s_info.summary = true
    s_info.button = true
    s_info.show = true
    updateUI(s_info)
    log("Final scoring summary:"); for p,s in pairs(summary) do log(p.." scored "..tostring(s).." points") end --DEBUG
    -- ///////////// handle end of action stuffs if special action  ////////////////
    --TODO: perhaps set an "undo_ok" flag in the action when starting scoring, cleaner
    if s_special then
      local a = G.d.action
      local pdata = G.d.players[G.d.active_player]
      -- if a.special.secret then
      log("special scoring, after stuffs")
      a.special_completed = true
      if a.special.secret and a.special.players == "all" then
        a.stage = "main"
        a.undo = {main={},court={},special={},reset=false}; log("special scoring, secret, clearing undo") --DEBUG
        pdata.disable_reset = true
        pdata.allow_undo = false
        pdata.undo_button = false
      else
        a.stage = "special"
        pdata.disable_reset = false
        pdata.allow_undo = true
        pdata.undo_button = true
      end
      pdata.done_button = true
      pdata.active = true
      pdata.action_ui = true
      updatePlayerBoardUI(G.d.active_player)
    end
    -- ///////////// return to game state prior to scoring ////////////////
    G.d.phase = backup.phase
    G.d.status = backup.status
    updateStatusUI(G.d.status)
    if not(s_special) then
      if G.d.round == 9 then setEndGame()
      else startBidPhase() end
    end
    log("--- exiting runScoring() coroutine") --DEBUG
    return(1)
  end
  startLuaCoroutine(Global, "runScoring")
end
--[[ Show game end results. Set game_end phase.
--]]
function setEndGame()
  if env.trace then log("setEndGame()") end
  G.d.phase = "game_end"
  local s = G.d.status
  local temp = nil
  for c,p in pairs(G.d.players) do
    local new = {player=c,score=p.score}
    if not(temp) then temp = {new}
    else
      local found = false
      for i,e in ipairs(temp) do
        if p.score >= e.score then
          table.insert(temp,i,new)
          found=true
          break
        end
      end
      if not(found) then table.insert(temp,#temp+1,new) end
    end
  end
  s.info = "Player "..temp[1].player.." Wins!\n\nFinal Scores:"
  s.waitlist = {}
  for i,e in ipairs(temp) do
    table.insert(s.waitlist,i,{player_color=e.player,player_status=tostring(e.score)})
  end
  s.show = true
  updateStatusUI(G.d.status)
end

-- //////////// User interaction handlers //////////////////

--[[ NOTE: EXPERIMENTAL Handler for confirm dialog clicks.
  G.d.confirm_actions: a data structure that may define a number of posible actions.
    cancel: a table of cancel action parameters.
    ok: a table of ok action parameters.
    ack: a table of ack aaction parameters.
  Each of these tables may contain:
    pre: ids of actions to take before the defined function is called.
    fn: function name to execute, also params: parameters to pass in the call function.
    post: ids of actions to take after the defined function is called.
  All pre, fn, post elements are optional.
  The button id determines which possible action is performed.
  NOTE: This data structure should be TTS save data safe.  Take care when adding
    new parameters to ensure that. pre and post are always lists of ids.  Everything
  else is key:value.
--]]
function confirmClick(player, button, id)
  if env.trace then log("confirmClick() "..player.color..", "..tostring(id)) end
  assert(G.d.confirm_actions,"confirmClick() missing confirm_actions")
  local conf = G.d.confirm_actions
  local pdata = G.d.players[player.color]
  if id == "cancel" then
    if conf.cancel.pre then
      for _,pre in ipairs(conf.cancel.pre) do
        --TODO: any pre cancel fn things
      end
    end
    if conf.cancel.fn then Global.call(conf.cancel.fn,conf.cancel.params) end
    if conf.cancel.post then
      for _,post in ipairs(conf.cancel.post) do
        --TODO: any post cancel fn things
      end
    end
    UI_setAttribute("confirm_pnl","visibility","Pink")
  elseif id == "ok" then
    if conf.ok.pre then
      for _,pre in ipairs(conf.ok.pre) do
        if pre == "end_actions" then
          G.d.action.court_completed = true
          G.d.action.special_completed = true
        end
      end
    end
    if conf.ok.fn then Global.call(conf.ok.fn,conf.ok.params) end
    if conf.ok.post then
      for _,post in ipairs(conf.ok.post) do
        --TODO: any post ok fn things
      end
    end
    UI_setAttribute("confirm_pnl","visibility","Pink")
  elseif id == "ack" then
    --TODO: ack stuffs
  else
    log("ERROR: confirmClick() unhandled id")
  end
  G.d.confirm_lock = false
end
--[[ Handle object drops by players.
  Object tags supported: Caballero, Grande, King, ScoreBoard
  snapBack() if not in the actions phase.
  Call appropriate handler for the respective object tag.
  NOTE: Multiple Physics.cast() per object dropped.
  TODO: if outside current Region, snapBack if not in a valid move action
  TODO: handle drop on playerboard (return to Court/Province)
  TODO: Add a tile under Castillo (Castillo base?) use that to detect Castillo in Physics.cast.
        Explicity add to Castillo bag in addToCastillo(), then get rid of tryObjectEnter() and
        all script on the Castillo bag
]]
--TODO: handle playing delayed action from card in hand
function onObjectDrop(pcol, obj)
  if env.ignore_drop then return end --DEVELOPMENT
  if G.d.phase == "" then return end --game not started
  if not(obj.hasTag("Caballero") or obj.hasTag("Grande") or obj.hasTag("King") or obj.hasTag("ScoreBoard") or obj.hasTag("Veto")) then log("no tag"); return end
  if obj.hasTag("Veto") then
    --TODO: should this immediately trigger the veto?  Just display dialog for now. confirm_lock should block any actions
    log(pcol.." dropped Veto card")
    if contains(Player[pcol].getHandObjects(), obj) then log("in hand"); return end --ignore moving in hand
    if pcol ~= G.d.veto then obj.deal(1,G.d.veto); log("player not veto player"); return end
    if G.d.phase ~= "actions" then obj.deal(1,pcol); log("not actions phase") return end
    if not(G.d.action.allow_veto) then obj.deal(1,pcol); log("action veto not allowed"); return end
    G.d.confirm_lock = true
    UI_setAttribute("veto_pnl","hidden","re_deal")
    UI_setAttribute("veto_pnl","active",true)
    return
  end
  if G.d.confirm_lock then snapBack(obj.getGUID()); return end
  local region,board,castillo = nil,nil,nil
  local pos = Player[pcol].getPointerPosition();pos.y = 0
  local hits = Physics.cast({origin = pos,direction = {0,1,0,},type = 1,debug = false,})
  for _,hit in ipairs(hits) do
    if hit.hit_object.hasTag("Region") then region = hit.hit_object.getGUID(); break
    elseif hit.hit_object.hasTag("PlayerBoard") then board = hit.hit_object.getGUID(); break
    elseif hit.hit_object.getGUID() == C.castillo_base then castillo = true; break
    end
  end
  if not(region or board or castillo) then snapBack(obj.getGUID()); return end
  if obj.hasTag("Caballero") then
    if region then
      if G.obj.regions[region].caballeros[obj.memo][obj.getGUID()] then
        G.obj.snaps[obj.getGUID()] = obj.getPosition()
        return --ignore same region
      else
        --TODO: check for action state == "staging" and if pcol ~= obj.memo then snapBack(obj.getGUID()); return
      end
      if not(addCaballero(pcol, region, obj.memo, obj.getGUID())) then snapBack(obj.getGUID()); return end
      G.obj.snaps[obj.getGUID()] = obj.getPosition()
    elseif board then
      log("dropped Caballero on player board "..board)
      local a = G.d.action
      local guid = obj.getGUID()
      local success = false
      if a.stage == "waiting" and a.special.id == "king_returns" then
        if not(G.d.players[pcol].active) then log(pcol.." not the active deciding player"); snapBack(guid); return end
        local origin = nil
        if pcol == obj.memo and pcol == keyOf(C.player_boards, board) then
          if a.caballeros_moved[pcol] == a.special.max then log(pcol.." has returned max cubes"); snapBack(guid); return end
          --get the object origin (region or court), remove it when found
          if indexOf(G.d.players[pcol].court, guid) > 0 then
            origin = "court"; table.remove(G.d.players[pcol].court,indexOf(G.d.players[pcol].court, guid))
          else
            for g,r in pairs(G.obj.regions) do
              if r.caballeros[pcol][guid] then origin = g; r.caballeros[pcol][guid] = nil; break end
            end
          end
          assert(origin, "onObjectDrop() king_returns action; failed to detect origin")
          a.undo.special[guid] = {id="ret2prov", g=guid, player=pcol, origin=origin, snap=G.obj.snaps[guid]}
          returnToProvinces(pcol, guid)
          pendingCubes("add",guid)
          a.caballeros_moved[pcol] = a.caballeros_moved[pcol] + 1
          if a.caballeros_moved[pcol] == 1 then
            G.d.players[pcol].undo_button = true
            updatePlayerBoardUI(pcol)
          end
          if a.caballeros_moved[pcol] == a.special.max then
            log(pcol.." has returned the required number of cubes")
            G.d.players[pcol].done_button = true
            updatePlayerBoardUI(pcol)
          end
          updateBoardUI()
          success = true
          --set active player buttons to disable undo/reset/done
          local pd = G.d.players[G.d.active_player]
          pd.undo_button = false
          pd.done_button = false
          pd.disable_reset = true
          pd.allow_undo = false
          updatePlayerBoardUI(G.d.active_player)
        end
      elseif a.special.id == "ret2provinces" then
        if a.special.each then
          local origin = nil
          for g,r in pairs(G.obj.regions) do
            if r.caballeros[obj.memo][guid] then origin = g; r.caballeros[obj.memo][guid] = nil; break end
          end
          if not(origin) then
            log("ERROR: onObjectDrop(): ret2provinces, caballero "..guid.." not found in any region")
          elseif not(G.d.players[pcol].active) then
            log("onObjectDrop(): ret2provinces, cube dropped on board by non-active player") --DEBUG
          elseif a.caballeros_moved[obj.memo] >= a.special.count then
            log("onObjectDrop(): ret2provinces, exceeded count for color "..obj.memo) --DEBUG
          elseif a.total_moved >= a.total_max then
            log("onObjectDrop(): ret2provinces, exceeded total moved limit of "..tostring(a.total_max)) --DEBUG
          else
            if not(a.caballeros_moved[obj.memo]) then
              log("ERROR: onObjectDrop(): ret2provinces, cube color "..obj.memo.." not in caballeros_moved list") --DEBUG
            else
              a.caballeros_moved[obj.memo] = a.caballeros_moved[obj.memo] + 1
              G.d.players[pcol].undo_button = true
              a.total_moved = a.total_moved + 1
              a.stage_status = "Moved "..tostring(a.total_moved).." / "..tostring(a.total_max)
              if a.total_moved == a.total_max then
                log(pcol.." has moved the required number of cubes") --DEBUG
                G.d.players[pcol].done_button = true
              end
              a.undo.special[guid] = {id="ret2prov", g=guid, player=obj.memo, origin=origin, snap=G.obj.snaps[guid]}
              returnToProvinces(obj.memo, obj.getGUID(), false)
              pendingCubes("add",obj.getGUID())
              updatePlayerBoardUI(pcol)
              success = true
            end
          end
        else
          log("onObjectDrop(): ret2provinces, single caballero counter not yet supported")
        end
      else
        log("ERROR: onObjectDrop(): unhandled state for Caballero dropped on a player board")
      end
      if not(success) then
        log("onObjectDrop() failed drop on player board")
        snapBack(obj.getGUID())
      end
    elseif castillo then
      local g = obj.getGUID()
      if not(addToCastillo(obj)) then  snapBack(obj.getGUID())
      else
        G.obj.snaps[g] = nil
        if G.d.action.pending_cubes[g] then G.d.action.pending_cubes[g] = nil end
      end
    end
  elseif obj.hasTag("Grande") then
    --TODO: can Grande be dropped on a player board or the Castillo?
    if G.obj.regions[region].grandes[obj.memo] then
      G.obj.snaps[obj.getGUID()] = obj.getPosition()
      return --ignore same region
    end
    if not(region) or not(setGrande(region, obj.memo)) then snapBack(obj.getGUID()); return end
    G.obj.snaps[obj.getGUID()] = obj.getPosition()
  elseif obj.hasTag("King") then
    if G.obj.regions[region].king and not(G.d.phase == "placement") then
      G.obj.snaps[obj.getGUID()] = obj.getPosition()
      return --ignore dupes (except during placement)
    end
    if not(region) or not(setKing(region)) then snapBack(obj.getGUID()) end
    G.obj.snaps[obj.getGUID()] = obj.getPosition()
  elseif obj.hasTag("ScoreBoard") then
    log("dropped mobile scoreboard") --DEBUG
    if region then addScoreBoard(region, obj.getGUID())
    elseif castillo then addScoreBoard("castillo", obj.getGUID())
    else snapBack(obj.getGUID()) end
  end
end
--[[ Handler for the Veto dialog
--]]
function vetoClick(player, button, id)
  if env.trace then log("vetoClick() "..player.color..", "..tostring(id)) end
  if player.color ~= G.d.veto then log("ignore non veto player"); return end --ignore other players
  if id == "veto_yes" then
    log("---TESTING: Do the veto")
    G.d.veto = nil
    G.d.action.ignore_wait = true --TODO: no coro (remove when all coro's safe)
    G.d.action.vetoed = true --signal to processAction(), runScoring(), anything waiting
    G.d.action.waitlist = {}
    G.d.action.waiting = 0
    G.d.confirm_lock = false --TODO: before or after processAction()??
    G.d.players[G.d.active_player].active = true
    G.d.players[G.d.active_player].allow_undo = false
    G.d.players[G.d.active_player].action_ui = true
    G.d.players[G.d.active_player].disable_reset = true
    G.d.phase = "actions"
    processAction(G.d.active_player, "finished")
    local card = getObjectFromGUID(G.d.players[player.color].veto_card)
    assert(card, "vetoClick(): could not get veto card object")
    getObjectFromGUID(C.trash).putObject(card)
    G.d.players[player.color].veto_card = nil
    UI_setAttribute("veto_pnl","active",false)
  elseif id == "veto_no" then
    log("---TESTING: decline the veto")
    if UI.getAttribute("veto_pnl", "hidden") == "re_deal" then
      local card = getObjectFromGUID(G.d.players[player.color].veto_card)
      assert(card, "vetoClick(): could not get veto card object to re_deal")
      card.deal(1,player.color)
      UI_setAttribute("veto_pnl","hidden","")
    end
    UI_setAttribute("veto_pnl","active",false)
    G.d.confirm_lock = false
    G.d.veto_declined = true
    if G.d.action.special.immediate then
      processAction(G.d.active_player, "special")
    end
  else
    log("ERROR: vetoClick(): unhandled id")
  end
end
--[[ Game start options handler
]]
function startOptions(player, value, id)
  if env.trace then log("startOptions() player: "..tostring(player.color)..", id: "..tostring(id)) end
  local setting = (value == 'True')
  if id == "verbose" then
    G.env.verbose = setting
  elseif id == "short" then
    G.env.short_game = setting
  elseif id == "intrique_king" or id == "grandissimo" or id == "inquisitor_colonies" then
    broadcastToColor("Not yet implemented", player.color)
    setting = false
  else
    log("ERROR: startOptions(): unknown id: "..tostring(id))
  end
  UI_setAttribute(id,"isOn",setting)
end
--[[ Handler for clicks on action cards. Active player selecting a card.
]]
function cardClick(card, pcol, alt)
  if env.trace then log("cardClick() "..pcol..", "..card.getGUID()) end
  if G.d.confirm_lock then return end
  if pcol ~= G.d.active_player then return end
  if G.d.phase ~= "actions" then log("cardClick() ignore card click in non-actions phase"); return end
  local pdata = G.d.players[pcol]
  local cinfo = cards[card.getGUID()]
  assert(cinfo, "cardClick() could not locate card info")
  if pdata.action_card ~= "" then log("cardClick() ignore clicks when another card is selected"); return end
  local a = G.d.action
  a.stage = "main"
  a.guid = card.getGUID()
  a.player = pcol
  a.status = {}
  a.name = cinfo.name
  a.status.waitlist = {}
  a.status.show = true
  a.court = cinfo.court
  a.undo.main[card.guid] = {id="select_card",g=card.guid,pcol=pcol,snap=card.getPosition()}
  card.clearButtons()
  if cinfo.special.id == "veto" then
    log("handle select Veto card")
    UI_setAttribute("veto_player_pnl","color",pcol)
    UI_setAttribute("veto_player_txt","text",pcol)
    a.description = "Veto card\nCourt is only action"
    a.status.info = "Active Player\nHold Veto card in hand\nCourt is only action"
    updateStatusUI(a.status)
    a.special = {}
    a.special_completed = true
    card.addTag("Veto")
    card.deal(1,pcol)
    pdata.veto_card = card.getGUID()
    table.remove(G.d.action_cards,indexOf(G.d.action_cards,card.getGUID()))
    G.d.veto = pcol
    G.d.veto_round = G.d.round
  else
    a.description = "Choose an action:"
    a.status.info = "Active Player\nChoose actions for\n"..cinfo.name
    updateStatusUI(a.status)
    for _,c in ipairs(G.d.player_order) do if c~=pcol then table.insert(a.opponents,c) end end
    a.special = simpleDeepCopy(cinfo.special)
    local board = getObjectFromGUID(C.player_boards[pcol])
    card.setPosition(board.positionToWorld(C.card_pos_l))
    Wait.condition(function() card.setLock(true) end, function() return card.resting end)
  end
  pdata.action_card = card.getGUID()
  pdata.undo_button = true
  pdata.allow_undo = true
  pdata.done_button = true
  pdata.action_ui = true
  updatePlayerBoardUI(pcol)
end
--[[ Handler for player clicking on a button in the PlayerBoard action dialog.
]]
function actionClick(player, button, id)
  if env.trace then log("actionClick() "..player.color..", "..tostring(id)) end
  if G.d.confirm_lock then return end
  local board_color = Split(id,"_")[1]
  if player.color ~= board_color then return end
  local opt= Split(id,"_")[3]
  processAction(player.color, opt)
end
--[[ TODO: Handler for clicks on the scoring dialog.
    Hide the scoring dialog from the player.
--]]
function scoringClick(player, button, id)
  if env.trace then log("scoringClick() "..player.color..", "..id) end
  local tmp = UI.getAttribute(player.color.."_scoring_region_row","hidden")
  local history_index = nil
  if tmp then history_index = tonumber(tmp) end
  -- log("History index is "..tostring(history_index))
  local function updateScoringUI(pcol, info)
    -- log("updateScoringUI() "..tostring(pcol));log(info)
    if info.region then UI_setAttribute(pcol.."_scoring_region_title_txt","text",info.region)
    else UI_setAttribute(pcol.."_scoring_region_title_txt","text","") end
    if info.scores then
      UI_setAttribute(pcol.."_scoring_region_row","active",true)
      for i=1,3 do
        for _,c in ipairs({"Blue","Red","Green","Purple","Yellow"}) do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_"..c,"active",false) end
        if #info.scores[i] > 0 then
          UI_setAttribute(pcol.."_scoring_"..tostring(i).."_pts_txt","text",tostring(info.scores[i][1].points.." pts"))
          for _,e in ipairs(info.scores[i]) do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_"..e.player,"active",true) end
        else UI_setAttribute(pcol.."_scoring_"..tostring(i).."_pts_txt","text","0 pts") end
        UI_setAttribute(pcol.."_scoring_"..tostring(i).."_row","active",true)
      end
    else
      for i=1,3 do UI_setAttribute(pcol.."_scoring_"..tostring(i).."_row","active",false) end
      UI_setAttribute(pcol.."_scoring_region_row","active",false)
    end
    if #info.scores <= 1 then
      UI_setAttribute(pcol.."_scoring_region_prev","active",false)
      UI_setAttribute(pcol.."_scoring_region_next","active",false)
    elseif history_index == #G.d.scoring_history[pcol] then
      UI_setAttribute(pcol.."_scoring_region_prev","active",true)
      UI_setAttribute(pcol.."_scoring_region_next","active",false)
    elseif history_index == 1 then
      UI_setAttribute(pcol.."_scoring_region_prev","active",false)
      UI_setAttribute(pcol.."_scoring_region_next","active",true)
    else
      UI_setAttribute(pcol.."_scoring_region_prev","active",true)
      UI_setAttribute(pcol.."_scoring_region_next","active",true)
    end
  end
  local target = Split(id,"_")[2]
  local action = Split(id,"_")[3]
  if target == "scoring" then action = Split(id,"_")[4] end
  if target == "dlg" and action == "close" then
    local vis = UI.getAttribute("scoring_pnl","visibility")
    local new = "Pink"
    local tmp = Split(vis,"|")
    for i,c in ipairs(tmp) do if c ~= player.color and c ~= "Pink" then new = new.."|"..c end end
    UI_setAttribute("scoring_pnl","visibility",new)
  elseif target == "scoring" and action == "prev" then
    local pcol = Split(id,"_")[1]
    assert(history_index, "ERROR: scoringClick(): action=prev, bad history index "..tostring(history_index)) --DEBUG
    if history_index > 1 then
      history_index = history_index - 1
      updateScoringUI(pcol, G.d.scoring_history[pcol][history_index])
      UI_setAttribute(pcol.."_scoring_region_row","hidden",tostring(history_index))
    end
  elseif target == "scoring" and action == "next" then
    local pcol = Split(id,"_")[1]
    assert(history_index, "ERROR: scoringClick(): action=next, bad history index "..tostring(history_index)) --DEBUG
    if history_index < #G.d.scoring_history[pcol] then
      history_index = history_index + 1
      updateScoringUI(pcol, G.d.scoring_history[pcol][history_index])
      UI_setAttribute(pcol.."_scoring_region_row","hidden",tostring(history_index))
    end
  else
    log("scoringClick(): unhandled action "..id)
  end
end
--[[ Handler for clicks on the secret disk.  Rotate disk to next/previous
    region based on mouse click and set accordingly in player data.
    Left click increments, Right (alt) click decrements.
]]
function diskClick(player, button, id)
  if env.trace then log("diskClick() "..player.color..", "..button..", "..id) end
  if G.d.confirm_lock then log("diskClick() confirm locked, ignoring"); return end
  local color = Split(id,"_")[1]
  if player.color ~= color then return end
  local pdata = G.d.players[player.color]
  if pdata.disk_button then
    local r = pdata.selected_region
    local index = indexOf(pdata.allowed_regions,r)
    local max = #pdata.allowed_regions
    if index == 0 then index = 1
    else
      if button == "-1" then
        if index < max then index = index + 1 else index = 1 end
      else
        if index > 1 then index = index - 1 else index = max end
      end
    end
    pdata.selected_region = pdata.allowed_regions[index]
    pdata.done_button = true
    updatePlayerBoardUI(player.color)
  end
end
--[[ Handler for player buttons on player board.
]]
function playerButton(player, button, id)
  if env.trace then log("playerButton() "..player.color..", "..tostring(id)) end
  if G.d.confirm_lock then return end
  local color = Split(id,"_")[1]
  local action = Split(id,"_")[2]
  if player.color ~= color then return end
  if action == "done" then playerDone(player.color)
  elseif action == "undo" then playerUndo(player.color)
  else log(" ERROR: playerDone() unknown action")
  end
end
--[[ Handler for player clicking on a order bid button.
]]
function bidButton(player, button, id)
  if env.trace then log("bidButton() "..player.color..", "..tostring(id)) end
  if G.d.confirm_lock then log("bidButton() confirm locked, ignoring"); return end
  if player.color ~= G.d.active_player then return end
  local pdata = G.d.players[player.color]
  local index = tonumber(Split(id,"_")[2])
  pdata.bid_button = index
  local guid = C.button_guids[index]
  local button_data = G.obj.bid_buttons[guid]
  if G.d.phase == "bidding" then
    --normal bidding click
    if not(button_data.selected)  then
      button_data.selected = player.color
      table.remove(button_data.players,indexOf(button_data.players,player.color))
      table.insert(button_data.used,player.color)
      for g,d in pairs(G.obj.bid_buttons) do
        d.visibility = {}
        updateOrderButtonUI(g,d)
      end
    else
      log("WARN: bidButton() button "..tostring(index).." already selected") --DEBUG
    end
    table.remove(G.d.players_to_bid,indexOf(G.d.players_to_bid,player.color))
    pdata.undo_button = true
    pdata.done_button = true
    updatePlayerBoardUI(player.color)
  elseif G.d.phase == "actions" then
    --click during a special action (restore bid token)
    table.remove(button_data.used,indexOf(button_data.used,player.color))
    table.insert(button_data.players,player.color)
    button_data.button_on = false
    button_data.visibility = {}
    updateOrderButtonUI(guid,button_data)
    --clear the buttons
    G.d.action.undo.special[guid] = {id="restore_bid",g=guid,pcol=player.color}
    for g,button_data in pairs(G.obj.bid_buttons) do
      button_data.button_on = false
      button_data.visibility = {}
      updateOrderButtonUI(g,button_data)
    end
    --set playerboard UI
    local a = G.d.action
    a.stage = "special"
    a.stage_status = "Power "..tostring(index).." restored"
    pdata.disable_reset = false
    pdata.allow_undo = true
    pdata.undo_button = true
    pdata.done_button = true
    pdata.action_ui = true
    updatePlayerBoardUI(player.color)
  end
end

-- //////////////// UI Updaters ///////////////////

--[[ Update Global status UI
]]
function updateStatusUI(status)
  if env.trace then log("updateStatusUI()") end
  if status.show then
    UI_setAttribute("wait_message_txt","text",status.info)
    for i=1,5 do
      if i<= #status.waitlist then
        local pcol = status.waitlist[i].player_color
        UI_setAttribute("wait_p"..tostring(i).."_pnl","color",pcol)
        UI_setAttribute("wait_p"..tostring(i).."_txt","text",pcol)
        UI_setAttribute("wait_p"..tostring(i).."_status_txt","text",status.waitlist[i].player_status)
        UI_setAttribute("wait_p"..tostring(i).."_row","active",true)
      else
        UI_setAttribute("wait_p"..tostring(i).."_row","active",false)
      end
    end
    UI_setAttribute("player_wait_pnl","height",tostring(120+(40*#status.waitlist)))
    UI_setAttribute("player_wait_pnl","active",true)
  else
    UI_setAttribute("player_wait_pnl","active",false)
  end
end
--[[ Update UIs with current state
]]
function updateBoardUI()
  if env.trace then log("updateBoardUI()") end
  local board = C.board
  for g,info in pairs(G.obj.regions) do
    local r = info.scoring_order
    local s = tostring(info.scoring[1]).." / "..tostring(info.scoring[2]).." / "..tostring(info.scoring[3])
    object_UI_setAttribute(board,"R"..tostring(r).."_S_txt","text",s)
    if info.king then
      object_UI_setClass(board,"R"..tostring(r).."_H_pnl","Light Base")
      object_UI_setClass(board,"R"..tostring(r).."_H_txt","Title M")
    else
      object_UI_setClass(board, "R"..tostring(r).."_H_pnl","Clear")
      object_UI_setClass(board, "R"..tostring(r).."_H_txt","M LGray")
    end
    for color,present in pairs(info.grandes) do
      object_UI_setAttribute(board, color.."_R"..tostring(r).."_G_pnl","active",present)
    end
    for color,list in pairs(info.caballeros) do
      object_UI_setAttribute(board, color.."_R"..tostring(r).."_C_pnl","active", (sizeOf(list) > 0))
      object_UI_setAttribute(board, color.."_R"..tostring(r).."_C_txt","text", tostring(sizeOf(list)))
    end
  end
end
--[[ Update the player board UI for a given player with current data.
]]
function updatePlayerBoardUI(pcol)
  if env.trace then log("updatePlayerBoardUI() "..tostring(pcol)) end
  local pdata = G.d.players[pcol]
  local board = C.player_boards[pcol]
  if pdata.active then
    object_UI_setAttribute(board, "active_pnl","active",true)
    object_UI_setAttribute(board, "done_pnl","active",false)
  else
    object_UI_setAttribute(board, "active_pnl","active",false)
    object_UI_setAttribute(board, "done_pnl","active",pdata.done)
  end
  if pdata.waiting then object_UI_setAttribute(board,"active_txt","text","Deciding")
  else object_UI_setAttribute(board,"active_txt","text","Active") end
  object_UI_setAttribute(board, "secret_disk","active",pdata.show_disk)
  object_UI_setAttribute(board, "disk","rotation",C.disk_rotations[pdata.selected_region])
  object_UI_setAttribute(board, pcol.."_undo","active",pdata.undo_button)
  if pdata.undo_button then
    if pdata.waiting or pdata.show_disk then object_UI_setAttribute(board, pcol.."_undo","text","Undo")
    else object_UI_setAttribute(board, pcol.."_undo","text","Undo Turn") end
  end
  object_UI_setClass(board, pcol.."_undo","")
  object_UI_setAttribute(board, pcol.."_done","active",pdata.done_button);object_UI_setClass(board, pcol.."_done","")
  if pdata.disk_button then
    object_UI_setClass(board, "pointer","diskButton")
  else
    object_UI_setClass(board, "pointer","") --BUG: doesn't work, workaround: ignore clicks in diskClick()
  end
  if pdata.show_stage then
    object_UI_setAttribute(board,"stage_title_txt","text","Move to "..G.obj.regions[C.region_guids[pdata.selected_region]].name)
    object_UI_setAttribute(board,"stage_pnl","active",true)
  else
    object_UI_setAttribute(board,"stage_pnl","active",false)
  end
  if pdata.action_ui then
    local a = G.d.action
    object_UI_setAttribute(board, "action_desc_txt", "text", a.description)
    if a.stage == "main" then
      object_UI_setAttribute(board, "action_court_row","active",true)
      object_UI_setAttribute(board, "action_special_row","active",true)
      object_UI_setAttribute(board, "action_stage_row","active",false)
      if a.court_completed then
        object_UI_setAttribute(board, "action_court_pnl","active",false)
        object_UI_setAttribute(board, "action_court_finished","active",true)
      else
        object_UI_setAttribute(board, "action_court_pnl","active",true)
        object_UI_setAttribute(board, "action_court_finished","active",false)
      end
      if a.special_completed then
        object_UI_setAttribute(board, "action_special_pnl","active",false)
        object_UI_setAttribute(board, "action_special_finished","active",true)
      else
        object_UI_setAttribute(board, "action_special_pnl","active",true)
        object_UI_setAttribute(board, "action_special_finished","active",false)
      end
    elseif a.stage == "court" then
      object_UI_setAttribute(board, "action_court_row","active",false)
      object_UI_setAttribute(board, "action_special_row","active",false)
      object_UI_setAttribute(board, "action_stage_row","active",true)
      local str = "Moved "..tostring(a.caballeros_moved).." / "
      str=str..tostring(a.court)
      object_UI_setAttribute(board, "stage_status_txt","text",str)
      object_UI_setAttribute(board, "stage_status_row","active",true)
      object_UI_setAttribute(board, "stage_finished_row","active",true)
      object_UI_setAttribute(board, "stage_finished_placeholder_row","active",false)
      object_UI_setAttribute(board, "stage_reset_row","active",not(pdata.disable_reset))
    elseif a.stage == "special" then
      object_UI_setAttribute(board, "action_court_row","active",false)
      object_UI_setAttribute(board, "action_special_row","active",false)
      object_UI_setAttribute(board, "action_stage_row","active",true)
      object_UI_setAttribute(board, "stage_status_txt","text",a.stage_status)
      object_UI_setAttribute(board, "stage_status_row","active",true)
      object_UI_setAttribute(board, "stage_finished_row","active",true)
      object_UI_setAttribute(board, "stage_finished_placeholder_row","active",false)
      object_UI_setAttribute(board, "stage_reset_row","active",not(pdata.disable_reset))
    elseif a.stage == "waiting" then
      object_UI_setAttribute(board, "action_court_row","active",false)
      object_UI_setAttribute(board, "action_special_row","active",false)
      object_UI_setAttribute(board, "action_stage_row","active",true)
      object_UI_setAttribute(board, "stage_status_txt","text","Waiting on selections")
      object_UI_setAttribute(board, "stage_status_row","active",true)
      object_UI_setAttribute(board, "stage_finished_row","active",false)
      object_UI_setAttribute(board, "stage_finished_placeholder_row","active",true)
      object_UI_setAttribute(board, "stage_reset_row","active",not(pdata.disable_reset))
    else
      log("WARN: updatePlayerBoardUI() unknown action stage")
    end
    object_UI_setAttribute(board, "action_pnl","active",true)
  else
    object_UI_setAttribute(board, "action_pnl","active",false)
  end
end
--[[ Update the UI for an Order Bidding button with current state.
]]
function updateOrderButtonUI(guid, button_data)
  if env.trace then log("updateOrderButtonUI() Button "..tostring(button_data.number)) end
  -- log(button_data)
  if button_data.button_on then
    local str="Pink"
    for _,c in ipairs(button_data.visibility) do str = str .."|"..c end
    object_UI_setAttribute(guid,"button","visibility",str)
  end
  object_UI_setAttribute(guid,"button","active",button_data.button_on)
  if button_data.selected then
    object_UI_setAttribute(guid,"player_pnl","color",button_data.selected)
    object_UI_setAttribute(guid,"player_txt","text",button_data.selected)
    object_UI_setAttribute(guid,"selected","active",true)
    -- object_UI_setAttribute(guid,"button","active",false)
    -- object_UI_setAttribute(guid,"used","active",false)
  else
    object_UI_setAttribute(guid,"selected","active",false)
    -- object_UI_setAttribute(guid,"used","active",true)
  end
  local str="Pink"
  for _,c in ipairs(button_data.used) do str = str .."|"..c end
  object_UI_setAttribute(guid,"used","visibility",str)
  object_UI_setAttribute(guid,"used","active",#button_data.used > 0)
  if #button_data.players > 0 then
    object_UI_setAttribute(guid,"info_row_2","active",#button_data.players > 3)
    for i,player in ipairs(button_data.players) do
      local initial = string.sub(player, 1, 1)
      object_UI_setAttribute(guid,"info_"..tostring(i).."_pnl","color",player)
      object_UI_setAttribute(guid,"info_"..tostring(i).."_txt","text",initial)
      object_UI_setAttribute(guid,"info_"..tostring(i).."_pnl","active",true)
    end
    for i=#button_data.players+1,5 do
      object_UI_setAttribute(guid,"info_"..tostring(i).."_pnl","active",false)
    end
    object_UI_setAttribute(guid,"info","active",true)
  else
    object_UI_setAttribute(guid,"info","active",false)
  end
end
--[[ Update Castillo UI with current data
]]
function updateCastilloUI()
  if env.trace then log("updateCastilloUI()") end
  for color,list in pairs(G.obj.castillo.caballeros) do
    if #list > 0 then
      object_UI_setAttribute(C.castillo,color.."_txt","text",tostring(#list))
      object_UI_setAttribute(C.castillo,color.."_pnl","active",true)
    else
      object_UI_setAttribute(C.castillo,color.."_pnl","active",false)
    end
  end
end
--[[ TODO: Update Scoring UI with state of scoring progress.
]]
function updateScoringUI()
end

--//////////////// UTILITY ////////////////////////

--[[ Set the cube lock status in a player's court. Save setting in player data.
]]
function setLockCourt(pcol, locked)
  if env.trace then log("setLockCourt() "..tostring(pcol)..", "..tostring(locked)) end
  if locked == nil then locked = true end
  local pdata = G.d.players[pcol]
  for _,g in ipairs(pdata.court) do getObjectFromGUID(g).setLock(locked) end
  pdata.court_locked = locked
end
--[[ TODO: Set the cube lock status in a player's provinces. Save setting in player data.
]]
function setLockProvinces(pcol, locked)
  log("--TODO: implement setLockProvinces()")
end
--[[ Return a Caballero cube to the player's court
]]
function returnToCourt(pcol, guid)
  if env.trace then log("returnToCourt() "..tostring(pcol)..", "..tostring(guid)) end
  if contains(G.d.players[pcol].court, guid) then
    log("WARN: returnToCourt() removing "..tostring(guid).." from court for player "..tostring(pcol))   --DEBUG
    table.remove(G.d.players[pcol].court, indexOf(G.d.players[pcol].court,guid))
  end
  local o = getObjectFromGUID(guid)
  assert(o,"returnToCourt() cannot locate object for "..tostring(guid)) --DEBUG
  assert(o.hasTag("Caballero"),"returnToCourt() object "..tostring(guid).." not a Caballero")   --DEBUG
  assert(o.memo == pcol,"returnToCourt() "..tostring(o.memo).." Caballero not owned by "..pcol)   --DEBUG
  local board = getObjectFromGUID(C.player_boards[pcol])
  cleanupCourt(pcol)
  local index = #G.d.players[pcol].court + 1
  if index < 30 then
    o.setLock(false)
    o.setPosition(board.positionToWorld(C.court_pos_l[index]))
    o.setRotation({0,0,0})
    Wait.condition(function() o.setLock(true) end, function() return o.resting end)
    table.insert(G.d.players[pcol].court, guid)
    G.obj.snaps[guid] = board.positionToWorld(C.court_pos_l[index])
  else
    log("ERROR: returnToCourt() exceeded 30 cubes. "..tostring(pcol)..", "..tostring(guid)) --DEBUG
  end
end
--[[ Reorder cube positions in the court
]]
function cleanupCourt(pcol)
  if env.trace then log("cleanupCourt() "..tostring(pcol)) end
  local pdata = G.d.players[pcol]
  local board = getObjectFromGUID(C.player_boards[pcol])
  for _,g in ipairs(pdata.court) do
    local o = getObjectFromGUID(g)
    o.setLock(false)
    local pos = o.getPosition()
    pos.y = 4
    o.setPosition(pos)
  end
  for i,g in ipairs(pdata.court) do
    local o = getObjectFromGUID(g)
    o.setPosition(board.positionToWorld(C.court_pos_l[i]))
    o.setLock(pdata.court_locked)
    G.obj.snaps[g]=board.positionToWorld(C.court_pos_l[i])
  end
end
--[[ Return a Caballero cube to the player's Provinces
]]
function returnToProvinces(pcol, guid, fast)
  if not(fast) then fast = true end
  if env.trace then log("returnToProvinces() "..tostring(pcol)..", "..tostring(guid)..", fast="..tostring(fast)) end
  if contains(G.d.players[pcol].provinces, guid) then
    log("WARN: returnToProvinces() "..tostring(guid).." already in Provinces for player "..tostring(pcol))   --DEBUG
    return;
  end
  local o = getObjectFromGUID(guid)
  assert(o,"returnToProvinces() cannot locate object for "..tostring(guid))   --DEBUG
  assert(o.hasTag("Caballero"),"returnToProvinces() object "..tostring(guid).." not a Caballero")   --DEBUG
  assert(o.memo == pcol,"returnToProvinces() "..tostring(o.memo).." Caballero not owned by "..pcol)   --DEBUG
  local board = getObjectFromGUID(C.player_boards[pcol])
  -- cleanupCourt(pcol) --TODO: why? probably copy & paste from returnToCourt ;)
  local index = #G.d.players[pcol].provinces + 1
  if index < 30 then
    o.setLock(false)
    -- o.setPosition(board.positionToWorld(C.prov_pos_l[index]))
    o.setPositionSmooth(board.positionToWorld(C.prov_pos_l[index]), false, fast)
    o.setRotation({0,0,0})
    Wait.condition(function() o.setLock(true) end, function() return o.resting end)
    table.insert(G.d.players[pcol].provinces, guid)
    G.obj.snaps[guid] = board.positionToWorld(C.prov_pos_l[index])
  else
    log("ERROR: returnToProvinces() exceeded 30 cubes. "..tostring(pcol)..", "..tostring(guid)) --DEBUG
  end
end
--[[ Reorder cube positions in the court
]]
function cleanupProvinces(pcol)
  if env.trace then log("cleanupProvinces() "..tostring(pcol)) end
  local pdata = G.d.players[pcol]
  local board = getObjectFromGUID(C.player_boards[pcol])
  for _,g in ipairs(pdata.provinces) do
    local o = getObjectFromGUID(g)
    local pos = o.getPosition()
    pos.y = 4
    o.setLock(false)
    o.setPosition(pos)
  end
  for i,g in ipairs(pdata.provinces) do
    local o = getObjectFromGUID(g)
    o.setPosition(board.positionToWorld(C.prov_pos_l[i]))
    o.setLock(pdata.provinces_locked)
  end
end
--[[ Coroutine: flash pending cubes in an action between cube color and White.
  NOTE: EXPERIMENTAL trying this idea out.  Needs lots of testing with things
  like the Castillo.
  Checks done to prevent coro from failing if any cube objects go missing
  from being dropped ina container etc.
]]
function flashCubes()
  if env.trace then log("Starting coro flashCubes()") end
  local n = 0
  local flash = false
  local cycles = 0
  while true do
    if n >= env.flasher_rate then
      cycles = cycles + 1
      if cycles > env.flasher_debug_cycles then
        if env.flasher_debug then log("Flasher queue:");log(G.d.action.pending_cubes);cycles=0 end
      end
      for _,g in ipairs(G.d.action.pending_cubes) do
        local o = getObjectFromGUID(g)
        if o then
          if flash then o.setColorTint(Color["White"])
          else o.setColorTint(Color[o.memo]) end
        end
      end
      n=0
      flash = not(flash)
    end
    n=n+1
    coroutine.yield(0)
  end
  return 1
end
--[[ Manage cubes in the action pending_cubes queue.
  See: flashCubes()
  Required parameters:
  action: "add"|"remvoe"|"clear"|"clear_player"
  guid: guid of cube in pending_cubes queue (or player color in case of action == clear_player)
]]
function pendingCubes(action, guid)
  if env.trace then log("pendingCube() "..tostring(action)..", "..tostring(guid)) end
  assert(action,"pendingCube() missing action")  --DEBUG
  if action == "add" then table.insert(G.d.action.pending_cubes, guid)
  elseif action == "remove" then
    local index = indexOf(G.d.action.pending_cubes, guid)
    if index > 0 then table.remove(G.d.action.pending_cubes, index)
    else log("WARN:  pendingCube() "..tostring(guid).." not in pending_cubes queue")  --DEBUG
    end
    local o = getObjectFromGUID(guid)
    if o then o.setColorTint(Color[o.memo])
    else log("WARN:  pendingCube() no object for "..tostring(guid))  --DEBUG
    end
  elseif action == "clear" then
    local temp = simpleDeepCopy(G.d.action.pending_cubes)
    G.d.action.pending_cubes = {}
    for _,g in ipairs(temp) do
      local o = getObjectFromGUID(g)
      if o then o.setColorTint(Color[o.memo]) end
    end
  elseif action == "clear_player" then
    local temp = {}
    for _,g in ipairs(G.d.action.pending_cubes) do
      local o = getObjectFromGUID(g)
      if o and o.memo == guid then table.insert(temp,g) end
    end
    for _,g in ipairs(temp) do pendingCubes("remove", g) end
  else log("WARN: pendingCube() unknown action "..tostring(action))  --DEBUG
  end
end
--[[ Return an object back to it's most recently saved snap position.
      Used extensively throughout the code.
]]
function snapBack(guid)
  if env.trace then log("snapBack() "..tostring(guid)) end
  local pos = G.obj.snaps[guid]
  assert(pos, "snapBack() no snap pos for "..tostring(guid))
  getObjectFromGUID(guid).setPosition(pos)
end
--[[ Return a scoring marker position for the supplied color and score value.
  Will wrap around the board at 50 and again at 100.  Only valid to 150.
  El Grande scores don't go that high.  :)
]]
function getScorePos(color, val)
  if env.trace then log("getScorePos() "..tostring(color)..", "..tostring(val)) end
  assert(val >= 0 and val <= 150, "getScorePos() score value "..tostring(val).." must be between 0 and 150")
  assert(contains({"Blue","Red","Green","Purple","Yellow"},color),"getScorePos() invalid color "..tostring(color))
  if val == 0 then return C.score_marker_start_pos[color] end
  if val > 50 and val <= 100 then val = val - 50
  elseif val > 100 and val <= 150 then val = val - 100
  end
  val = val - 1
  local pos = Vector(C.score_track_first_pos)
  if val < 13 then
    pos.z = pos.z - (C.delta_Z * val)
  elseif val < 37 then
    pos.z = pos.z - (C.delta_Z * 12)
    pos.x = pos.x - (C.delta_X * (val-12))
  else
    pos.z = pos.z - (C.delta_Z * 12)
    pos.x = pos.x - (C.delta_X * (36-12))
    pos.z = pos.z + (C.delta_Z * (val-36))
  end
  return Vector(pos) - Vector(C.marker_offsets[color])
end
--[[ Return score for a region.  Returns a table of Color:Score.
  if 3 players, only return first two scoring levels.
  if 2 players, only return the first scoring level.
  All tied players drop to next lower level of score.
]]
function scoreRegion(region_guid)
  if env.trace then log("scoreRegion() "..tostring(region_guid)) end
  local region = nil
  if region_guid == "castillo" then
    region = G.obj.castillo
  else
    region=G.obj.regions[region_guid]
  end
  log("Scoring region "..region.name) --DEBUG
  --rank players
  local rank={}
  for p,d in pairs(region.caballeros) do
    local new = {player=p,val=sizeOf(d)}
    if #rank == 0 then table.insert(rank,{new})
    else
      local f=false
      for i,e in ipairs(rank) do
        if new.val > e[1].val then table.insert(rank,i,{new}); f=true; break
        elseif new.val == e[1].val then table.insert(e,new); f=true; break end
      end
      if not(f) then table.insert(rank,{new}) end
    end
  end
  -- log("Player rank is: ");log(rank) --DEBUG
  --Assign region score levels to players by rank
  --if 3 players, only use first two scoring levels.
  --if 2 players, only use the first scoring level.
  --ties use next lower level of score.
  local result,index,max,grande,king = {},1,3,false,false
  if #G.d.player_order == 3 then max = 2
  elseif #G.d.player_order == 2 then max = 1 end
  while index <= max do
    if not(rank[index]) then break end
    if sizeOf(rank[index]) == 1 then
      local score = region.scoring[index]
      if rank[index][1].val > 0 then
        if index == 1 then
          --determine Home region and/or King bonus
          if region.grandes[rank[1][1].player] then  score = score + 2; grande = true end
          if region.king then score = score + 2; king = true end
        end
        local e = {player=rank[index][1].player,caballeros=rank[index][1].val,score=score,grande=grande,king=king,}
        table.insert(result,{e})
      end
      index = index + 1
    else --there is a tie at this rank index
      if index+1 <= max then
        local new = {}
        table.insert(result,{}) --empty row for the tie?
        for _,e in ipairs(rank[index]) do
          local score = region.scoring[index+1]
          if e.val > 0 then
            table.insert(new,{player=e.player,caballeros=e.val,score=score,})
          end
        end
        if #new > 0 then table.insert(result,new) end
      end
      index = index + 2 --skip a level
    end
  end
  return result
end
--[[ Force reload of all UI elements when somethign isn't showing.
    HACK: Linked to numpad 1 hotkey for the game.
]]
function reloadUI(player_color)
  if env.trace then log("reloadUI() "..tostring(player_color)) end
  local xml = UI.getXml()
  if xml ~= nil and #xml > 0 then UI.setXml(xml)
  else log("Global:reloadUI(): WARN: no global XML found!") end
  local n = 0
  for _,o in ipairs(getAllObjects()) do
    if not(o.hasTag("Caballero")) and not(o.hasTag("Grande")) then
      local xml = o.UI.getXml()
      if xml ~= nil and #xml > 0 then o.UI.setXml(xml); n=n+1 end
    end
  end
  broadcastToAll("All UIs reloaded.")
  log("UIs reloaded for Global and "..tostring(n).." Objects")
end

#include ~/github/tts-el_grande/Constants.ttslua
#include ~/github/tts-el_grande/Cards.ttslua
#include ~/github/tts-lib/Utils.ttslua

--/////////////// DEVELOPMENT STUFFS //////////////////

function getLocalPos(pcol)
  assert(pcol,"getLocalPos(color): Parameter color is mandatory")
  local board = getObjectFromGUID(C.player_boards[pcol])
  local n = 0
  local s = ""
  for _,o in ipairs(Player[pcol].getSelectedObjects()) do
    n=n+1
    local l = board.positionToLocal(o.getPosition())
    s=s.."{"..string.format("%.4f", l.x)..","..string.format("%.4f", l.y)..","..string.format("%.4f", l.x).."},"
    if n==5 then s=s.."\n"; n=0 end
  end
  Notes.setNotes(s)
end

function w2l(list, guid, format)
  local format = format or false
  local o = getObjectFromGUID(guid)
  local s = ""
  local n = 0
  for _,e in ipairs(list) do
    n=n+1
    local l = o.positionToLocal(e)
    if format then
      s=s.."{"..string.format("%.5f", l.x)..","
      s=s..string.format("%.5f", l.y)..","
      s=s..string.format("%.5f", l.z).."},"
    else
      s=s.."{"..tostring(l.x)..","..tostring(l.y)..","..tostring(l.z).."},"
    end
    if n==5 then s=s.."\n"; n=0 end
  end
  Notes.setNotes(s)
end

mb_color = Color.fromString("White")
function colorPick(pcol)
  assert(pcol,"colorPick(player_color): player_color is required")
  Player[pcol].showColorDialog(mb_color,
    function (c, p)
      mb_color = c
      local str = "rgba("..tostring(c.r)..","..tostring(c.g)..","..tostring(c.b)..","..tostring(c.a)..")"
      log(str)
      Notes.setNotes(str)
      getObjectFromGUID("719679").UI.setAttribute("mb_image","color",str)
    end
  )
end

function cardcheck()
  for i=1,4 do
    log("stack "..tostring(i))
    local stack = getObjectFromGUID(C.stacks[i])
    for _,c in ipairs(stack.getObjects()) do
      if not(cards[c.guid]) then
        log("Card "..c.guid.." not defined")
        stack.takeObject({guid=c.guid})
      end
    end
  end
end
