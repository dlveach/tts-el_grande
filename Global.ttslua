--[[

--TODO: document, credits, etc.
--board art: Francesco Neri https://boardgamegeek.com/image/540942/el-grande

  -TODO: track cube snapback locations for undo etc.
  -TODO: staging area for return cubes to province/court
  -TODO: highlight (decal?) cubes that have been moved during an action, before player hits done

]]
env = {}
env.version = "0.1 experimental"
env.debug = false
env.trace = true
env.trace2 = false
-- env.test_players = {"Brown","Red","Green","Purple","Yellow"}
env.test_players = {"Red","Green","Purple"}
env.in_dev = false --leave some objects interactable for dev purposes.
env.use_saved_data = false
env.ui_dedupe = false --NOTE: EXPERIMENTAL: trying to ignore dupes in UI setAttribute calls.
env.save_stats = false --log save data size every onSave() call.  Noisy.
env.lock_player_cubes = false --false for testing
--[[  defaults for game environment settings ]]
env.game_verbose = true
env.short_game = false
env.intrigue_king_exp = false --TODO: future option
env.grandissimo_exp = false --TODO: future option
env.inquisitor_colonies_exp = false --TODO: future expansion

GD = {}

function onLoad(saved_data)
  if not(env.in_dev) then getObjectFromGUID(C.board).interactable = false end
  log("*************************************")
  log("Disigner:       TBD")
  log("Artist:         TBD")
  log("Year Released:  1995")
  log("Publisher:      ")
  log("TTS Scripting:  David Veach; 2024")
  log("Version: "..env.version)
  log("*************************************")
  UI.setAttribute("game_version","text","Version "..env.version)

  if env.test_players then
    UI.setAttribute("start_title","text","After all players seated:\n*** Test Players Enabled ***")
    log("WARN: Test players enabled")
  end
  if not(env.in_dev) then
    local o = getObjectFromGUID(C.trash)
    o.interactable = false
    o.setInvisibleTo(Player.getAvailableColors())
  end
  if not(env.use_saved_data) then saved_data = "" end
  if saved_data ~= "" then
    if env.trace then log("Global:onLoad(): loading from saved data") end
    GD = JSON.decode(saved_data)
    restoreGame()
  else
    if env.trace then log("Global:onload(): initializing a fresh load") end
    --persistent UI state tables
    GD.states = {}
    GD.states.UI = {}
    GD.states.UI_class = {}
    GD.states.object_UI = {}
    GD.states.object_UI_class = {}
    --persistent environment vars
    GD.env = {}
    GD.env.verbose = env.game_verbose
    GD.env.short_game = env.short_game
    GD.env.intrigue_king_exp = env.intrigue_king_exp
    GD.env.grandissimo_exp = env.grandissimo_exp
    GD.env.inquisitor_colonies_exp = env.inquisitor_colonies_exp
    --player data
    GD.players = {}
    GD.player_order = {}
    GD.start_player = ""
    GD.current_player = ""
    --object tables
    GD.caballeros = {}  --Brown={},Red={},Green={},Purple={},Yellow={},
    GD.grandes = {}  --Brown="",Red="",Green="",Purple="",Yellow="",
    GD.orderButtons = simpleDeepCopy(C.order_buttons)
    for _,e in pairs(GD.orderButtons) do
      e.selected = false
      e.button_on = false
      e.players = {}
      e.visibility = {}
      e.used = {}
    end
    GD.regions = simpleDeepCopy(C.region_info)
    for _,e in pairs(GD.regions) do
      e.king = false
      e.grandes = {Brown=false,Red=false,Green=false,Purple=false,Yellow=false}
      e.caballeros = {Brown={},Red={},Green={},Purple={},Yellow={}}
    end
    GD.castillo = {Brown={},Red={},Green={},Purple={},Yellow={},}
    --Game data
    GD.round = 0
    GD.action_cards = {}
    GD.game_started = false
    GD.phase = ""
    --TODO: set start dialog toggles
    UI_setAttribute("start_pnl","active",true)
  end
  updateCastilloUI()
  math.randomseed(os.time())
  --set up a hotkey to trigger UI reload.
  clearHotkeys()
  addHotkey("Reload all UI", function(player_color) reloadUI(player_color) end)
end

--[[ Save game state ]]
function onSave()
  local save_data = JSON.encode(GD)
  if env.save_stats then
    log("Saved data length: "..tostring(#save_data))
    if env.debug then log(save_data) end
  end
  return save_data
end

function restoreGame()
  if env.trace then log("restoreGame()") end
  --restore Global UI setAttribute()
  for key,value in pairs(GD.states.UI) do
    local id = Split(key, ':')[1]
    local field = Split(key, ':')[2]
    if not(UI.setAttribute(id, field, value)) then
      log("WARN: restoreGame() unable to setAttribute() "..tostring(id)..", "..tostring(field)..", "..tostring(value))
    end
  end
  --restore Global UI setClass()
  for id,value in pairs(GD.states.UI_class) do
    if not(UI.setClass(id,value)) then
      log("WARN: restoreGame() unable to setClass() "..tostring(id)..", "..tostring(value))
    end
  end
  --restore object UI setAttribute()
  for key,value in pairs(GD.states.object_UI) do
    local params = Split(key,":")
    local guid = params[1]
    local id = params[2]
    local field = params[3]
    local obj = getObjectFromGUID(guid)
    assert(obj, "restoreGame() restore object attributes, unable to locate object for guid "..tostring(guid))
    if not(obj.UI.setAttribute(id, field, value)) then
      log("WARN: restoreGame() unable to setAttribute() "..tostring(guid)..":"..tostring(id)..", "..tostring(field)..", "..tostring(value))
    end
  end
  --restore object UI setClass()
  for key,value in pairs(GD.states.object_UI) do
    local params = Split(key,":")
    local guid = params[1]
    local id = params[2]
    local obj = getObjectFromGUID(guid)
    assert(obj, "restoreGame() restore objct classes, unable to locate object for guid "..tostring(guid))
    if not(obj.UI.setClass(id,value)) then
      log("WARN: restoreGame() unable to setClass() "..tostring(guid)..":"..tostring(id)..", "..tostring(value))
    end
  end

  if GD.game_started then
    updateBoardUI()()

  --   if GD.phase == "bidding" then
  --     for g,e in pairs(GD.orderButtons) do
  --       local button = getObjectFromGUID(g)
  --       button.call("updateUI",e)
  --     end
  --   elseif GD.phase == "actions" then
  --
  --     --TODO:
  --
  --   else
  --     log("ERROR: restoreGame(): unknown game phase")
  --   end
  end
end

--[[ TODO: TESTING ignoring dupes in UI wrapper calls. Cut down UI overhead.
  Need to do some stats testing to see if it is dropping any updates needed.
  NOTE: for setAttribute only, not for setClass. ]]
--[[  Wrapper function for saving Global UI attributes for game restore. ]]
function UI_setAttribute(id, field, value)
  assert(type(id) == "string", "UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "UI_setAttribute(): field must be a string")
  if env.ui_dedupe and GD.states.UI[id..":"..field] == value then return end
  if env.trace2 then log("UI_setAttribute(): "..tostring(id)..", "..tostring(field)..", "..tostring(value)) end
  UI.setAttribute(id, field, value)
  GD.states.UI[id..":"..field] = value
end

--[[  Wrapper function for saving Global UI setClass for game restore. ]]
function UI_setClass(id, value)
  assert(type(id) == "string", "UI_setClass(): id must be a string")
  assert(type(value) == "string", "UI_setClass(): value must be a string")
  -- if GD.states.UI_class[id] == value then log("skip class "..id) return end
  if env.trace2 then log("UI_setClass() "..tostring(id)..", "..tostring(value)) end
  UI.setClass(id, value)
  GD.states.UI_class[id] = value
end

--[[  Wrapper function for saving Global UI setClass for game restore. ]]
function object_UI_setClass(guid, id, value)
  assert(guid, "object_UI_setClass(): missing guid")
  assert(type(id) == "string", "object_UI_setClass(): id must be a string")
  assert(type(value) == "string", "object_UI_setClass(): value must be a string")
  local obj = getObjectFromGUID(guid)
  assert(obj, "object_UI_setAttribute() unable to locate object for guid "..tostring(guid))
  -- if GD.states.object_UI_class[guid..":"..id] == value then log("skip class "..guid..":"..id) return end
  if env.trace2 then log("UI_setClass() "..tostring(id)..", "..tostring(value)) end
  obj.UI.setClass(id, value)
  GD.states.object_UI_class[guid..":"..id] = value
end

--[[  Wrapper function for saving object UI attributes for game restore. ]]
function object_UI_setAttribute(guid, id, field, value)
  assert(guid, "object_UI_setAttribute(): missing guid")
  assert(type(id) == "string", "object_UI_setAttribute(): id must be a string")
  assert(type(field) == "string", "object_UI_setAttribute(): field must be a string")
  assert(value ~= nil, "object_UI_setAttribute(): missing value")
  local obj = getObjectFromGUID(guid)
  assert(obj, "object_UI_setAttribute() unable to locate object for guid "..tostring(guid))
  if env.ui_dedupe and GD.states.object_UI[guid..":"..id..":"..field] == value then return end
  if env.trace2 then log("object_UI_setAttribute() "..tostring(guid)..", "..tostring(id)..", "..tostring(field)..", "..tostring(value)) end
  obj.UI.setAttribute(id, field, value)
  GD.states.object_UI[guid..":"..id..":"..field] = value
end

--[[ ******************************
Game start options handler
*********************************]]
function startOptions(player, value, id)
  if env.trace then log("startOptions() player: "..tostring(player.color)..", id: "..tostring(id)) end
  local setting = (value == 'True')
  UI.setAttribute(id, "isOn", setting)
  if id == "verbose" then
    GD.env.verbose = setting
  elseif id == "short" then
    GD.env.short_game = setting
  elseif id == "intrique_king" or id == "grandissimo" or id == "inquisitor_colonies" then
    broadcastToColor("Not yet implemented", player.color)
    setting = false
  else
    log("ERROR: startOptions(): unknown id: "..tostring(id))
  end
  UI.setAttribute(id,"isOn",setting)
end

--[[ Set up the game environment.
--]]
function setupGame(player, button, id)
  if env.trace then log("setupGame() "..player.color..", "..tostring(id)) end
  UI_setAttribute("start_pnl","active",false)
  for i=1,4 do
    local g = C.stacks[i]
    local stack = getObjectFromGUID(g)
    assert(stack, "setupGame() missing card stack for guid "..tostring(g))
    stack.shuffle()
  end
  -- setup players
  local seated = getSeatedPlayers()
  if env.test_players then seated = env.test_players
  elseif #seated < 2 then
    broadcastToAll("At least 2 players required to play this game")
    return
  end
  local n = math.random(#C.table_order)
  for i=1,#C.table_order do
    local pcol = C.table_order[n]
    if contains(seated,pcol) then
      table.insert(GD.player_order,pcol)
      GD.players[pcol] = {
        grande = "",
        start_caballeros = {},
        caballeros = {},
        provinces = {},
        court = {},
        active = false,
        undo_button = false,
        done_button = false,
        show_disk = true,
        disk_button = true,
        selected_region = math.random(1,9),
      }
      if not(GD.env.intrigue_king_exp) then getObjectFromGUID(C.decks[pcol]).destruct() end
    else
      --delete all unused items for non-player colors
      getObjectFromGUID(C.decks[pcol]).destruct()
      getObjectFromGUID(C.player_boards[pcol]).destruct()
    end
    if n == #C.table_order then n=1 else n=n+1 end
  end
  for g,e in pairs(GD.orderButtons) do
    e.players = simpleDeepCopy(GD.player_order)
    e.visibility = simpleDeepCopy(GD.player_order)
  end
  object_UI_setAttribute(C.board, "regions","active",true)
  startLuaCoroutine(Global, "createPlayerCubes")
end

--[[ Create player cubes and place them.
  Runs in a coro to yield between spawn calls.  Not entirely necessary
  but I like the visual effect it creates. :)
--]]
function createPlayerCubes()
  if env.trace then log("createPlayerCubes()") end
  for _,pcol in ipairs(GD.player_order) do
    local pdata = GD.players[pcol]
    local board = getObjectFromGUID(C.player_boards[pcol])
    --Grande
    local sd = {
      position = board.positionToWorld(Vector(C.start_pos_l[1])),
      rotation = Vector(0,0,0),
    }
    sd.data = JSON.decode(C.grande_json)
    sd.callback_function = function(o)
      o.setName(pcol.." Grande")
      o.setColorTint(Color[pcol])
      o.setLock(env.lock_player_cubes)
      pdata.grande = o.getGUID()
    end
    spawnObjectData(sd)
    coroutine.yield(0)
    --Province Caballeros
    sd.data = JSON.decode(C.caballero_json)
    sd.callback_function = function(o)
      o.setName(pcol.." Caballero")
      o.setColorTint(Color[pcol])
      o.setLock(env.lock_player_cubes)
      table.insert(pdata.caballeros, o.getGUID())
      table.insert(pdata.provinces, o.getGUID())
    end
    -- Province Caballeros
    for i=1,21 do
      sd.position = board.positionToWorld(Vector(C.prov_pos_l[i]))
      spawnObjectData(sd)
      coroutine.yield(0)
    end
    --Court Caballeros
    sd.callback_function = function(o)
      o.setName(pcol.." Caballero")
      o.setColorTint(Color[pcol])
      o.setLock(env.lock_player_cubes)
      table.insert(pdata.caballeros, o.getGUID())
      table.insert(pdata.court, o.getGUID())
    end
    for i=1,7 do
      sd.position = board.positionToWorld(Vector(C.court_pos_l[i]))
      spawnObjectData(sd)
      coroutine.yield(0)
    end
    --Starting Caballeros
    sd.callback_function = function(o)
      o.setName(pcol.." Caballero")
      o.setColorTint(Color[pcol])
      o.setLock(env.lock_player_cubes)
      table.insert(pdata.caballeros, o.getGUID())
      table.insert(pdata.start_caballeros, o.getGUID())
    end
    sd.position = board.positionToWorld(Vector(C.start_pos_l[2]))
    spawnObjectData(sd)
    coroutine.yield(0)
    sd.position = board.positionToWorld(Vector(C.start_pos_l[3]))
    spawnObjectData(sd)
    coroutine.yield(0)
  end
  local c = 0
  while c < 30 do c=c+1; coroutine.yield(0) end
  startPlacementPhase()
  return 1
end

--[[ Setup for bidding on initial placement. ]]
function startPlacementPhase()
  if env.trace then log("startPlacementPhase()") end
  GD.phase = "placement"
  GD.player_waitlist = simpleDeepCopy(GD.player_order)
  local str = "Initial Placement Selection"
  str = str.."\nSecretly select starting region for"
  str = str.."\nGrande and 2 starting Caballeros"
  UI_setAttribute("wait_message_txt","text",str)
  for i=1,5 do
    if i <= #GD.player_order then
      local pcol = GD.player_order[i]
      UI_setAttribute("wait_p"..tostring(i).."_pnl","color",pcol)
      UI_setAttribute("wait_p"..tostring(i).."_txt","text",pcol)
      UI_setAttribute("wait_p"..tostring(i).."_row","active",true)
      GD.players[pcol].active = true
      GD.players[pcol].done_button = true
      object_UI_setAttribute(C.player_boards[pcol],"secret_disk","active",true)
      object_UI_setAttribute(C.player_boards[pcol],"button_pnl","active",true)
      updatePlayerBoardUI(pcol)
    else
      UI_setAttribute("wait_p"..tostring(i).."_row","active",false)
    end
  end
  UI_setAttribute("player_wait_pnl","height",tostring(140+(50*#GD.player_order)))
  UI_setAttribute("player_wait_pnl","active",true)
end

function placeStartingCubes()
  if env.trace then log("startPlacementPhase()") end
  for _,pcol in ipairs(GD.player_order) do
    local pdata = GD.players[pcol]
    local region_guid = C.region_guids[pdata.selected_region]
    local region = C.region_info[region_guid]
    local grande = getObjectFromGUID(pdata.grande)
    grande.setPosition(region.start_loc[pcol])
    setGrande(region_guid, pcol)
    --place starting caballeros
    local delta_x = {0.28, -0.32}
    local delta_z = 1.15
    for i,g in ipairs(pdata.start_caballeros) do
      local o = getObjectFromGUID(g)
      local pos = grande.getPosition()
      pos.x = pos.x - delta_x[i]
      pos.z = pos.z - delta_z
      o.setPosition(pos)
      addCaballero(region_guid, pcol, g)
    end
    pdata.start_caballeros = nil
  end
end

--[[ Setup and begin the order bidding phase ]]
function startBidPhase()
  if env.trace then log("startBidPhase()") end
  if GD.env.verbose then broadcastToAll("In current turn order players select action order bids") end
  GD.phase = "bidding"
  GD.players_to_bid = simpleDeepCopy(GD.player_order)
  local str = "Action turn order bidding"
  str = str.."\nChoose an available bid number"
  str = str.."\nX Caballeros will move to Court"
  UI_setAttribute("wait_message_txt","text",str)
  local first_player = GD.player_order[1]
  GD.current_player = first_player
  for i,pcol in ipairs(GD.player_order) do
    local pdata = GD.players[pcol]
    UI_setAttribute("wait_p"..tostring(i).."_pnl","color",pcol)
    UI_setAttribute("wait_p"..tostring(i).."_txt","text",pcol)
    if pcol == first_player then
      UI_setAttribute("wait_p"..tostring(i).."_status_txt","text","Active")
    else
      UI_setAttribute("wait_p"..tostring(i).."_status_txt","text","")
    end
    pdata.active = pcol == first_player
    pdata.undo_button = false
    pdata.done_button = false
    pdata.show_disk = false
    object_UI_setAttribute(C.player_boards[pcol],"secret_disk","active",false)
    updatePlayerBoardUI(pcol)
  end
  UI_setAttribute("player_wait_pnl","active",true)
  -- Move round marker
  GD.round = GD.round + 1
  if GD.env.short_game then
    if GD.round == 1 then GD.round = 2
    elseif GD.round == 4 then GD.round = 5
    elseif GD.round == 7 then GD.round = 8
    end
  end
  local marker = getObjectFromGUID(C.round_marker)
  marker.setPosition(C.round_marker_positions[GD.round])
  -- Reveal Action Cards
  if #GD.action_cards > 0 then
    for _,g in ipairs(GD.action_cards) do getObjectFromGUID(g).destruct() end
  end
  GD.action_cards = {}
  for i=1,4 do
    local stack = getObjectFromGUID(C.stacks[i])
    local pos = stack.getPosition()
    pos.y = pos.y + 3
    local card = stack.takeObject({
      position=pos,
      flip=true,
      callback_function = function(o)
        Wait.condition(function() o.setLock(true) end, function() return o.resting end)
      end
    })
    table.insert(GD.action_cards, card.getGUID())
  end
  local king_card = getObjectFromGUID(C.stacks[5])
  if king_card.is_face_down then
    king_card.setLock(false)
    king_card.flip()
  end
  Wait.condition(function() king_card.setLock(true) end, function() return king_card.resting end)
  -- Activate bid buttons
  for g,d in pairs(GD.orderButtons) do
    d.button_on = true
    d.selected = false
    if not(d.selected) and indexOf(d.players,first_player) > 0 then
      d.visibility = {first_player}
    else
      d.visibility = {}
    end
    updateOrderButtonUI(g,d)
  end
end

--[[ Setup and begin the action phase  ]]
function startActionPhase()
  if env.trace then log("startActionPhase()") end
  GD.phase = "actions"
  -- set player order from highest to lowest bid
  local temp = {}
  for i=13,1,-1 do
    local d = GD.orderButtons[C.button_guids[i]]
    if d.selected then
      table.insert(temp,d.selected)
      GD.players[d.selected].p2c = d.court
    end
    d.button_on = false
  end
  assert(#temp == #GD.player_order, "FATAL: startActionPhase() uable to build new player order from selected bids")
  GD.player_order = temp
  GD.start_player = GD.player_order[1]
  GD.current_player = GD.start_player
  GD.players_to_play = simpleDeepCopy(GD.player_order)
  local str = "Player Actions"
  str = str.."\nChoose an action card to play"
  str = str.."\nCaballeros move Court -> Region"
  UI_setAttribute("wait_message_txt","text",str)
  local first_player = GD.player_order[1]
  GD.current_player = first_player
  for i,pcol in ipairs(GD.player_order) do
    local pdata = GD.players[pcol]
    UI_setAttribute("wait_p"..tostring(i).."_pnl","color",pcol)
    UI_setAttribute("wait_p"..tostring(i).."_txt","text",pcol)
    if pcol == first_player then
      UI_setAttribute("wait_p"..tostring(i).."_status_txt","text","Active")
    else
      UI_setAttribute("wait_p"..tostring(i).."_status_txt","text","")
    end
    pdata.active = pcol == first_player
    pdata.undo_button = false
    pdata.done_button = false
    pdata.show_disk = false
    object_UI_setAttribute(C.player_boards[pcol],"secret_disk","active",false)
    updatePlayerBoardUI(pcol)
    -- Move Caballeros from Province to Court based on player's order button selection.
    local board = getObjectFromGUID(C.player_boards[pcol])
    for i=1,pdata.p2c do
      if #pdata.provinces > 0 then
        local o = getObjectFromGUID(pdata.provinces[#pdata.provinces])
        table.insert(pdata.court, o.getGUID())
        o.setPosition(board.positionToWorld(C.court_pos_l[#pdata.court]))
        table.remove(pdata.provinces, #pdata.provinces)
      end
    end
  end
  UI_setAttribute("player_wait_pnl","active",true)

  -- Activate buttons on action cards
  log("TODO activate buttons on cards")
  local p = {
    click_function = "cardClick",
    function_owner = Global,
    position = {0,1,0},
    width = 800,
    height = 1000,
    color = {r=0,g=0,b=0,a=0},
  }
  for i,g in ipairs(GD.action_cards) do
    local card = getObjectFromGUID(g)
    card.createButton(p)
  end
  local card = getObjectFromGUID(C.stacks[5])
  card.createButton(p)
end

--[[ Handler for clicks on action cards. Active player selecting a card. ]]
function cardClick(card, pcol, alt)
  if env.trace then log("cardClick() "..pcol..", "..card.getGUID()) end
  if pcol ~= GD.current_player then return end
  card.clearButtons()
  local pdata = GD.players[pcol]
  pdata.action_card = card.getGUID()
  --TODO; get card metadata
  if C.stacks[5] == card.getGUID() then
    card.setLock(false)
    card.flip()
    Wait.condition(function() card.setLock(true) end, function() return card.resting end)
  else
    table.remove(GD.action_cards, indexOf(GD.action_cards, card.getGUID()))
    getObjectFromGUID(C.trash).putObject(card)
  end

   --TODO: any setup for the card's action??
   log("--- TODO setup for action defined by card metadata, just testing flow for now")
   -- if secret disk, back up current action player list & set up a new wait list for the dialog.
   -- some cards may be used later, deal to player.  Handle these in onObjectDrop.
   -- some cards require actions by opponents in table order from active player.  Backup player list and use a new order for the dialog.

   GD.players[pcol].undo_button = true
   GD.players[pcol].done_button = true
   updatePlayerBoardUI(pcol)

end

--[[ Handler for player clicking on a order bid button. -- ]]
function bidButton(player, button, id)
  if env.trace then log("bidButton() "..player.color..", "..tostring(id)) end
  if player.color ~= GD.current_player then return end
  local index = tonumber(Split(id,"_")[2])
  local guid = C.button_guids[index]
  local button_data = GD.orderButtons[guid]
  if not(button_data.selected)  then
    button_data.selected = player.color
    table.remove(button_data.players,indexOf(button_data.players,player.color))
    table.insert(button_data.used,player.color)
    for g,d in pairs(GD.orderButtons) do
      d.visibility = {}
      updateOrderButtonUI(g,d)
    end
  end
  table.remove(GD.players_to_bid,indexOf(GD.players_to_bid,player.color))
  GD.players[player.color].undo_button = true
  GD.players[player.color].done_button = true
  updatePlayerBoardUI(player.color)
end

--[[ Handle object drops on regions.
  Object tags supported: Caballero, Grande, King, ScoreBoard
  Call appropriate handler for the respective object tag.
  NOTE: uses Physics.cast() per object dropped to get region under player cursor.  Possible
        opportunity for optimization here to eleminate unnecessary casts at the same spot.
        However with logging reduced it's not at all bad.
--]]
function onObjectDrop(pcol, obj)
  local function getRegion()
    local pos = Player[pcol].getPointerPosition()
    pos.y = 0
    local hits = Physics.cast({origin = pos,direction = {0,1,0,},type = 1,debug = false,})
    for _,hit in ipairs(hits) do
      if hit.hit_object.hasTag("Region") then
        hit.hit_object.highlightOn(Color["Yellow"],1)
        return hit.hit_object.getGUID()
      end
    end
  end
  if obj.hasTag("Caballero") then
    addCaballero(getRegion(), Split(obj.getName()," ")[1], obj.getGUID())
  elseif obj.hasTag("Grande") then
    setGrande(getRegion(), Split(obj.getName()," ")[1])
  elseif obj.hasTag("King") then
    setKing(getRegion())
  elseif obj.hasTag("ScoreBoard") then
    log("--- TODO: handle mobile scoreboard")
  end
end

--[[ Add a Caballero to a region. --]]
function addCaballero(region_guid, color, caballero_guid)
  if env.trace then log("addCaballero() "..region_guid..", "..color..":"..caballero_guid) end
  if GD.regions[region_guid].caballeros[color][caballero_guid] then return end --ignore dupes
  log("adding "..color.." Caballero "..caballero_guid.." to "..GD.regions[region_guid].name)
  GD.regions[region_guid].caballeros[color][caballero_guid] = true
  for g,r in pairs(GD.regions) do
    if g ~= region_guid and r.caballeros[color][caballero_guid] then r.caballeros[color][caballero_guid] = nil end
  end
  updateBoardUI()
end

--[[ Sets a Grande in a region when player drops it there. --]]
function setGrande(region_guid, color)
  if env.trace then log("setGrande() "..region_guid..", "..color) end
  if GD.regions[region_guid].grandes[color] then return end --ignore dupes
  for g,r in pairs(GD.regions) do
    if g == region_guid then r.grandes[color] = true else r.grandes[color] = false end
  end
  updateBoardUI()
end

--[[ Sets the King in a region when a player drops it there. --]]
function setKing(region_guid)
  if env.trace then log("setKing() "..tostring(region_guid)) end
  if GD.region[region_guid].king then return end
  log("setting King in "..GD.regions[region_guid].name)
  for g,region in pairs(GD.regions) do
    if g == region_guid then region.king = true else region.king = false end
  end
  updateBoardUI()
end

--[[ Adds a Caballero to the Castillo when a player drops it into the bag. --]]
function addToCastillo(params)
  if env.trace then log("addToCastillo()") end
  local color = params.color; assert(color,"addToCastillo(): parameter color missing")
  local guid = params.guid; assert(guid,"addToCastillo(): parameter guid missing")
  local type = params.type; assert(type,"addToCastillo(): parameter type missing")
  --TODO: add more state checks
  if GD.game_started then
    if type == "Caballero" then
      table.insert(GD.castillo[color],{guid})
      updateCastilloUI()
      return true
    elseif type == "Grande" then
      --TODO: check for game state allowing Grande in Castillo.  Just return false for now.
    else
      log("ERROR: addToCastillo() unknown type")
    end
  end
  if GD.env.verbose then broadcastToAll("Some objects cannot enter the Castillo") end
  return false
end

--[[ Handler for clicks on the secret disk.  Rotate disk to next/previous
    region based on mouse click and set accordingly in player data.
    Left click increments, Right (alt) click decrements.
--]]
function rotateDisk(player, button, id)
  if env.trace then log("rotateDisk() "..player.color..", "..button..", "..id) end
  local color = Split(id,"_")[1]
  if player.color ~= color then return end
  if GD.players[player.color].disk_button then
    local index = GD.players[player.color].selected_region
    if button == "-1" then
      if index < 9 then index = index + 1 else index = 1 end
    elseif button == "-2" then
      if index > 1 then index = index - 1 else index = 9 end
    end
    GD.players[player.color].selected_region = index
    GD.players[player.color].done_button = true
    updatePlayerBoardUI(player.color)
  end
end

--[[ Handler for player buttons on player board. ]]
function playerButton(player, button, id)
  if env.trace then log("playerButton() "..player.color..", "..tostring(id)) end
  local color = Split(id,"_")[1]
  local action = Split(id,"_")[2]
  if player.color ~= color then return end
  if action == "done" then playerDone(player.color)
  elseif action == "undo" then playerUndo(player.color)
  else log(" ERROR: playerDone() unknown action")
  end
end

--[[ Player clicked "Done" button. ]]
function playerDone(pcol)
  if env.trace then log("playerDone() "..tostring(pcol)) end
  if GD.phase == "placement" then
    if indexOf(GD.player_waitlist,pcol) > 0 then
      table.remove(GD.player_waitlist,indexOf(GD.player_waitlist,pcol))
      UI_setAttribute("wait_p"..tostring(indexOf(GD.player_order,pcol)).."_status_txt","text","Set")
      GD.players[pcol].disk_button = false
      GD.players[pcol].undo_button = true
      GD.players[pcol].done_button = false
      GD.players[pcol].active = false
      updatePlayerBoardUI(pcol)
      if #GD.player_waitlist == 0 then
        UI_setAttribute("player_wait_pnl","active",false)
        placeStartingCubes()
        startBidPhase()
      end
    end
  elseif GD.phase == "bidding" then
    GD.players[pcol].undo_button = false
    GD.players[pcol].done_button = false
    GD.players[pcol].active = false
    updatePlayerBoardUI(pcol)
    UI_setAttribute("wait_p"..tostring(indexOf(GD.player_order,pcol)).."_status_txt","text","Set")
    if #GD.players_to_bid == 0 then
      UI_setAttribute("player_wait_pnl","active",false)
      startActionPhase()
    else
      local n = indexOf(GD.player_order, pcol) + 1
      if n > #GD.player_order then n = 1 end
      GD.current_player = GD.player_order[n]
      GD.players[GD.current_player].active = true
      updatePlayerBoardUI(GD.current_player)
      UI_setAttribute("wait_p"..tostring(n).."_status_txt","text","Active")
      for g,d in pairs(GD.orderButtons) do
        if not(d.selected) and indexOf(d.players,GD.current_player) > 0 then
          d.visibility = {GD.current_player}
        else
          d.visibility = {}
        end
        updateOrderButtonUI(g,d)
      end
    end
  elseif GD.phase == "actions" then
    GD.players[pcol].undo_button = false
    GD.players[pcol].done_button = false
    GD.players[pcol].active = false
    updatePlayerBoardUI(pcol)
    UI_setAttribute("wait_p"..tostring(indexOf(GD.player_order,pcol)).."_status_txt","text","Done")
    table.remove(GD.players_to_play,indexOf(GD.players_to_play,pcol))
    if #GD.players_to_play == 0 then
      UI_setAttribute("player_wait_pnl","active",false)
      --reverse player order and start next bidding phase
      local temp = {}
      for i=#GD.player_order,1,-1 do table.insert(temp,GD.player_order[i]) end
      GD.player_order = temp
      startBidPhase()
    else
      local n = indexOf(GD.player_order, pcol) + 1
      if n > #GD.player_order then n = 1 end
      GD.current_player = GD.player_order[n]
      GD.players[GD.current_player].active = true
      updatePlayerBoardUI(GD.current_player)
      UI_setAttribute("wait_p"..tostring(n).."_status_txt","text","Active")
    end
  end
end

--[[ Player clicked "Undo" button. ]]
function playerUndo(pcol)
  if env.trace then log("playerUndo() "..tostring(pcol)) end
end

--[[ Update UIs with current state ]]
function updateBoardUI()
  if env.trace then log("updateBoardUI()") end
  local board = C.board
  for g,info in pairs(GD.regions) do
    local r = info.scoring_order
    if info.king then
      object_UI_setClass(board, "R"..tostring(r).."_H_pnl","Light Base")
      object_UI_setClass(board, "R"..tostring(r).."_H_txt","Title")
    else
      object_UI_setClass(board, "R"..tostring(r).."_H_pnl","Clear")
      object_UI_setClass(board, "R"..tostring(r).."_H_txt","M LGray")
    end
    for color,present in pairs(info.grandes) do
      object_UI_setAttribute(board, color.."_R"..tostring(r).."_G_pnl","active",present)
    end
    for color,list in pairs(info.caballeros) do
      object_UI_setAttribute(board, color.."_R"..tostring(r).."_C_pnl","active", (sizeOf(list) > 0))
      object_UI_setAttribute(board, color.."_R"..tostring(r).."_C_txt","text", tostring(sizeOf(list)))
    end
  end
end

function nullFn()
  log("nullFn()")
end

--[[ Update the player board UI for a given player with current data. ]]
function updatePlayerBoardUI(pcol)
  if env.trace then log("updatePlayerBoardUI() "..pcol) end
  local pdata = GD.players[pcol]
  local board = C.player_boards[pcol]
  object_UI_setAttribute(board, "active_pnl","active",pdata.active)
  object_UI_setAttribute(board, "secret_disk","active",pdata.show_disk)
  object_UI_setAttribute(board, "disk","rotation",C.disk_rotations[pdata.selected_region])
  object_UI_setAttribute(board, pcol.."_undo","active",pdata.undo_button)
  object_UI_setClass(board, pcol.."_undo","")
  object_UI_setAttribute(board, pcol.."_done","active",pdata.done_button)
  object_UI_setClass(board, pcol.."_done","")
  if pdata.disk_button then
    object_UI_setClass(board, "pointer","diskButton")
  else
    object_UI_setClass(board, "pointer","") --BUG: doesn't work, workaround: ignore clicks in rotateDisk()
  end
end

--[[ Update the UI for an Order Bidding button with current state. --]]
function updateOrderButtonUI(guid, button_data)
  if env.trace then log("updateOrderButtonUI() Button "..tostring(button_data.number)) end
  -- log(button_data)
  if button_data.button_on then
    local str="Pink"
    for _,c in ipairs(button_data.visibility) do str = str .."|"..c end
    object_UI_setAttribute(guid,"button","visibility",str)
  end
  object_UI_setAttribute(guid,"button","active",button_data.button_on)
  if button_data.selected then
    object_UI_setAttribute(guid,"player_pnl","color",button_data.selected)
    object_UI_setAttribute(guid,"player_txt","text",button_data.selected)
    object_UI_setAttribute(guid,"selected","active",true)
    object_UI_setAttribute(guid,"button","active",false)
    -- object_UI_setAttribute(guid,"used","active",false)
  else
    object_UI_setAttribute(guid,"selected","active",false)
    -- object_UI_setAttribute(guid,"used","active",true)
  end
  local str="Pink"
  for _,c in ipairs(button_data.used) do str = str .."|"..c end
  object_UI_setAttribute(guid,"used","visibility",str)
  object_UI_setAttribute(guid,"used","active",#button_data.used > 0)
  if #button_data.players > 0 then
    object_UI_setAttribute(guid,"info_row_2","active",#button_data.players > 3)
    for i,player in ipairs(button_data.players) do
      local initial = string.sub(player, 1, 1)
      object_UI_setAttribute(guid,"info_"..tostring(i).."_pnl","color",player)
      object_UI_setAttribute(guid,"info_"..tostring(i).."_txt","text",initial)
      object_UI_setAttribute(guid,"info_"..tostring(i).."_pnl","active",true)
    end
    for i=#button_data.players+1,5 do
      object_UI_setAttribute(guid,"info_"..tostring(i).."_pnl","active",false)
    end
    object_UI_setAttribute(guid,"info","active",true)
  else
    object_UI_setAttribute(guid,"info","active",false)
  end
end

--[[ Update Castillo UI with current data  ]]
function updateCastilloUI()
  if env.trace then log("updateCastilloUI()") end
  for color,list in pairs(GD.castillo) do
    if #list > 0 then
      object_UI_setAttribute(C.castillo,color.."_txt","text",tostring(#list))
      object_UI_setAttribute(C.castillo,color.."_pnl","active",true)
    else
      object_UI_setAttribute(C.castillo,color.."_pnl","active",false)
    end
  end
end


--[[ Force reload of all UI elements when somethign isn't showing.
    HACK: Linked to numpad 1 hotkey for the game.
--]]
function reloadUI(player_color)
  if env.trace then log("reloadUI() "..tostring(player_color)) end
  local xml = UI.getXml()
  if xml ~= nil and #xml > 0 then UI.setXml(xml)
  else log("Global:reloadUI(): WARN: no global XML found!") end
  local n = 0
  for _,o in ipairs(getAllObjects()) do
    if not(o.hasTag("Caballero")) and not(o.hasTag("Grande")) then
      local xml = o.UI.getXml()
      if xml ~= nil and #xml > 0 then o.UI.setXml(xml); n=n+1 end
    end
  end
  broadcastToAll("All UIs reloaded.")
  log("UIs reloaded for Global and "..tostring(n).." Objects")
end

#include ~/github/tts-el_grande/Constants.ttslua
#include ~/github/tts-el_grande/Cards.ttslua
#include ~/github/tts-lib/Utils.ttslua

--/////////////// DEVELOPMENT STUFFS //////////////////

-- function getLocalPos()
--   local board = getObjectFromGUID(C.player_boards["Brown"])
--   local n = 0
--   local s = ""
--   for _,o in ipairs(Player["Brown"].getSelectedObjects()) do
--     n=n+1
--     local l = board.positionToLocal(o.getPosition())
--     s=s.."{"..string.format("%.4f", l.x)..","..string.format("%.4f", l.y)..","..string.format("%.4f", l.x).."},"
--     if n==5 then s=s.."\n"; n=0 end
--   end
--   Notes.setNotes(s)
-- end
